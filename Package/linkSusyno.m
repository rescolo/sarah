(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)

(* ---------------------------------------------------- *)
(* 
  Functions to link Susyno by Renato Fonseca to SARAH *)
(* \
---------------------------------------------------- *)

SA`NeededInvariantsSusyno={};
SA`NeededGeneratorsSusyno={};

SusynoForm[SU[x_]]:=ToExpression["SU"<>ToString[x]];
SusynoForm[SO[x_]]:=ToExpression["SO"<>ToString[x]];
SusynoForm[E[x_]]:=ToExpression["E"<>ToString[x]];
SusynoForm[F[x_]]:=ToExpression["F"<>ToString[x]];
SusynoForm[G[x_]]:=ToExpression["G"<>ToString[x]];
SusynoForm[SP[x_]]:=ToExpression["SP"<>ToString[x]];

GetInformationSusyno[Nr_,k_]:=Block[{i,resSusyno,temp},
      resSusyno = CallSusyno[Fields[[Nr,k+3]],Gauge[[k,2]]];
      MakeGroupConstants[Nr,k,resSusyno[[2]],resSusyno[[3]],resSusyno[[4]],
        resSusyno[[5]]];
      Generator[Gauge[[k,2]],k,FieldDim[Nr,k],lor_,p1_,
          p2_]=(Hold[
              TA[DIMGAUGE,DIM,genf[lor],listIndizes[[GAUGE,1]]/.subGC[p1],
                listIndizes[[GAUGE,1]]/.subGC[p2]]] /. {DIMGAUGE \[Rule] 
                Gauge[[k,2]],DIM\[Rule]FieldDim[Nr,k],GAUGE\[Rule]k});
      
      SA`NeededGeneratorsSusyno= 
        Join[SA`NeededGeneratorsSusyno,{{Gauge[[k,2]],FieldDim[Nr,k],
              DynkinLabels[Gauge[[k,2]],Fields[[Nr,3]]]}}];
      
      temp= {Gauge[[k,3]]};
      For[i=1,i\[LessEqual]Length[temp],
        If[Gauge[[k,5]]\[Equal]False,
          
          notShort = 
              Join[notShort,{ToExpression[
                    ToString[temp[[i]]]<>appendIndex[[i]]]}];,
          
          expShort = 
              Join[expShort,{ToExpression[
                    ToString[temp[[i]]]<>appendIndex[[i]]]}];
          ];
        i++;];
      NonSUNindices=Intersection[Join[NonSUNindices,{Gauge[[k,3]]}]];
      DynkinLabels[Gauge[[k,2]],Fields[[Nr,3]]]=resSusyno[[6]];
      ConjDynkinLabels[Gauge[[k,2]],Fields[[Nr,3]]]=ConjResSusyno[[6]];
      If[FieldDim[Nr,k]<0 && Head[Fields[[Nr,k+3]]]=!=List, temp = - temp;];
      If[Gauge[[k,5]]\[Equal]False,
        notExpanded=Join[notExpanded,temp];,
        expanded=Join[expanded,temp];
        ];
      ];




CallSusyno[rep_,group_]:=
    Block[{dim,dimS,dynkin,temp,pos,checkvariableexistsSARAH,DL},
      If[SusynoLoaded=!=True,
          Message[SARAH::UnknownGaugeGroup,group];
          Interrupt[];,
          
          If[Head[rep]===List,dimS=rep[[1]]; dynkin=rep[[2]];,dimS=rep; 
            dynkin=None];
          dim=Abs[dimS];
          temp = SARAHCheckIrrep[dim,{ToString[Head[group]],group[[1]]}];
          If[dynkin===None && Length[temp]\[LessEqual] 2,
            If[dim\[Equal]dimS,
                
                If[Length[temp]\[Equal]1,ConjResSusyno=temp[[1]];,
                  ConjResSusyno=temp[[2]];];
                 Return[temp[[1]]];,
                ConjResSusyno=temp[[1]]; 
                Return[temp[[2]]];
                ];,
            If[dynkin===None && Length[temp]> 2, 
                Message[SARAH::DimensionNotUnique,dim, group];,
                pos = Position[temp,dynkin];
                If[pos==={};
                  Message[SARAH::UnknownDynkin,dynkin];,
                  
                  ConjResSusyno=
                    Delete[Position[temp,temp[[pos[[1,1,4]]]]],pos[[1,1]]];
                  Return[temp[[pos[[1,1]]]]];
                  ];
                ];
            ];
          ];
      ];


GeneratInvariantMatrixSusyno[IndexTypesNonSUN_,partList_]:=
    Block[{resNonSUN,pos,tepm,i,j,dyn,ind},
      
      resNonSUN=1;
      For[i=1,i\[LessEqual]Length[IndexTypesNonSUN],
        pos = Position[Gauge,IndexTypesNonSUN[[i]]][[1,1]];
        temp={}; dyn={}; ind={};
        For[j=1,j\[LessEqual]Length[partList],
          pos2=Position[Fields,partList[[j]]][[1,1]];
          If[FieldDim[pos2,pos]=!=1,
            temp = Join[temp,{FieldDim[pos2,pos]}];
            dyn = Join[dyn,{DynkinLabels[Gauge[[pos,2]],Fields[[pos2,3]]]}];
            ind=Join[ind,{IndexTypesNonSUN[[i]] /. subGC[j]}];
            ];
          j++;];
        temp=DeleteCases[temp,1,5];
        resNonSUNtemp=RM[Gauge[[pos,2]],temp,dyn]@@ind;
        
        (*
          Switch[Length[partList],
              2,
              	If[partList[[1]]\[Equal]partList[[2]], 
                  	
                  resNonSUNtemp = 
                      1/Sqrt[2](resNonSUNtemp + (resNonSUNtemp /. 
                                RM[a__][b_,c_]\[Rule]RM[a][c,b]));
                  	];,
              3,
                    If[partList[[1]]===partList[[2]]===partList[[3]],
                  	
                  resNonSUNtemp = 
                      1/Sqrt[3](resNonSUNtemp + (resNonSUNtemp /.RM[a__][x1_,
                                    x2_,x3_]\[Rule]RM[a][x3,x2,
                                    x1])+(resNonSUNtemp /.RM[a__][x1_,x2_,
                                    x3_]\[Rule]RM[a][x2,x1,
                                    x3])+(resNonSUNtemp /.RM[a__][x1_,x2_,
                                    x3_]\[Rule]RM[a][x1,x3,x2]));,
                   Which[
                      partList[[1]]===partList[[2]], 
                      resNonSUNtemp = 
                          resNonSUNtemp(1-Delta[gen1,gen2])+ 
                            1/Sqrt[2] Delta[gen1,
                                gen2](resNonSUNtemp + (resNonSUNtemp /. 
                                      RM[a__][x1_,x2_,x3_]\[Rule]RM[a][x2,x1,
                                        x3]));,
                      partList[[1]]===partList[[3]], 
                      resNonSUNtemp = 
                          resNonSUNtemp(1-Delta[gen1,gen3])+ 
                            Delta[gen1,gen3] 1/
                                Sqrt[2](resNonSUNtemp + (resNonSUNtemp /. 
                                      RM[a__][x1_,x2_,x3_]\[Rule]RM[a][x3,x2,
                                        x1]));,
                      partList[[3]]===partList[[2]], 
                      resNonSUNtemp = 
                          resNonSUNtemp(1-Delta[gen2,gen3])+ 
                            Delta[gen2,gen3] 1/
                                Sqrt[2](resNonSUNtemp + (resNonSUNtemp /. 
                                      RM[a__][x1_,x2_,x3_]\[Rule]RM[a][x1,x3,
                                        x2]));
                      	];
                  ];
              ];
          *)
        
        SA`NeededInvariantsSusyno = 
          Join[SA`NeededInvariantsSusyno,{{Gauge[[pos,2]],temp,dyn,
                IndexTypesNonSUN[[i]]}}];
        resNonSUN = resNonSUN*resNonSUNtemp;
        i++];
      
      Return[resNonSUN];
      ];

NumberStates[x_,y_]:=
    NumberStates[x,y//. (a_[{b__}]\[Rule]a)]/;FreeQ[y,List]\[Equal]False;

GenerateSusyNoInvariants:=Block[{i,j,temp,pos},
      If[SusynoLoaded\[Equal]True,
          Print["Get information from Susyno"];
          
          SA`NeededInvariantsSusyno = 
            Intersection[SA`NeededInvariantsSusyno];
          SA`NeededGeneratorsSusyno = 
            Intersection[SA`NeededGeneratorsSusyno];
          SA`NonZeroEntries={};
          
          For[i=1,i\[LessEqual]Length[SA`NeededGeneratorsSusyno],
            entry = SA`NeededGeneratorsSusyno[[i]];
            temp = Normal/@RepMatrices[SusynoForm[entry[[1]]],entry[[3]]];
            
            ReleaseHold[
              Hold[SetDelayed[
                    TA[entry[[1]],entry[[2]],x_Integer,y_Integer,z_Integer],
                    TEMP[[x,y,z]]]]/.TEMP\[Rule]temp];
            
            pos=Take[
                Position[temp,_?((#=!=0)&&NumericQ[#]&),6,1][[1]],{1,3}];
            
            SA`NonZeroEntries = 
              Join[SA`NonZeroEntries,{{TA[entry[[1]],entry[[2]],_,_,_],
                    pos}}];
            i++;];
          
          
          For[i=1,i\[LessEqual]Length[SA`NeededInvariantsSusyno],
            entry=SA`NeededInvariantsSusyno[[i]];
            Switch[Length[entry[[2]]],
              2,
              	
              temp = Invariants[SusynoForm[entry[[1]]],entry[[3,1]],
                    entry[[3,2]]][[1]];
              	
              temp = Table[
                  Coefficient[temp,a[i1] b[i2]],{i1,1,entry[[2,1]]},{i2,1,
                    entry[[2,2]]}];
              	
              ReleaseHold[
                Hold[SetDelayed[
                      RM[entry[[1]],entry[[2]],entry[[3]]][x_Integer,
                        y_Integer],TEMP[[x,y]]]]/.TEMP\[Rule]temp];
              	
              pos=Take[
                  Position[temp,_?((#=!=0)&&NumericQ[#]&),6,1][[1]],{1,2}];
              	
              SA`NonZeroEntries = 
                Join[SA`NonZeroEntries,{{RM[entry[[1]],entry[[2]],entry[[3]]],
                      pos,entry[[4]]}}];,
              3,
              	
              temp = Invariants[SusynoForm[entry[[1]]],entry[[3,1]],
                    entry[[3,2]],entry[[3,3]]][[1]];
              	
              temp = Table[
                  Coefficient[temp,a[i1] b[i2] c[3]],{i1,1,entry[[2,1]]},{i2,
                    1,entry[[2,2]]},{i3,1,entry[[2,3]]}];
              	
              ReleaseHold[
                Hold[SetDelayed[
                      RM[entry[[1]],entry[[2]],entry[[3]]][x_Integer,
                        y_Integer,z_Integer],
                      TEMP[[x,y,z]]]]/.TEMP\[Rule]temp];
              	
              pos=Take[
                  Position[temp,_?((#=!=0)&&NumericQ[#]&),6,1][[1]],{1,3}];
              	
              SA`NonZeroEntries = 
                Join[
                  SA`NonZeroEntries,{{RM[entry[[1]],entry[[2]],entry[[3]]],
                      pos,entry[[4]]}}];
              ];
            i++;];
          
          For[i=1,i\[LessEqual]Length[Gauge],
            If[Head[Gauge[[i,2]]]=!=SU && Head[Gauge[[i,2]]]=!=U,
              For[j=1,j\[LessEqual]Length[Fields],
                  
                  temp = Invariants[SusynoForm[Gauge[[i,2]]],
                        DynkinLabels[Gauge[[i,2]],Fields[[j,3]]],
                        ConjDynkinLabels[Gauge[[i,2]],Fields[[j,3]]]][[1]];
                  
                  temp = Table[
                      Coefficient[temp,a[i1] b[i2]],{i1,1,entry[[2,1]]},{i2,1,
                        entry[[2,2]]}];
                  
                  ReleaseHold[
                    Hold[SetDelayed[
                          RM[Gauge[[i,2]],FieldDim[j,i],
                              DynkinLabels[Gauge[[i,2]],Fields[[j,3]]]][
                            x_Integer,y_Integer],
                          TEMP[[x,y]]]]/.TEMP\[Rule]temp];
                  
                  pos=Take[
                      Position[temp,_?((#=!=0)&&NumericQ[#]&),6,1][[1]],{1,
                        2}];
                  
                  SA`NonZeroEntries = 
                    Join[SA`NonZeroEntries,{{RM[Gauge[[i,2]],FieldDim[j,i],
                            DynkinLabels[Gauge[[i,2]],Fields[[j,3]]]],pos,
                          Gauge[[i,2]]}}];
                  j++;];
              ];
            i++;];
          ];
      ];



GenerateNoSUNsub[term_,length_]:=Block[{sub={},pos,i,fca},
      If[Head[term]===Times,
        temp=Select[List@@term,(Head[Head[#]]\[Equal]RM)&,5];,
        temp=Select[{term},(Head[Head[#]]\[Equal]RM)&,5];
        ];
      fac=1;
      For[i=1,i\[LessEqual]Length[temp],
        pos=Position[SA`NonZeroEntries,temp[[i,0]]][[1,1]];
        entry=Extract[SA`NonZeroEntries,pos];
        sub=
          Join[sub,
            Flatten[Table[(entry[[3]]/.subGC[j])\[Rule]entry[[2,j]],{j,1,
                  length}]]];
        fac=fac*(temp[[i]]/.sub) i++;];
      Return[{sub,fac}];];

