(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)


Options[CalcLoopCorrections]={ReadLists\[Rule]False, OnlyWith\[Rule]{}};

CalcLoopCorrections[Eigenstates_,opt___ ]:=
    CalcOneLoopCorrections[Eigenstates,
      ReadLists/.{opt}/.Options[CalcLoopCorrections],
      OnlyWith/.{opt}/.Options[CalcLoopCorrections]];

CalcOneLoopCorrections[Eigenstates_, ReadLists_,OnlyWith_]:=
    Block[{i,j,temp,entryParticles},
      If[VerticesForEigenstates=!=Eigenstates,
        MakeVertexList[Eigenstates,VerticesForLoops\[Rule]True];
        ];
      
      massless=Massless[Eigenstates];
      
      $sarahCurrentLoopDir=ToFileName[{$sarahCurrentOutputDir,"One-Loop"}];
      If[FileExistsQ[$sarahCurrentLoopDir]=!=True,
        CreateDirectory[$sarahCurrentLoopDir];
        ];
      
      Print["Generate interaction list"];
      MakeCouplingLists;
      
      Print["------------------------------------"];
      Print["Calculate Loop Corrections"];
      Print["------------------------------------"];
      
      CalculatedSelfEnergy={};
      GaugeMassES={};
      GaugeMassESorg={};
      listAddedMasses={};
      listNotMixedMasses={};
      VerticesGaugeMassES={};
      AddedVertex={};
      entryParticles = {};
      
      For[i=1,i\[LessEqual]Length[Particles[Current]],
        GaugeMassES=
          Join[GaugeMassES,{ToExpression[
                "U"<>ToString[
                    Particles[Current][[i,1]]  /. diracSubBack1 /. 
                      diracSubBack2]]}];
        GaugeMassESorg=
          Join[GaugeMassESorg,{Particles[Current][[i,1]]  /. diracSubBack1 /. 
                diracSubBack2}];
        
        If[
          FreeQ[MajoranaPart,
              Particles[Current][[i,1]]  /. diracSubBack1 /. 
                diracSubBack2]\[Equal]False,
          
          MajoranaPart = 
              Join[MajoranaPart,{ToExpression[
                    "U"<>ToString[
                        Particles[Current][[i,1]]  /. diracSubBack1 /. 
                          diracSubBack2]]}];
          ];
        
        If[FreeQ[realVar,Particles[Current][[i,1]]]\[Equal]False,
          
          realVar = 
              Join[realVar,{ToExpression[
                    "U"<>ToString[Particles[Current][[i,1]] ]]}];
          ];
        i++;];
      
      
      Print["     For Rotated Fields"];
      Print["------------------------------------"];
      OneLoopMassMatrices[Eigenstates];
      getUnmixedMasses[Eigenstates];
      
      Print[""];
      Print[""];
      Print["     For Tadpoles"];
      Print["------------------------------------"];
      OneLoopTadpoles[Eigenstates];
      
      Print[""];
      Print[""];
      Print["     For Gauge Eigenstates"];
      Print["------------------------------------"];
      OneLoopNotMixed[listNotMixedMasses, Eigenstates];
      OneLoopSelfEnergy[Eigenstates]=CalculatedSelfEnergy;
      
      SelfEnergy1LoopListtemp[Eigenstates]=
        Join[LoopCorrectionMassMatrices[Eigenstates],
          LoopCorrectionUnmixed[Eigenstates]];
      SelfEnergy1LoopSum[Eigenstates] = 
        Join[SelfEnergies1Loop[Eigenstates],SelfEnergyUnmixed[Eigenstates]];
      ParticlesSelfEnergy1LoopSum[Eigenstates]=entryParticles;
      Tadpoles1LoopSum[Eigenstates] = Tadpoles1Loop[Eigenstates];
      
      If[Head[DEFINITION[Eigenstates][VEVs]]===List,
        Tadpoles1LoopList[Eigenstates]={};
        For[i=1,i\[LessEqual]Length[LoopCorrectionTadpoles[Eigenstates]],
          
          Tadpoles1LoopList[Eigenstates]=
            Join[Tadpoles1LoopList[Eigenstates],{ 
                Delete[LoopCorrectionTadpoles[Eigenstates][[i]],2] /. 
                  gI2\[Rule]gI1}];
          i++];,
        Tadpoles1LoopList[Eigenstates]={};
        ];
      
      SelfEnergy1LoopList[Eigenstates]={};
      
      For[i=1,i\[LessEqual]Length[LoopCorrectionMassMatrices[Eigenstates]],
        calcPart=DEFINITION[Eigenstates][MatterSector][[i,2,1]];
        If[Length[calcPart]\[Equal]2,
          temp={calcPart[[1]] /. diracSubBack1  /. diracSubBack2};,
          temp={calcPart /. diracSubBack1  /. diracSubBack2};
          ];
        For[j=1,
          j\[LessEqual]Length[LoopCorrectionMassMatrices[Eigenstates][[i]]],
          If[LoopCorrectionMassMatrices[Eigenstates][[i,j,4]]===SSSS || 
              LoopCorrectionMassMatrices[Eigenstates][[i,j,4]]===SSVV || 
              LoopCorrectionMassMatrices[Eigenstates][[i,j,4]]===VVVV,
            
            temp = Join[
                  temp,{Delete[LoopCorrectionMassMatrices[Eigenstates][[i,j]],
                        2] /. gI2\[Rule]gI1}];,
            
            temp = Join[
                  temp,{ LoopCorrectionMassMatrices[Eigenstates][[i,j]]}];
            ];
          j++;];
        SelfEnergy1LoopList[Eigenstates] = 
          Join[SelfEnergy1LoopList[Eigenstates],{temp}];
        i++];
      
      
      For[i=1,i\[LessEqual]Length[LoopCorrectionUnmixed[Eigenstates]],
        calcPart=ListUnmixed[Eigenstates][[i,1]];
        temp={calcPart /. diracSubBack1  /. diracSubBack2};
        If[Length[LoopCorrectionUnmixed[Eigenstates][[i]]]>1,
          
          For[j=1,j\[LessEqual]Length[
                LoopCorrectionUnmixed[Eigenstates][[i]]],
            
            If[LoopCorrectionUnmixed[Eigenstates][[i,j,4]]===SSSS || 
                LoopCorrectionUnmixed[Eigenstates][[i,j,4]]===SSVV || 
                LoopCorrectionUnmixed[Eigenstates][[i,j,4]]===VVVV,
              
              temp = Join[
                    temp,{Delete[LoopCorrectionUnmixed[Eigenstates][[i,j]],
                          2] /. gI2\[Rule]gI1}];,
              temp = Join[temp,{LoopCorrectionUnmixed[Eigenstates][[i,j]]}];
              ];
            j++;];
          
          SelfEnergy1LoopList[Eigenstates] = 
            Join[SelfEnergy1LoopList[Eigenstates],{temp}];
          ];
        i++];
      
      If[OnlyWith=!={},
        Print["Removing light field contributions"];
        LoopCorrectionMassMatrices[Eigenstates] = 
          DeleteLightFieldContributions[
            LoopCorrectionMassMatrices[Eigenstates],OnlyWith,
            listAddedMasses];
        LoopCorrectionUnmixed[Eigenstates] = 
          DeleteLightFieldContributions[LoopCorrectionUnmixed[Eigenstates],
            OnlyWith,Transpose[ListUnmixed[Eigenstates]][[1]]];
        Tadpoles1Loop[Eigenstates] = 
          DeleteLightFieldContrubtions[Tadpoles1Loop[Eigenstates],OnlyWith,
            True];
        VerticesGaugeMassESsave = VerticesGaugeMassES;
        VerticesGaugeMassES = 
          DeleteLightFieldVertices[VerticesGaugeMassES, OnlyWith];
        ];
      
      Put[OneLoopSelfEnergy[Eigenstates],
        ToFileName[$sarahCurrentLoopDir,"SelfEnergy.m"]];
      Put[SelfEnergies1Loop[Eigenstates],
        ToFileName[$sarahCurrentLoopDir,"SelfEnergyRotatedFields.m"]];
      Put[SelfEnergyUnmixed[Eigenstates],
        ToFileName[$sarahCurrentLoopDir,"SelfEnergyUnrotatedFields.m"]];
      Put[Tadpoles1Loop[Eigenstates],
        ToFileName[$sarahCurrentLoopDir,"Tadpoles1Loop.m"]];
      Put[LoopCorrectionMassMatrices[Eigenstates],
        ToFileName[$sarahCurrentLoopDir,"SelfEnergyRotatedFields-list.m"]];
      Put[LoopCorrectionUnmixed[Eigenstates],
        ToFileName[$sarahCurrentLoopDir,"SelfEnergyUnrotatedFields-list.m"]];
      Put[LoopCorrectionTadpoles[Eigenstates],
        ToFileName[$sarahCurrentLoopDir,"Tadpoles1Loop-list.m"]];
      Put[ListUnmixed[Eigenstates],
        ToFileName[$sarahCurrentLoopDir,"UnrotatedParticles.m"]];
      Put[VerticesGaugeMassES,
        ToFileName[$sarahCurrentLoopDir,"NewVertices.m"]]; 
      
      
      CalculatedLoopCorrections=Eigenstates;
      
      ];

 OneLoopNotMixed[particles_, Eigenstates_]:=Block[{i,j},
      
      CorrectionList = Table[0,{Length[particles]}];
      OneLoopProp = Table[0,{Length[particles]}];
      For[i=1,i\[LessEqual]Length[particles],
        If[FreeQ[massless,particles[[i,1]]]\[Equal]True,
          particle=particles[[i,1]] /. diracSubBack1 /. diracSubBack2;
          Print["    Calculate One Loop Self Energy of ",particle];
          Switch[getType[particle],
              S,
            temp=Join[ThreeParticleVertex2[particle],
                  FourParticleVertex2[particle]];,
              V,
            temp=Join[ThreeParticleVertex2[particle],
                  FourParticleVertex2[particle]];,
              F,temp=ThreeParticleVertex2[particle];
            ];
          
          If[getGen[particle]>1,
            
            CorrectionList[[i]]=
              temp /.{particle[{gO1,a___}]\[Rule] 
                    ToExpression["U"<>ToString[particle]][{gO1,a}],
                  particle[{gO2,a___}]\[Rule] 
                    ToExpression["U"<>ToString[particle]][{gO2,a}]};
            
            LoopCorrection=0;
            For[j=1,j\[LessEqual]Length[temp],
               
              VerticesGaugeMassES = 
                Join[VerticesGaugeMassES,{{AddUnrotatedVertex[{temp[[j,4]],
                          AntiField[particle],temp[[j,1]],temp[[j,2]]},None],
                      temp[[j,4]]}}];
              
              LoopCorrection += 
                AddLoop2[particle,temp[[j]]] /. {Mass[conj[x_]]\[Rule]Mass[x],
                    Mass[bar[x_]]\[Rule]Mass[x],
                    Mass2[conj[x_]]\[Rule]Mass2[x],
                    Mass2[bar[x_]]\[Rule]Mass2[x]};
              j++;];,
            
            LoopCorrection=0;
            CorrectionList[[i]]=temp ;
            For[j=1,j\[LessEqual]Length[temp],
              
              If[FreeQ[AddedVertex,
                  temp[[j,3]]  //.\[InvisibleSpace]{x_[{a__}][b_]\[Rule]x,
                        x_[{a__}]\[Rule]x}/. Cp \[Rule]C],
                 
                VerticesGaugeMassES = 
                  Join[VerticesGaugeMassES,{{AddVertex[{temp[[j,4]],
                            AntiField[particle],temp[[j,1]],temp[[j,2]]}],
                        temp[[j,4]]}}]; 
                
                AddedVertex=
                  Join[AddedVertex,{temp[[j,
                              3]]  //.\[InvisibleSpace]{x_[{a__}][b_]\[Rule]x,
                            x_[{a__}]\[Rule]x}/. Cp \[Rule]C}];
                ];
              
              LoopCorrection += 
                AddLoop2[particle,temp[[j]]]/. {Mass[conj[x_]]\[Rule]Mass[x],
                    Mass[bar[x_]]\[Rule]Mass[x],
                    Mass2[conj[x_]]\[Rule]Mass2[x],
                    Mass2[bar[x_]]\[Rule]Mass2[x]};
              j++;];
            
            
            ];
          OneLoopProp[[i]]=LoopCorrection;
          
          CalculatedSelfEnergy= 
            Join[CalculatedSelfEnergy,{{particle,LoopCorrection}}];,
          OneLoopProp[[i]]=0;
          ];
        entryParticles=Join[entryParticles,{particle}];
        
        
        i++;];
      
      LoopCorrectionUnmixed[Eigenstates]=CorrectionList;
      SelfEnergyUnmixed[Eigenstates]=OneLoopProp;
      
      ];


OneLoopMassMatrices[Eigenstates_]:=Block[{i,j,i1,i2,i3,i4,temp},
       
      basis =DEFINITION[Eigenstates][MatterSector];
      
      If[Head[basis]=!=List,basis={};];
      
      CorrectedMassMatrices=Table[0,{Length[basis]}];
      CorrectionList=Table[0,{Length[basis]}];
      
      
      
       For[i=1,i\[LessEqual]Length[basis], 
        If[Length[basis[[i,2,1]]]\[Equal]0,
          
          Print["    Calculate One Loop Self Energy of ",basis[[i,2,1]] /. 
                  diracSubBack1 /. diracSubBack2];,
          
          Print["    Calculate One Loop Self Energy of ",basis[[i,2,1,1]] /. 
                  diracSubBack1 /. diracSubBack2];
          ];
        
        If[Length[Dimensions[basis[[i,2]]]]\[Equal]1,
          
          OneLoopMassMatrix=
            Table[0,{Length[basis[[i,1]]]},{Length[basis[[i,1]]]}];
          particle=basis[[i,2,1]] /. diracSubBack1 /. diracSubBack2;
          unrotateMatrix=basis[[i,2,2]];,
          
          OneLoopMassMatrix=
            Table[0,{Length[basis[[i,1,1]]]},{Length[basis[[i,1,1]]]}];
          particle=basis[[i,2,1,1]] /. diracSubBack1 /. diracSubBack2;
          unrotateMatrix={basis[[i,2,1,2]],basis[[i,2,2,2]]};
          ];
        
        listAddedMasses=Join[listAddedMasses,{particle}];
        
        Switch[getType[particle],
          S,
          temp=Join[ThreeParticleVertex2[particle],
                FourParticleVertex2[particle]];,
            V,
          temp=Join[ThreeParticleVertex2[particle],
                FourParticleVertex2[particle]];,
            F,temp=ThreeParticleVertex2[particle];
          ];
        
        
        If[getGen[particle]>1,
          
          CorrectionList[[i]]=
              temp /.{particle[{gO1,a___}]\[Rule] 
                    ToExpression["U"<>ToString[particle]][{gO1,a}],
                  particle[{gO2,a___}]\[Rule] 
                    ToExpression["U"<>ToString[particle]][{gO2,a}]};,
          CorrectionList[[i]]=temp;
          ];
        
        LoopCorrection=0;
        For[j=1,j\[LessEqual]Length[temp],
          If[getGen[particle]>1,
            
            LoopCorrection += 
                AddLoop2[basis[[i,2,1]],
                    temp[[j]] /.{particle[{gO1,a___}]\[Rule] 
                          ToExpression["U"<>ToString[particle]][{gO1,a}],
                        particle[{gO2,a___}]\[Rule] 
                          ToExpression["U"<>ToString[particle]][{gO2,
                              a}]}] /. {Mass[conj[x_]]\[Rule]Mass[x],
                    Mass[bar[x_]]\[Rule]Mass[x],
                    Mass2[conj[x_]]\[Rule]Mass2[x],
                    Mass2[bar[x_]]\[Rule]Mass2[x]};,
            
            LoopCorrection += 
                AddLoop2[basis[[i,2,1]],
                    temp[[j]]] /. {Mass[conj[x_]]\[Rule]Mass[x],
                    Mass[bar[x_]]\[Rule]Mass[x],
                    Mass2[conj[x_]]\[Rule]Mass2[x],
                    Mass2[bar[x_]]\[Rule]Mass2[x]};
            ];
          
          
          If[FreeQ[
              AddedVertex,(CorrectionList[[i,j,3]]  /. A_[{a___}]\[Rule]a)/. 
                Cp \[Rule]C],
            
            VerticesGaugeMassES = 
              Join[VerticesGaugeMassES,{{AddUnrotatedVertex[{temp[[j,4]],
                        AntiField[particle],temp[[j,1]],temp[[j,2]]},
                      unrotateMatrix],temp[[j,4]]}}];
            
            AddedVertex=
              Join[AddedVertex,{(CorrectionList[[i,j,3]]  /. 
                        A_[{a___}]\[Rule]A)/. Cp \[Rule]C}];
            ];
          
            
          
          j++;];
        
        CorrectedMassMatrices[[i]]=LoopCorrection;
        
        If[Length[basis[[i,2,1]]]\[Equal]2,
          
          CalculatedSelfEnergy= 
              Join[CalculatedSelfEnergy,{{basis[[i,2,1]][[1]] /. 
                        diracSubBack1 /. diracSubBack2,LoopCorrection}}];,
          
          CalculatedSelfEnergy= 
              Join[CalculatedSelfEnergy,{{basis[[i,2,1]],LoopCorrection}}];
          ];
        
        entryParticles=Join[entryParticles,{particle}];
        i++;];
      
      
      SelfEnergies1Loop[Eigenstates]=CorrectedMassMatrices;
      LoopCorrectionMassMatrices[Eigenstates]=CorrectionList;
      
      ];


OneLoopTadpoles[Eigenstates_]:=
    Block[{i,vevs,scalars,temp,vevNr,i1,i2, res,par1,basis,particlelist,temp3,
        pos},
      TEqu=TadpoleEquations[Eigenstates];
      basis=DEFINITION[Eigenstates][MatterSector];
      vevs=DEFINITION[Eigenstates][VEVs];
      neededVerticesForTadpoles={};
      CorrectionListTadpoles={};
      
      If[Head[vevs]===List,
        scalars=Transpose[Transpose[vevs][[4]]][[1]];
        vevNames=Transpose[Transpose[vevs][[2]]][[1]];
        TadpolesLoop ={};
        ScalarsForTadpoles={};
        listVEVseparated={};
        For[i=1,i\[LessEqual]Length[vevNames],
          particle = scalars[[i]];
          
          If[FreeQ[basis,particle]\[Equal]False,
            pos = Position[basis,particle][[1,1]];
            particle = basis[[pos,2,1]];
            ];
          
          
          If[FreeQ[ScalarsForTadpoles,particle] && 
              FreeQ[listVEVseparated,vevNames[[i]]],
            ScalarsForTadpoles=Join[ScalarsForTadpoles,{particle}];
            
            
            temp=ThreeParticleVertex2[particle];
            temp2={};
            
            
            For[i1=1,i1\[LessEqual]Length[temp],
              
              If[AntiField[temp[[i1,1]]]===temp[[i1,2]] && 
                  FreeQ[MasslessBosons,temp[[i1,1]]]\[Equal]True,
                temp2=Join[temp2,{temp[[i1]]}];
                ];
              i1++;];
            
            If[getGen[particle]>1,
              
              CorrectionListTadpoles=
                Join[CorrectionListTadpoles,{temp2 /.{particle[{gO1,
                              a___}]\[Rule] 
                          ToExpression["U"<>ToString[particle]][{gO1,a}]}}];
              
              neededVerticesForTadpoles = 
                Join[neededVerticesForTadpoles,{ 
                    ToExpression["U"<>ToString[particle]]}];,
              CorrectionListTadpoles=Join[CorrectionListTadpoles,{temp2}];
              
              neededVerticesForTadpoles = 
                Join[neededVerticesForTadpoles,{particle}];
              ];
            
            
            LoopCorrection=0;
            For[j=1,j\[LessEqual]Length[temp2],
              If[temp2[[j,1]]===AntiField[temp2[[j,2]]],
                
                LoopCorrection  +=
                    AddLoop1[particle,
                        temp2[[j]]] /. {Mass[conj[x_]]\[Rule]Mass[x],
                        Mass[bar[x_]]\[Rule]Mass[x],
                        Mass2[conj[x_]]\[Rule]Mass2[x],
                        Mass2[bar[x_]]\[Rule]Mass2[x]};
                ];
              j++;];
            
            temp={};
             For[i1=1,i1\[LessEqual]Length[vevNames],
              If[ScalarToVEV[vevNames[[i1]],Eigenstates]===particle,
                temp=Join[temp,{vevNames[[i1]]}];
                ];
              i1++;];
            listVEVseparated = Join[listVEVseparated,{temp}];
            
            If[getGen[particle]>1,
              
              TadpolesLoop = 
                  Join[TadpolesLoop,{{particle, 
                        LoopCorrection /.{particle[{gO1,a___}]\[Rule] 
                              ToExpression["U"<>ToString[particle]][{gO1,
                                  a}]}}}];,
              TadpolesLoop =Join[TadpolesLoop,{{particle, LoopCorrection }}];
              ];
            
            ];
          i++;];
        
        Tadpoles1Loop[Eigenstates]=TadpolesLoop;
        LoopCorrectionTadpoles[Eigenstates]=CorrectionListTadpoles;,
        
        Tadpoles1Loop[Eigenstates]={{}};
        LoopCorrectionTadpoles[Eigenstates]={{}};
        ];
      
      ];


ScalarToVEV[x_, Eigenstates_]:=Block[{pos,i,s,basis},
      pos=
        Position[
            Transpose[Transpose[DEFINITION[Eigenstates][VEVs]][[2]]][[1]],
            x][[1,1]];
      s=Transpose[Transpose[DEFINITION[Eigenstates][VEVs]][[4]]][[1]][[pos]];
      If[FreeQ[DEFINITION[Eigenstates][MatterSector],s],
        Return[s];,
        
        pos = Position[DEFINITION[Eigenstates][MatterSector],s][[1,1]];
        Return[DEFINITION[Eigenstates][MatterSector][[pos,2,1]]];
        ];
      ];


AddLoop1[particle_,corrections_]:=Block[{temp,m1,m2,m0,i,vCur},
      If[getGen[corrections[[1]]]>1,
        m1=Mass[corrections[[1]][{gI1}]]/. Mass\[Rule]Mass2;,
        m1=Mass[corrections[[1]]]/. Mass\[Rule]Mass2;
        ];
      If[m1=!=0,
        vCur = corrections[[3]] /. {gI2 \[Rule]gI1}; 
        Switch[getType[corrections[[1]]],
          S,amp = -A0[m1] vCur;,
          V,amp = 3 A0[m1] vCur;,
          F,amp = 4 A0[m1] m1 vCur;
          ];
        fac =2* corrections[[5]]*corrections[[6]];
        Return[fac*sum[gI1,1,getGen[corrections[[1]]],amp]];,
        Return[0];
        ];
      ];


OrderMasses[p1_,p2_,type_]:=Block[{m1,m2},
      If[getType[p1]===type,
        If[getGenOne[p1]>1,m1 =Mass[p1[{gI1}]];,m1=Mass[p1];];
        If[getGenOne[p2]>1,m2 = Mass[p2[{gI2}]];,m2=Mass[p2];];,
        If[getGenOne[p2]>1,m1 =Mass[p2[{gI1}]];,m1=Mass[p2];];
        If[getGenOne[p1]>1,m2 = Mass[p1[{gI2}]];,m2=Mass[p1];];
        ];
      Return[{m1,m2}];
      ];

AddLoop2[particle_,correction_]:=Block[{part},
      If[Length[particle]\[Equal]2,part=particle[[1]];,part=particle];
      Switch[getTypeOld[part],
        S, Return[AddLoopScalar[part,correction]];,
        F, Return[AddLoopFermion[part,correction]];,
        V, Return[AddLoopVector[part,correction]];
        ];
      ];

AddLoopScalar[particle_,corrections_]:=
    Block[{temp,m1,m2,m0,mS,mV,v,fac,m12,m22},
      If[corrections[[4]]===FFS,
          temp=OrderMasses[corrections[[1]],corrections[[2]],F];
          m12=temp[[1]]/. Mass\[Rule]Mass2;
          m22=temp[[2]]/. Mass\[Rule]Mass2;
          m1 = temp[[1]];
          m2 = temp[[2]];
          
          If[FreeQ[m1,corrections[[1]]] && FreeQ[m2,corrections[[2]]],
            m1 = m1 /. gI1\[Rule]gI2;
            m12 = m12 /. gI1\[Rule]gI2;
            m22 = m22 /. gI2\[Rule]gI1;
            m2 = m2 /. gI2\[Rule]gI1;
            ];
          
          coupL1=corrections[[3]][PL];
          coupR1=corrections[[3]][PR];
          coupL2= conj[corrections[[3]][PL]]/. {gO1 \[Rule]gO2};
          coupR2= conj[corrections[[3]][PR]]/. {gO1 \[Rule]gO2};
          pi1LoopA=-2 m1 m2 (coupL1*coupR2+coupR1*coupL2)*B0[p^2,m12,m22] ;
          pi1LoopB=(coupL1*coupL2+coupR1*coupR2)*G0[p^2,m12,m22] ;
          pi1LoopA =pi1LoopA* corrections[[6]]*corrections[[5]];
          pi1LoopB =pi1LoopB* corrections[[6]]*corrections[[5]];
          If[AntiField[particle]===particle,
            
            Return[sum[gI1,1,getGenOne[corrections[[1]]],
                    sum[gI2,1,getGenOne[corrections[[2]]],2 pi1LoopA]]+
                  sum[gI1,1,getGenOne[corrections[[1]]],
                    sum[gI2,1,getGenOne[corrections[[2]]], 2 pi1LoopB]]];,
            
            Return[sum[gI1,1,getGenOne[corrections[[1]]],
                    sum[gI2,1,getGenOne[corrections[[2]]],pi1LoopA]]+
                  sum[gI1,1,getGenOne[corrections[[1]]],
                    sum[gI2,1,getGenOne[corrections[[2]]],pi1LoopB]]];
            ];,
          
          
          temp=OrderMasses[corrections[[1]],corrections[[2]],S];
          m11=temp[[1]]; m12=temp[[1]]/. Mass\[Rule]Mass2; m21=temp[[2]]; 
          m22=temp[[2]]/. Mass\[Rule]Mass2;
          
          If[FreeQ[m11,corrections[[1]]] && FreeQ[m21,corrections[[2]]] ,
            m11 = m11 /. gI1\[Rule]gI2;
            m12 = m12 /. gI1\[Rule]gI2;
            m22 = m22 /. gI2\[Rule]gI1;
            m21 = m21 /. gI2\[Rule]gI1;
            ];
          coup1=corrections[[3]]; 
          coup2=conj[corrections[[3]]]/. {gO1 \[Rule]gO2};
          
          Switch[corrections[[4]],
            	SSS,
            		
            		pi1Loop = coup1*coup2*B0[p^2,m12,m22];
            		If[conj[particle]===particle,
              		pi1Loop =2 pi1Loop* corrections[[6]]*corrections[[5]];,
              		pi1Loop =pi1Loop* corrections[[6]]*corrections[[5]];
              		];
            		
            Return[sum[gI1,1,getGenOne[corrections[[1]]],
                sum[gI2,1,getGenOne[corrections[[2]]],pi1Loop]]];,
            
            	SSV,
            		pi1Loop = coup1*coup2*F0[p^2,m12,m22];
            		If[conj[particle]===particle,
              		pi1Loop =2 pi1Loop* corrections[[6]]*corrections[[5]];,
              		pi1Loop =pi1Loop* corrections[[6]]*corrections[[5]];
              		];
            		
            Return[sum[gI1,1,getGenOne[corrections[[1]]],
                sum[gI2,1,getGenOne[corrections[[2]]],pi1Loop]]];,
            	SVV,
            		pi1Loop = 7/2 coup1*coup2*B0[p^2,m12,m22];
            		If[conj[particle]===particle,
              		pi1Loop =2 pi1Loop* corrections[[6]]*corrections[[5]];,
              		pi1Loop =pi1Loop* corrections[[6]]*corrections[[5]];
              		];
            		
            Return[sum[gI1,1,getGenOne[corrections[[1]]],
                sum[gI2,1,getGenOne[corrections[[2]]],pi1Loop]]];,
            
            	SSVV,
            	If[m12=!=0,
                		pi1Loop  = coup1*A0[m12];
                		
                pi1Loop =
                  4 pi1Loop* corrections[[6]]*
                      corrections[[5]]  /. {gI2 \[Rule]gI1};
                		Return[sum[gI1,1,getGenOne[corrections[[1]]],pi1Loop]];,
                		Return[0];
                	];,
            
            	SSSS,
            	If[m12=!=0,
                		pi1Loop  = -coup1*A0[m12];
                		pi1Loop =pi1Loop* corrections[[6]]  /. {gI2 \[Rule]gI1};
                		If[corrections[[5]]<500, 
                  		
                  Return[corrections[[5]]  sum[gI1,1,
                          getGenOne[corrections[[1]]],pi1Loop]];,
                  		
                  Return[C  sum[gI1,1,getGenOne[corrections[[1]]],pi1Loop]];
                  		];,
                		Return[0];
                	];
            	];
          ]; 
      ];

AddLoopFermion[particle_,corrections_]:=
    Block[{temp,m1,m2,m0,mS,mV,v,fac,m11,m12,m21,m22},
      temp=OrderMasses[corrections[[1]], corrections[[2]], F];
      m11=temp[[1]]; m12=temp[[1]]/. Mass\[Rule]Mass2; m21=temp[[2]]; 
      m22=temp[[2]]/. Mass\[Rule]Mass2;
      coupL1= corrections[[3]][PL];
      coupR1= corrections[[3]][PR];
      coupL2= conj[corrections[[3]][PL]]/. {gO1 \[Rule]gO2};
      coupR2= conj[corrections[[3]][PR]]/. {gO1 \[Rule]gO2};	
      
      If[FreeQ[m11,corrections[[1]]] && FreeQ[m21,corrections[[2]]],
        m11 = m11/. gI1\[Rule]gI2;
        m12 = m12 /. gI1\[Rule]gI2;
        m22 = m22 /. gI2\[Rule]gI1;
        m21 = m21 /. gI2\[Rule]gI1;
        ];
      
      
      Switch[corrections[[4]],
        	FFS,
        		
        Sigma1LoopS= 
          sum[gI1,1,getGenOne[corrections[[1]]],
            sum[gI2,1,getGenOne[corrections[[2]]],
              m11 coupR1*coupL2*B0[p^2,m12,m22] corrections[[6]]*
                corrections[[5]]]];
        		
        Sigma1LoopR =
          sum[gI1,1,getGenOne[corrections[[1]]],
            sum[gI2,1,
              getGenOne[corrections[[2]]], -1/2coupR1*coupR2*
                B1[p^2,m12,m22] corrections[[6]]*corrections[[5]]]];
        		
        Sigma1LoopL=
          sum[gI1,1,getGenOne[corrections[[1]]],
            sum[gI2,1,
              getGenOne[corrections[[2]]],-1/2coupL1*coupL2*
                B1[p^2,m12,m22] corrections[[6]]*corrections[[5]]]];,
        
        	FFV,
        		
        Sigma1LoopS= 
          sum[gI1,1,getGenOne[corrections[[1]]],
            sum[gI2,1,
              getGenOne[corrections[[2]]],-4 m11 coupL1*coupR2*
                B0[p^2,m12,m22] corrections[[6]]*corrections[[5]]]];
        		
        Sigma1LoopR = 
          sum[gI1,1,getGenOne[corrections[[1]]],
            sum[gI2,1,
              getGenOne[corrections[[2]]],- coupL1*coupL2*
                B1[p^2,m12,m22]corrections[[6]]*corrections[[5]]]];
        		
        Sigma1LoopL=
          sum[gI1,1,getGenOne[corrections[[1]]],
            sum[gI2,1,
              getGenOne[corrections[[2]]], -coupR1*coupR2*
                B1[p^2,m12,m22] corrections[[6]]*corrections[[5]]]];
        	];
      
      If[FreeQ[MajoranaPart,particle]===False,
        	Return[{2 Sigma1LoopS,2 Sigma1LoopR,2 Sigma1LoopL}];,
        	Return[{Sigma1LoopS,Sigma1LoopR,Sigma1LoopL}];
        	];
      ];



AddLoopVector[particle_,corrections_]:=
    Block[{temp,m1,m2,m0,mS,mV,v,fac,m11,m12,m21,m22},
      If[corrections[[4]]===VVVV || corrections[[4]]===SSVV,Return[0];];
      
      If[getType[corrections[[1]]]===F,
        temp=OrderMasses[corrections[[1]], corrections[[2]], F];
        
        If[FreeQ[m11,corrections[[1]]] && FreeQ[m21,corrections[[2]]],
          m11 = m11/. gI1\[Rule]gI2;
          m12 = m12 /. gI1\[Rule]gI2;
          m22 = m22 /. gI2\[Rule]gI1;
          m21 = m21 /. gI2\[Rule]gI1;
          ];
        
        m11=temp[[1]]; m12=temp[[1]]/. Mass\[Rule]Mass2; m21=temp[[2]]; 
        m22=temp[[2]]/. Mass\[Rule]Mass2;	
        coupL1= corrections[[3]][PL];
        coupR1= corrections[[3]][PR];
        pi1Loop  =  (coupL1 conj[coupL1]+coupR1 conj[coupR1])*
              H0[p^2,m12,m22]+4  Re[conj[coupL1] coupR1]*
              B0[p^2,m12,m22] m11 m21;
        pi1Loop =pi1Loop* corrections[[6]]*corrections[[5]];
        Return[
          sum[gI1,1,getGenOne[corrections[[1]]],
            sum[gI2,1,getGenOne[corrections[[2]]],pi1Loop]]];,
        
        temp=OrderMasses[corrections[[1]], corrections[[2]], V];
        
        If[FreeQ[m11,corrections[[1]]] && FreeQ[m21,corrections[[2]]],
          m11 = m11/. gI1\[Rule]gI2;
          m12 = m12 /. gI1\[Rule]gI2;
          m22 = m22 /. gI2\[Rule]gI1;
          m21 = m21 /. gI2\[Rule]gI1;
          ];
        
        m11=temp[[1]]; m12=temp[[1]]/. Mass\[Rule]Mass2; m21=temp[[2]]; 
        m22=temp[[2]]/. Mass\[Rule]Mass2;	
        coup= corrections[[3]];
        Switch[corrections[[4]],
          	SSV, 
          			pi1Loop  =  -4 coup conj[coup]B22[p^2,m12,m22];	
          			pi1Loop =pi1Loop* corrections[[6]]*corrections[[5]];
          			If[conj[particle]===particle,
            			
            Return[sum[gI1,1,getGenOne[corrections[[1]]],
                  sum[gI2,1,getGenOne[corrections[[2]]],2 pi1Loop]]];,
            			
            Return[sum[gI1,1,getGenOne[corrections[[1]]],
                  sum[gI2,1,getGenOne[corrections[[2]]],pi1Loop]]];
            			];,
          	SVV,
          			pi1Loop  =coup conj[coup]B0[p^2,m12,m22];	
          			pi1Loop =pi1Loop* corrections[[6]]*corrections[[5]];
          			
          Return[sum[gI1,1,getGenOne[corrections[[1]]],
              sum[gI2,1,getGenOne[corrections[[2]]],pi1Loop]]];,
          	VVV,
          			
          If[FreeQ[massless,corrections[[1]]]\[Equal]True && 
                FreeQ[massless,corrections[[2]]]\[Equal]True,
              			
              pi1Loop  =
                coup conj[
                    coup](- (4 p^2+m12 +m22 )*B0[p^2,m12,m22] - 
                      8 B22[p^2,m12,m22]);
              			pi1Loop =pi1Loop* corrections[[6]]*corrections[[5]];
              			
              Return[sum[gI1,1,getGenOne[corrections[[1]]],
                  sum[gI2,1,getGenOne[corrections[[2]]],pi1Loop]]];,
              			
              pi1Loop  =
                coup conj[
                    coup](- (4 p^2 )*B0[p^2,m12,m22] - 8 B22[p^2,m12,m22]);
              			pi1Loop =pi1Loop* corrections[[6]]*corrections[[5]];
              			
              Return[sum[gI1,1,getGenOne[corrections[[1]]],
                  sum[gI2,1,getGenOne[corrections[[2]]],pi1Loop]]];
              			];
          	];
        	];
      ];

getUnmixedMasses[Eigenstates_]:=Block[{i,j,neededP,treeMass,massMatrixTemp},
      partListFSV=Join[PART[F],Join[PART[S],PART[V]]];
      For[i=1,i\[LessEqual]Length[partListFSV],
        If[FreeQ[listAddedMasses,partListFSV[[i,1]]]\[Equal]True,
          Switch[getType[partListFSV[[i,1]]],
            S,type=ScalarMass;,
            F,
            If[MemberQ[MajoranaPart,partListFSV[[i,1]]]\[Equal]True,
                type=FermionMassSymm;,type=FermionMassNonSymm;];,
            V,type=VectorMass;
            ];
          
          treeMass=TreeMass[partListFSV[[i,1]],Eigenstates, False];
          neededP={};
          
          For[j=1,j\[LessEqual]Length[parameters],
            If[FreeQ[treeMass,parameters[[j,1]]]\[Equal]False,
              neededP=Join[neededP,{parameters[[j,1]]}];
              ];
            j++;];
          
          
          
          If[FreeQ[treeMass,gt1]\[Equal]False && 
              FreeQ[treeMass,gt2]\[Equal]False,
            
            massMatrixTemp= 
                Table[treeMass,{gt1,1,getGen[partListFSV[[i,1]]]},{gt2,1,
                    getGen[partListFSV[[i,1]]]}];,
            massMatrixTemp=treeMass;
            ];
          
          
          If[Simplify[treeMass /. subDependences] ===0 || 
              FreeQ[massless,partListFSV[[i,1]]]\[Equal]False,
            
            If[getType[partListFSV[[i,1]]]===V,
              MasslessBosons=Join[MasslessBosons, {partListFSV[[i,1]]}];];
            CurrentMass=0;
            treeMass=0;
            massMatrixTemp=0;,
            CurrentMass="M"<>ToString[partListFSV[[i,1]]];
            ];
          
          
          listNotMixedMasses= 
            Join[listNotMixedMasses,{{partListFSV[[i,1]],CurrentMass,neededP,
                  treeMass,massMatrixTemp,type}}];
          
          ];
        i++;];
      
      ListUnmixed[Eigenstates]=listNotMixedMasses;
      
      ];

DeleteLightFieldContributions[list_,heavyfields_,listFields_]:=
    Block[{i,j,k,temp, heavyInv},
      temp=Table[{},{Length[list]}];
      For[i=1,i\[LessEqual]Length[list],
        checkentry=False;
        If[listFields===True,
          checkentry=True;,
          If[getType[listFields[[i]]]===S,
              checkentry=True;
              ];
          ];
        If[checkentry\[Equal]True,
          For[k=1,k\[LessEqual]Length[list[[i]]],
              heavyInv=False;
              For[j=1,j\[LessEqual]Length[heavyfields],
                If[FreeQ[list[[i,k]],heavyfields[[j]]]\[Equal]False,
                  heavyInv=True;
                  ];
                j++;];
              If[heavyInv\[Equal]True,
                temp[[i]] = Join[temp[[i]],{list[[i,k]]}];
                ];
              k++;];,
          temp[[i]] = {};
          ];
        i++;];
      
      Return[temp];
      
      ];

DeleteLightFieldVertices[list_, heavyfields_]:=Block[{i,temp, heavyInv}, 
      temp = {};
      For[i=1,i\[LessEqual]Length[list],
        heavyInv=False;
        For[j=1,j\[LessEqual]Length[heavyfields],
          If[FreeQ[list[[i,1,1]],heavyfields[[j]]]\[Equal]False,
            heavyInv=True;
            ];
          j++;];
        For[j=1,j\[LessEqual]Length[neededVerticesForTadpoles],
          
          If[FreeQ[list[[i,1,1]],
                neededVerticesForTadpoles[[j]]]\[Equal]False,
            heavyInv=True;
            ];
          j++;];
        If[heavyInv\[Equal]True,
          temp = Join[temp,{list[[i]]}];
          ];
        i++;];
      Return[temp];
      ];