(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)

GenerateLesHouchesFile := Block[{i,i1, i2,k,listIn},
      
      Print["Writing LesHouches Input File"];
      
      sphenoLH=
        OpenWrite[
          ToFileName[$sarahCurrentSPhenoDir,"LesHouches.in."<>NameForModel]];
      WriteString[sphenoLH,"Block MODSEL \t #  \n"];
      WriteString[sphenoLH,"1 1 \t #  \n"];
      WriteString[sphenoLH,"6 1 \t # Generation Mixing \n"];
      WriteString[sphenoLH,"Block SMINPUTS \t # Standard Model inputs \n"];
      WriteString[sphenoLH,"2 1.166390E-05 \t # G_F,Fermi constant \n"];
      WriteString[sphenoLH,"3 1.190000E-01 \t # alpha_s(MZ) SM MSbar \n"];
      WriteString[sphenoLH,"4 9.118760E+01 \t # Z-boson pole mass \n"];
      WriteString[sphenoLH,"5 4.200000E+00 \t # m_b(mb) SM MSbar \n"];
      WriteString[sphenoLH,"6 1.729000E+02 \t # m_top(pole) \n"];
      WriteString[sphenoLH,"7 1.777000E+00 \t # m_tau(pole) \n"];
      WriteString[sphenoLH,"Block MINPAR \t # Input parameters \n"];
      
      For[i=1,i\[LessEqual]Length[MINPAR],
        WriteString[sphenoLH,
          ToString[i]<>" 0.000000E+00 \t  # "<>ToString[MINPAR[[i]]] <>"\n"];
        i++;];
      
      WriteString[sphenoLH,"Block EXTPAR \t # Input parameters \n"];
      For[i=1,i\[LessEqual]Length[EXTPAR],
        WriteString[sphenoLH,
          ToString[EXTPAR[[i,1]]]<>" 0.000000E+00 \t  # "<>
            ToString[EXTPAR[[i,2]]] <>"\n"];
        i++;];
      
      
      WriteString[sphenoLH,
        "Block SPhenoInput \t  # SPheno specific input \n"];
      WriteString[sphenoLH,"1 -1 \t  # error level \n"];
      WriteString[sphenoLH,"2  1 \t  # SPA conventions \n"];
      WriteString[sphenoLH,"11 1 \t  # calculate branching ratios \n"];
      WriteString[sphenoLH,
        "12 1.00000000E-04 \t  # write only branching ratios larger than this value \n"]\
;
      WriteString[sphenoLH,"21 0 \t  # calculate cross section \n"];
      
      
      listIn = 
        Intersection[
          Select[Flatten[{BoundaryHighScale,BoundarySUSYScale,
                  BoundaryEWSBScale,BoundaryConditionsUp,
                  BoundaryConditionsDown}],(Head[#]\[Equal]LHInput)&,99] /. 
            LHInput[x_]\[Rule]x];
      
      For[i=1,i\[LessEqual]Length[listIn],
        WriteString[sphenoLH,
          "Block "<>ToUpperCase[LHBlockName[listIn[[i]]]] <>"IN \t  #  \n"];
        Switch[Length[getDimSPheno[listIn[[i]]]],
          0, 
          WriteString[sphenoLH,
              ToString[LHPos[listIn[[i]]]]<>"\t 0.000000E+00 \t  # "<>
                SPhenoForm[listIn[[i]]] <>"\n"];,
          1,
          	For[i1=1,i1\[LessEqual]getDimSPheno[listIn[[i]]][[1]],
              	
              WriteString[sphenoLH,
                ToString[i1]<>" 0.000000E+00 \t  # "<>
                  SPhenoForm[listIn[[i]]] <>"("<>ToString[i1] <>")\n"];
              	i1++;];,
          2,
          	For[i1=1,i1\[LessEqual]getDimSPheno[listIn[[i]]][[1]],
              	For[i2=1,i2\[LessEqual]getDimSPheno[listIn[[i]]][[2]],
                	
                WriteString[sphenoLH,
                  ToString[i1]<>" "<>ToString[i2]<>" 0.000000E+00 \t  # "<>
                    SPhenoForm[listIn[[i]]] <>"("<>ToString[i1] <>","<>
                    ToString[i2]<>")\n"];
                	i2++;];
              	i1++;];,
          3,
          	For[i1=1,i1\[LessEqual]getDimSPheno[listIn[[i]]][[1]],
              	For[i2=1,i2\[LessEqual]getDimSPheno[listIn[[i]]][[2]],
                	For[i3=1,i3\[LessEqual]getDimSPheno[listIn[[i]]][[3]],
                  	
                  WriteString[sphenoLH,
                    ToString[i1]<>" "<>ToString[i2]<>" "<>ToString[i3]<>" 0.000000E+00 \t  # "<>
                      SPhenoForm[listIn[[i]]] <>"("<>ToString[i1] <>","<>
                      ToString[i2]<>","<>ToString[i3]<>")\n"];
                  	i3++;];
                	i2++;];
              	i1++;];
          ];
        i++;];
      
      
      
      
      (* For[k=1,k\[LessEqual]2,
            If[k\[Equal]1,
              listIn=lowScaleIn;
              
              listname=(ToExpression[StringDrop[ToString[#],-2]])&/@
                  lowScaleIn;,
              listIn=highScaleIn;
              
              listname=(ToExpression[StringDrop[ToString[#],-2]])&/@
                  highScaleIn;
              ];
            For[i=1,i\[LessEqual]Length[listIn],
              
              If[FreeQ[BoundarySUSYScale,listIn[[i]]]\[Equal]False || 
                  FreeQ[BoundaryEWSBScale,listIn[[i]]]\[Equal]False || 
                  FreeQ[ BoundaryHighScale, listIn[[i]]]\[Equal]False || 
                  FreeQ[BoundaryConditionsUp,listIn[[i]]]\[Equal]False || 
                  FreeQ[BoundaryConditionsDown,listIn[[i]]]\[Equal]False,
                
                WriteString[sphenoLH,
                  "Block "<>ToUpperCase[LHBlockName[listname[[i]]]] <>
                    "IN \t  #  \n"];
                Switch[Length[getDimSPheno[listIn[[i]]]],
                  0, 
                  WriteString[sphenoLH,
                      ToString[LHPos[listname[[i]]]]<>"\t 0.000000E+00 \t  # "<>
                        SPhenoForm[listIn[[i]]] <>"\n"];,
                  1,
                  	For[i1=1,i1\[LessEqual]getDimSPheno[listIn[[i]]][[1]],
                      	
                      WriteString[sphenoLH,
                        ToString[i1]<>" 0.000000E+00 \t  # "<>
                          SPhenoForm[listIn[[i]]] <>"("<>ToString[i1] <>
                          ")\n"];
                      	i1++;];,
                  2,
                  	For[i1=1,i1\[LessEqual]getDimSPheno[listIn[[i]]][[1]],
                      	For[i2=1,i2\[LessEqual]getDimSPheno[listIn[[i]]][[2]],
                        	
                        WriteString[sphenoLH,
                          ToString[i1]<>" "<>ToString[i2]<>" 0.000000E+00 \t  # "<>
                            SPhenoForm[listIn[[i]]] <>"("<>ToString[i1] <>","<>
                            ToString[i2]<>")\n"];
                        	i2++;];
                      	i1++;];
                  ];
                ];
              i++;];
            k++;]; *)
      
      Close[sphenoLH];
      
      ];


GenerateMakeFile[NameForModel_] :=Block[{i},
      Print["Writing Makefile"];
      
      sphenoMake=OpenWrite[ToFileName[$sarahCurrentSPhenoDir,"Makefile"]];
      
      
      
      WriteString[sphenoMake,
        "modname = "<>NameForModel<> "  # as an example  \n"];
      WriteString[sphenoMake,"PreDef = -DGENERATIONMIXING -DONLYDOUBLE\n"];
      WriteString[sphenoMake,"# setting various paths  \n"];
      WriteString[sphenoMake,"InDir = ../include\n"];
      WriteString[sphenoMake,"Mdir = ${InDir}\n"];
      WriteString[sphenoMake,
        "name = ../lib/libSPheno"<>NameForModel<>".a\n"];
      
      WriteString[sphenoMake,"#  \n"];
      WriteString[sphenoMake,"# options for various compilers  \n"];
      WriteString[sphenoMake,"#  \n"];
      
      WriteString[sphenoMake,"# Intels ifort,default in optimized mode  \n"];
      WriteString[sphenoMake,"F90=ifort  \n"];
      WriteString[sphenoMake,"comp= -c -g -module ${Mdir} -I${InDir}  \n"];
      WriteString[sphenoMake,"LFlagsB= -g  \n"];
      
      WriteString[sphenoMake,"# Intels ifort,debug modus  \n"];
      WriteString[sphenoMake,"ifeq (${F90},ifortg)  \n"];
      WriteString[sphenoMake,"F90=ifort  \n"];
      WriteString[sphenoMake,"comp= -c -g -module ${Mdir} -I${InDir}  \n"];
      WriteString[sphenoMake,"LFlagsB= -g  \n"];
      WriteString[sphenoMake,"endif  \n"];
      
      WriteString[sphenoMake,"# gfortran  \n"];
      WriteString[sphenoMake,"ifeq (${F90},gfortran)  \n"];
      WriteString[sphenoMake,"comp= -c -O -J${Mdir} -I${InDir}  \n"];
      WriteString[sphenoMake,"LFlagsB= -O  \n"];
      WriteString[sphenoMake,"endif  \n"];
      
      WriteString[sphenoMake,"# g95  \n"];
      WriteString[sphenoMake,"ifeq (${F90},g95)  \n"];
      WriteString[sphenoMake,"comp= -c -O -fmod=${Mdir} -I${InDir}  \n"];
      WriteString[sphenoMake,"LFlagsB= -O  \n"];
      WriteString[sphenoMake,"endif  \n"];
      
      WriteString[sphenoMake,"# Lahey F95 compiler  \n"];
      WriteString[sphenoMake,"ifeq (${F90},lf95)  \n"];
      WriteString[sphenoMake,"comp=-c -O -M ${Mdir} -I${InDir}  \n"];
      WriteString[sphenoMake,"LFlagsB=-O  \n"];
      WriteString[sphenoMake,"endif  \n"];
      
      WriteString[sphenoMake,"# NAG f95/2003  \n"];
      WriteString[sphenoMake,"ifeq (${F90},nagfor)  \n"];
      WriteString[sphenoMake,"comp= -c -O -M ${Mdir} -I${InDir}  \n"];
      WriteString[sphenoMake,
        "LFlagsB= -c -O -DONLYDOUBLE -mdir ${MDir} -I${InDir}  \n"];
      WriteString[sphenoMake,"endif   \n"];
      
      
      
      WriteString[sphenoMake,".SUFFIXES : .o .ps .f90 .F90 .a \n"];
      WriteString[sphenoMake,"bin/SPheno"<>NameForModel<>":\n"];
      WriteString[sphenoMake,"\t cd ../src ; ${MAKE} F90=${F90} \n"];
      WriteString[sphenoMake,"\t ${MAKE} F90=${F90} ${name} \n"];
      WriteString[sphenoMake,
        "\t ${MAKE} F90=${F90} SPheno"<>NameForModel<>".o \n"];
      WriteString[sphenoMake,
        "\t ${F90} -o SPheno"<>NameForModel<>" ${LFlagsB} SPheno"<>
          NameForModel<>".o ../lib/libSPheno"<>NameForModel<>
          ".a ../lib/libSPheno.a\n"];
      WriteString[sphenoMake,"\t mv SPheno"<>NameForModel<>" ../bin\n"];
      WriteString[sphenoMake,
        "${name}:  ${name}(Model_Data_"<>ModelName<>".o)  \\\n"]; 
      WriteString[sphenoMake," ${name}(RGEs_"<>ModelName<>".o)   \\\n"];  
      WriteString[sphenoMake,
        " ${name}(Couplings_"<>ModelName<>".o) ${name}(SusyMasses_"<>
          ModelName<>".o) \\\n"];  
      WriteString[sphenoMake,
        " ${name}(LoopCouplings_"<>ModelName<>".o) \\\n"];  
      WriteString[sphenoMake," ${name}(SusyDecays_"<>ModelName<>".o) \\\n"]; 
      If[Length[ListDecayParticles3B]>0,
        For[i=1,i\[LessEqual]Length[ListDecayParticles3B],
          
          WriteString[sphenoMake,
            " ${name}("<>StringDrop[ToString[ListDecayParticles3B[[i,2]]],-4]<>
              ".o) "];
          i++;];
        WriteString[sphenoMake ," \\\n"];
        ];
      If[UseHiggs2LoopMSSM===True,
        WriteString[sphenoMake,
            " ${name}(BranchingRatios_"<>ModelName<>".o) ${name}(TwoLoopHiggsMass_SARAH.o) ${name}(LoopMasses_"<>
              ModelName<>".o) \\\n"];,
        WriteString[sphenoMake,
            " ${name}(BranchingRatios_"<>ModelName<>".o) ${name}(LoopMasses_"<>
              ModelName<>".o) \\\n"];
        ];
      If[Head[RegimeNr]===Integer,
        WriteString[sphenoMake," ${name}(Shifts_"<>ModelName<>".o) \\\n"];
        ];
      If[AddLowEnergyConstraint ===True,
        WriteString[sphenoMake,
            " ${name}(SugraRuns_"<>ModelName<>".o) ${name}(LowEnergy_"<>
              ModelName<>".o) ${name}(InputOutput_"<>ModelName<>".o) \n"];,
        WriteString[sphenoMake,
            " ${name}(SugraRuns_"<>ModelName<>".o) ${name}(InputOutput_"<>
              ModelName<>".o) \n"];
        ];
      WriteString[sphenoMake,"clean: \n"];
      WriteString[sphenoMake,"\t rm -f *.o *~ */*.o */*~\n"];
      WriteString[sphenoMake,"cleanall: \n"];
      WriteString[sphenoMake,
        "\t rm -f bin/SPheno3 lib/*.a *~ */*.o */*~ include/*\n"];
      WriteString[sphenoMake,"#\n"];
      WriteString[sphenoMake,"# Suffix rules\n"];
      WriteString[sphenoMake,"#\n"];
      WriteString[sphenoMake,".f90.a:\n"];
      WriteString[sphenoMake,"\t ${F90} ${comp} $< \n"]; 
      WriteString[sphenoMake,"\t ar -ruc $@ $*.o\n"];
      WriteString[sphenoMake,"\t rm -f $*.o\n"];
      WriteString[sphenoMake,".F90.a:\n"];
      WriteString[sphenoMake,"\t ${F90} ${comp} ${PreDef} $< \n"];
      WriteString[sphenoMake,"\t ar -ruc $@ $*.o\n"];
      WriteString[sphenoMake,"\t rm -f $*.o\n"];
      WriteString[sphenoMake,".f90.o:\n"];
      WriteString[sphenoMake,"\t ${F90} ${comp} $<\n"];
      WriteString[sphenoMake,".f90.ps:\n"];
      WriteString[sphenoMake,"\t a2ps -o $*.ps $<\n"];
      WriteString[sphenoMake,".h.ps:\n"];
      WriteString[sphenoMake,"\t a2ps -o $*.ps $<\n"];
      
      Close[sphenoMake];
      
      
      
      ];





(* GenerateMakeFile[NameForModel_] :=Block[{i},
        Print["Writing Makefile"];
        
        sphenoMake=OpenWrite[ToFileName[$sarahCurrentSPhenoDir,"Makefile"]];
        
        WriteString[sphenoMake,"PreDef = -DGENERATIONMIXING -DONLYDOUBLE\n"];
        WriteString[sphenoMake,"InDir = ../include\n"];
        WriteString[sphenoMake,"Mdir = ${InDir}\n"];
        WriteString[sphenoMake,"F90 = g95\n"];
        WriteString[sphenoMake,"F90 = ifort\n"];
        WriteString[sphenoMake,"LFlagsB = -O\n"];
        WriteString[sphenoMake,"LFlagsB = -g\n"];
        WriteString[sphenoMake,"comp = -c -g -fmod=${Mdir} -I${InDir}\n"];
        WriteString[sphenoMake,"comp = -c -g -mod ${Mdir} -I${InDir}\n"];
        WriteString[sphenoMake,"comp = -c -g -mod ${Mdir} -I${InDir}\n"];
        WriteString[sphenoMake,"name = ../lib/libSPheno.a\n"];
        WriteString[sphenoMake,".SUFFIXES : .o .ps .f90 .F90 .a \n"];
        WriteString[sphenoMake,"bin/SPheno: ${name} SPheno3.o\n"];
        WriteString[sphenoMake,
          "\t ${F90} -o SPheno ${LFlagsB} SPheno3.o ../lib/${name}\n"];
        WriteString[sphenoMake,"\t mv SPheno ../bin\n"];
        WriteString[sphenoMake,
          "${name}: ${name}(Control.o) ${name}(Mathematics.o)   ${name}(Model_Data.o)  \\\n"]\
; WriteString[sphenoMake,
          " ${name}(RGEs.o)  ${name}(StandardModel.o) ${name}(MathematicsQP.o) \\\n"]\
;  WriteString[sphenoMake,
          " ${name}(Couplings.o) ${name}(SusyMasses.o) ${name}(LoopFunctions.o) \\\n"]\
;  
        WriteString[sphenoMake,
          " ${name}(LoopCouplings.o) ${name}(DecayFunctions.o) \\\n"];  
        WriteString[sphenoMake,
          " ${name}(SusyDecays.o) ${name}(ThreeBodyPhaseSpace.o) ${name}(ThreeBodyPhaseSpaceS.o) \\\n"]\
; 
        If[Length[ListDecayParticles3B]>0,
          For[i=1,i\[LessEqual]Length[ListDecayParticles3B],
            WriteString[sphenoMake,
              " ${name}("<>StringDrop[
                  ToString[ListDecayParticles3B[[i,2]]],-4]<>".o) "];
            i++;];
          WriteString[sphenoMake ," \\\n"];
          ];
        WriteString[sphenoMake,
          " ${name}(BranchingRatios.o) ${name}(TwoLoopHiggsMass.o) ${name}(LoopMasses.o) \\\n"]\
;
        If[Head[RegimeNr]===Integer,
          WriteString[sphenoMake," ${name}(Shifts.o) \\\n"];
          ];
        If[AddLowEnergyConstraint ===True,
          
          WriteString[sphenoMake,
              " ${name}(SugraRuns.o) ${name}(LowEnergy.o) ${name}(InputOutput.o) \n"]\
;,
          
          WriteString[sphenoMake,
              " ${name}(SugraRuns.o) ${name}(InputOutput.o) \n"];
          ];
        WriteString[sphenoMake,"clean: \n"];
        WriteString[sphenoMake,"\t rm -f *.o *~ */*.o */*~\n"];
        WriteString[sphenoMake,"cleanall: \n"];
        WriteString[sphenoMake,
          "\t rm -f bin/SPheno3 lib/*.a *~ */*.o */*~ include/*\n"];
        WriteString[sphenoMake,"#\n"];
        WriteString[sphenoMake,"# Suffix rules\n"];
        WriteString[sphenoMake,"#\n"];
        WriteString[sphenoMake,".f90.a:\n"];
        WriteString[sphenoMake,"\t ${F90} ${comp} $< \n"]; 
        WriteString[sphenoMake,"\t ar -ruc $@ $*.o\n"];
        WriteString[sphenoMake,"\t rm -f $*.o\n"];
        WriteString[sphenoMake,".F90.a:\n"];
        WriteString[sphenoMake,"\t ${F90} ${comp} ${PreDef} $< \n"];
        WriteString[sphenoMake,"\t ar -ruc $@ $*.o\n"];
        WriteString[sphenoMake,"\t rm -f $*.o\n"];
        WriteString[sphenoMake,".f90.o:\n"];
        WriteString[sphenoMake,"\t ${F90} ${comp} $<\n"];
        WriteString[sphenoMake,".f90.ps:\n"];
        WriteString[sphenoMake,"\t a2ps -o $*.ps $<\n"];
        WriteString[sphenoMake,".h.ps:\n"];
        WriteString[sphenoMake,"\t a2ps -o $*.ps $<\n"];
        
        Close[sphenoMake];
        
        
        
        ]; *)