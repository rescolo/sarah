(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)

Block[{$Path={$sarahSPhenoPackageDir}},
    <<SPhenoCoupling`;
    <<SPhenoMain`;
    <<SPhenoFunc`;
    <<SPhenoSusyDecays`;
    <<SPheno3BodyDecay`;
    <<SPhenoTreeMasses`;
    <<SPhenoRGE`;
    <<SPhenoInOut`;
    <<SPhenoSugra`;
    <<SPhenoRunRGE`;
    <<SPhenoBoundaryEW`;
    <<SPhenoBR`;
    <<SPhenoLoopMasses`;
    <<SPhenoMassShift`;
    <<SPhenoModelData`;
    <<SPhenoLoopCouplings`;
    <<SPhenoLesHouchesAndMake`;
    <<SPhenoLoopContributions`;
    
    
    
    ];

Options[MakeSPheno]={Eigenstates\[Rule]EWSB,TwoLoop\[Rule]True,
      ReadLists\[Rule]False, InputFile->"SPheno.m"};

MakeSPheno[opt___ ]:=
    MakeSPhenoOutput[Eigenstates/.{opt}/.Options[MakeSPheno],
      TwoLoop/.{opt}/.Options[MakeSPheno],
      ReadLists/.{opt}/.Options[MakeSPheno],
      InputFile/.{opt}/.Options[MakeSPheno]];

MakeSPhenoOutput[Eigenstates_, TwoL_,ReadL_, inputfile_]:=Block[{i,i1,i2},
      SPhenoFile=ToFileName[{$sarahCurrentModelDir},inputfile];
      
      AbortStartSPheno=False;
      SARAHFortran=True;
      parametersSave= parameters;
      
      Off[FileByteCount::nffil];
      
      If[FileByteCount[SPhenoFile]===$Failed,
        Print["File for SPheno-Output does not exist!"];
        AbortStartSPheno=True;,
        Get[SPhenoFile];
        ];
      
      NameForModel = ModelName;
      
      If[AbortStartSPheno==False,
        
        If[Length[Thresholds]>0,
          GenerateInformationForThresholds;
          SetOptions[CalcRGEs,VariableGenerations\[Rule]ThresholdParticles];
          ImplementThresholds=True;,
          ImplementThresholds=False;
          ];
        
        If[Head[HeavyFields]===List && IntermediateScale \[Equal]True,
          temp = {};
          For[i=1,i\[LessEqual]Length[HeavyFields],
            If[Head[HeavyFields[[i]]]===Symbol,
              temp = Join[temp,{HeavyFields[[i]]}];
              getStartHeavy[HeavyFields[[i]]]=1;,
              temp = Join[temp,{HeavyFields[[i,0]]}];
              StartGenHeavyField[HeavyFields[[i,0]]]=HeavyFields[[i,1]];
              getStartHeavy[HeavyFields[[i,0]]]=HeavyFields[[i,1]];
              ];
            i++;];
          
          HeavyFields=temp;
          
          SetOptions[CalcLoopCorrections,OnlyWith\[Rule]HeavyFields];
          ];
        
        
        If[IntermediateScale ===True,
          If[Head[HeavyFields]===List,
              
              ModelOutput[Eigenstates, ReadLists\[Rule]ReadL, 
                  IncludeLoopCorrections \[Rule]True,IncludeRGEs\[Rule]True,
                  TwoLoopRGEs\[Rule]True, VerticesForLoops\[Rule]True,
                  IncludeVertices\[Rule]True];,
              
              ModelOutput[Eigenstates, ReadLists\[Rule]ReadL, 
                  IncludeLoopCorrections \[Rule]False,IncludeRGEs\[Rule]True,
                  TwoLoopRGEs\[Rule]True, VerticesForLoops\[Rule]False,
                  IncludeVertices\[Rule]False];
              ];,
          
          ModelOutput[Eigenstates, ReadLists\[Rule]ReadL, 
              IncludeLoopCorrections \[Rule]True,IncludeRGEs\[Rule]True,
              TwoLoopRGEs\[Rule]True, VerticesForLoops\[Rule]True];
          ];
        
        
        $sarahCurrentSPhenoDir=ToFileName[{$sarahCurrentOutputDir,"SPheno"}];
        
        If[FileExistsQ[$sarahCurrentSPhenoDir]=!=True,
          CreateDirectory[$sarahCurrentSPhenoDir];
          ];
        
        Print["--------------------------------"];
        Print["Generate SPheno Source Code"];
        Print["--------------------------------"];
        
        SPhenoParameters = parameters;
        
        NewNumericalDependences ={};
        NewNumericalDependencesSub = {};
        
        For[i=1,i\[LessEqual]Length[rotationAngleGaugeBoson],
          
          NewNumericalDependences =
            Join[NewNumericalDependences ,{{rotationAngleGaugeBoson[[i]],
                  rotationAngleGaugeBoson[[i]]/.subNumDependences}}];
          
          NewNumericalDependencesSub = 
            Join[NewNumericalDependencesSub,{rotationAngleGaugeBoson[[i]]\
\[Rule](rotationAngleGaugeBoson[[i]]/.subNumDependences)}];
          i++;
          ];
        
        If[Length[Thresholds]>0,
          GenerateInformationForThresholds;
          SetOptions[CalcRGEs,VariableGenerations\[Rule]ThresholdParticles];
          ImplementThresholds=True;,
          ImplementThresholds=False;
          ];
        
        
        
        MakeSPhenoFortran;
        If[
          Head[TadpoleEquations[Eigenstates]]===List && 
            UseGivenTadpoleSolution=!=True,
          SolveTadpoleEquation[Eigenstates,ParametersToSolveTadpoles];
          ];
        
        If[IntermediateScale =!=True,
          InitSMParameters[Eigenstates];
          ];
        InitInfoForSPheno[Eigenstates];
        
        
        If[Head[RegimeNr]\[Equal]Integer,
          If[IntermediateScale =!=True,
              $sarahMetaDir=
                ToFileName[{ToFileName[{$sarahModelDir,Modelname}],"Meta"}];
              
              If[FileExistsQ[$sarahMetaDir]=!=True,
                CreateDirectory[$sarahMetaDir];];
              Print["-------------------------------------------------- "];
              Print["Evaluating all Regimes: This can last some time!"];
              Print["A new Mathematica Kernel is started."];
              Print["Progress can be supervised in ", $sarahMetaDir];
              Print["-------------------------------------------------- "];
              ListFormerParameters = LowScaleParameter;
              For[i=RegimeNr-1,i\[GreaterEqual] 1,
                Print["Current Regime: ", i];
                CalculateIntermediateScale[i,ReadL];
                Print["...  finished!"];
                Print[""];
                i--;];
              
              DimensionsOtherRegimes = Table[{},{RegimeNr}];
              GenerationsOfHeavyFieldsAllRegimes = Table[{},{RegimeNr}];
              LowScaleParametersAllRegimes= Table[{},{RegimeNr}];
              HighScaleParametersAllRegimes= Table[{},{RegimeNr}];
              HighScaleParametersAllwithVEVsRegimes= Table[{},{RegimeNr}];
              NumberLowAllRegimes= Table[{},{RegimeNr}];
              NumberHighAllRegimes= Table[{},{RegimeNr}];
              NumberAllwithVEVsAllRegimes= Table[{},{RegimeNr}];
              ListOfRegimeEigenstates = Table[{},{RegimeNr}];
              ListOfAdditionalParameters ={};
              ListVEVsAllRegimes = Table[{},{RegimeNr}];
              GaugeCouplingsAllRegimes= Table[{},{RegimeNr}];
              GauginosAllRegimes= Table[{},{RegimeNr}];
              GroupFactorHeavyFields= Table[{},{RegimeNr}];
              YukawaCouplingsAllRegimes= Table[{},{RegimeNr}];
              LHnamesAllRegimes= Table[{},{RegimeNr}];
              
              ParametersToSolveTadpolesAllRegimes= Table[{},{RegimeNr}];
              
              
              
              GaugeCouplingsAllRegimes[[RegimeNr]]=
                Intersection[Table[Gauge[[i,4]],{i,1,AnzahlGauge}]];
              
              GauginosAllRegimes[[RegimeNr]]=
                Intersection[Table[MassGauge[i],{i,1,AnzahlGauge}]];
              
              ParametersToSolveTadpolesAllRegimes[[RegimeNr]] = 
                ParametersToSolveTadpoles;
              
              Print["Reading information of all Regimes"];
              
              For[i=1,i<RegimeNr,
                ReadInformationOtherRegimes[i];
                i++;];
              AdditionalFortranForm;
              ];
          ];
        
        
        CheckDefinitionParameters;
        
        
        InitInputOutput;
        GenerateSPhenoRGEs; 
        
        GenerateSPhenoTreeMasses[Eigenstates];
        If[IntermediateScale=!= True,
          GenerateSPhenoCouplingList; 
          GenerateSPhenoLoopCouplings[Eigenstates];
          GenerateSPhenoSusyDecays[Eigenstates];
          GenerateSPhenoBR[Eigenstates];
          GenerateSPhenoLoopMasses[Eigenstates];
          MakePDGList[Eigenstates];
          MakeModelData;
          GenerateSugraRuns;
          
          If[SPhenoLowEnergyIncluded =!=True,
            AddLowEnergyConstraint=False;
            ];
          
          If[AddLowEnergyConstraint ===True,
            GenerateSPhenoLowEnergy;
            ];
          GenerateInOut;
          GenerateSPhenoMain[NameForModel];
          GenerateLesHouchesFile;
          GenerateMakeFile[NameForModel];
          
          If[UseHiggs2LoopMSSM\[Equal]True,
            CreateHiggs2Loop;
            ];
          
          If[Head[RegimeNr]===Integer,
            MakeShiftsFile;
            ];,
          GenerateSPhenoMassShift[Eigenstates];
          WriteMetaInformation[RegimeNr,Eigenstates];
          ];
        ];
      
      SARAHFortran=False;
      parameters= parametersSave;
      
      Print[""];
      Print["Finished! Output is in ",$sarahCurrentSPhenoDir ];
      Print["Copy files to subdirectory /",NameForModel," of SPheno"];
      Print["and compile the model afterwards using \"make\"."];
      
      
      ];

SolveTadpoleEquation[Eigenstates_,parameters_]:=
    Block[{i,TEqu, subReal,i1,i2,temp},
      Print["Solve Tadpole equations for given parameters"];
      
      resLoop={};
      resTree={};
      EquLoop={};
      EquTree={};
      SquaredParametersTadpoles={};
      
      temp=TadpoleEquations[Eigenstates];
      TEqu={};
      
      For[i=1,i\[LessEqual]Length[temp],
        For[j=1,j\[LessEqual]getGenALL[DEFINITION[Eigenstates][VEVs][[i,1]]],
          
          TEqu = Join[
              TEqu, {ReleaseHold[
                  temp[[i]] /. {gt1\[Rule]j}/. 
                    sum[a_,b_,c_,d_]\[Rule]Hold[Sum[d,{a,b,c}]]]}];
          j++;];
        i++;];
      
      For[i=1,i\[LessEqual]Length[TEqu],
        EquLoop = Join[EquLoop,{TEqu[[i]]-Tad1Loop[i]\[Equal]0}];
        EquTree = Join[EquTree,{TEqu[[i]]\[Equal]0}];
        i++;];
      
      subReal = {};
      subSPhenoForm={};
      subSPhenoFormBack={};
      
      For[i=1,i\[LessEqual]Length[parameters],
        subReal = 
          Join[subReal,{conj[parameters[[i]]]\[Rule]parameters[[i]]}];
        temp = 
          parameters[[i]] /. a_[b_Integer]\[Rule]a  /. 
            a_[b_Integer,c_Integer]\[Rule]a;
        subSPhenoForm=
          Join[subSPhenoForm,{temp\[Rule] ToExpression[SPhenoForm[temp]]}];
        subSPhenoFormBack=
          Join[subSPhenoFormBack,{ToExpression[SPhenoForm[temp]]\[Rule]
                temp}];
        i++;];
      
      EquLoop = EquLoop /. subReal /. subSPhenoForm;
      EquTree = EquTree /. subReal /. subSPhenoForm;
      
      resLoop=
        Solve[EquLoop,(parameters /. subSPhenoForm)] /. subSPhenoFormBack;
      resTree=
        Solve[EquTree,(parameters /. subSPhenoForm)]/. subSPhenoFormBack;
      
      
      NewParametersFromTadpoles={};
      SignumsTadpoles={};
      
      If[Length[resLoop]>1,
        SubSolutionsTadpolesLoop={};
        SubSolutionsTadpolesTree={};
        For[i=1,i\[LessEqual]Length[resLoop[[1]]],
          If[FreeQ[EquLoop,(resLoop[[1,i,1]]^2 /. subSPhenoForm)],
            SubSolutionsTadpolesLoop=
              Join[SubSolutionsTadpolesLoop,{resLoop[[1,i]]}];
            
            SubSolutionsTadpolesTree=
              Join[SubSolutionsTadpolesTree,{resTree[[1,i]]}];,
            absName = ToExpression["Abs2"<>SPhenoForm[resLoop[[1,i,1]]]];
            phaseName=ToExpression["Signum"<>SPhenoForm[resLoop[[1,i,1]]]];
            
            SignumsTadpoles = 
              Join[SignumsTadpoles,{{resLoop[[1,i,1]], phaseName}}];
            
            SquaredParametersTadpoles=
              Join[SquaredParametersTadpoles,{{absName,resLoop[[1,i,1]],
                    phaseName}}];
            
            NewParametersFromTadpoles=
              Join[NewParametersFromTadpoles,{absName}];
            SPhenoParameters = Join[SPhenoParameters,{{absName,{},{}}}];
            realVar=Join[realVar,{absName}];
            
            SubSolutionsTadpolesLoop=
              Join[SubSolutionsTadpolesLoop,{absName->resLoop[[1,i,2]]^2,
                  resLoop[[1,i,1]]\[Rule]phaseName*Sqrt[absName]}];
            
            SubSolutionsTadpolesTree=
              Join[SubSolutionsTadpolesTree,{absName->resTree[[1,i,2]]^2,
                  resTree[[1,i,1]]\[Rule]phaseName*Sqrt[absName]}];
            ];
          i++;];,
        SubSolutionsTadpolesLoop=Flatten[resLoop] ;
        SubSolutionsTadpolesTree=Flatten[resTree]; 
        ];
      
      If[SubSolutionsTadpolesLoop\[Equal]{},
        Message[SPheno::Tadpoles];
        ];
      
      Print["   Simplify solutions"];
      
      SubSolutionsTadpolesLoop=
        FullSimplify[SubSolutionsTadpolesLoop] //. 
            Sqrt[a_] Sqrt[b_]\[Rule] Sqrt[a b] //. 
          Sqrt[a_]/Sqrt[b_]\[Rule]Sqrt[a/b];
      SubSolutionsTadpolesTree=
        FullSimplify[SubSolutionsTadpolesTree]//. 
            Sqrt[a_] Sqrt[b_]\[Rule] Sqrt[a b] //. 
          Sqrt[a_]/Sqrt[b_]\[Rule]Sqrt[a/b]; 
      
      
      ];





InitInfoForSPheno[Eigenstates_]:=
    Block[{i,pos,tempName,i1,i2,neededParameters,neededParameterNames,
        namelist},
      
      If[IntermediateScale=!=True,
        neededParameters={UpYukawa,DownYukawa,ElectronYukawa,
            hyperchargeCoupling,leftCoupling,strongCoupling,ElectronMatrixL,
            ElectronMatrixR,DownMatrixL,DownMatrixR,UpMatrixL,UpMatrixR,
            VEVSM1,VEVSM2,HiggsMixingMatrix};
        neededParameterNames={"Up-Yukawa-Coupling","Down-Yukawa-Coupling","Lepton-Yukawa-Coupling",
            "Hypercharge-Coupling","Left-Coupling","Strong-Coupling","Left-Lepton-Mixing-Matrix",
            "Right-Lepton-Mixing-Matrix","Left-Down-Mixing-Matrix","Right-Down-Mixing-Matrix",
            "Left-Up-Mixing-Matrix","Right-Up-Mixing-Matrix","Down-VEV","Up-VEV",
            "Scalar-Mixing-Matrix"};
        
        For[i=1,i\[LessEqual]Length[neededParameters],
          If[FreeQ[parameters,neededParameters[[i]]],
            Message[SPheno::UndefinedParameter,neededParameterNames[[i]]];
            ];
          i++;];
        
        neededParameters={Electron,BottomQuark,TopQuark,VectorP,VectorG,
            VectorW,VectorZ,HiggsBoson,Neutrino};
        
        neededParameterNames={"Leptons","Down-Quarks","Up-Quarks","Photon","Gluon",
            "W-Boson","Z-Boson","Higgs","Neutrinos"};
        
        namelist=
          getParticleNameDirac /@ 
            Table[Particles[Eigenstates][[i,1]],{i,1,
                Length[Particles[EWSB]]}];
        For[i=1,i\[LessEqual]Length[neededParameters],
          
          If[FreeQ[namelist,neededParameters[[i]]] &&  
              FreeQ[Particles[Eigenstates],neededParameters[[i]]] ,
            Message[SPheno::UndefinedParticle,neededParameterNames[[i]]];
            ];
          i++;];
        ];
      
      
      
      Print["Build parameter lists"];
      SeveralBoundaryConditions=False;
      
      realVar = Join[realVar,{RealParameters}];
      
      If[Depth[BoundaryHighScale]>2,
        If[BoundaryHighScale[[1]]=!={},
            
            If[Head[BoundaryHighScale[[1,1]]]===List,
                SeveralBoundaryConditions=True;];
            ];
        ];
      If[Depth[BoundarySUSYScale]>2,
        If[BoundarySUSYScale[[1]]=!={},
            
            If[Head[BoundarySUSYScale[[1,1]]]===List,
                SeveralBoundaryConditions=True;];
            ];
        ];
      If[Depth[BoundaryEWSBScale]>2,
        If[BoundaryEWSBScale[[1]]=!={},
            
            If[Head[BoundaryEWSBScale[[1,1]]]===List,
                SeveralBoundaryConditions=True;];
            ];
        ];
      
      
      If[SeveralBoundaryConditions\[Equal]True,
        If[BoundarySUSYScale=!={} && Head[BoundarySUSYScale]===List,
          BoundarySUSY=BoundarySUSYScale[[1]];];
        If[BoundaryEWSBScale=!={} && Head[BoundaryEWSBScale]===List,
          BoundaryEWSB=BoundaryEWSBScale[[1]];];
        If[BoundaryHighScale=!={} && Head[BoundaryHighScale]===List,
          BoundaryHigh=BoundaryHighScale[[1]];];,
        BoundarySUSY=BoundarySUSYScale;
        BoundaryEWSB=BoundaryEWSBScale;
        BoundaryHigh=BoundaryHighScale;
        ];
      
      
      
      If[ListDecayParticles===Automatic,
        ListDecayParticles = 
          Join[Join[AllScalarNonSM,AllFermionNonSM],{TopQuark}];
        ListDecayParticles = Select[ListDecayParticles,(getType[#]=!=V)&];
         ];
      
      If[ListDecayParticles3B===Automatic,
        ListDecayParticles3B={};
        For[i=1,i\[LessEqual]Length[AllFermionNonSM],
          
          ListDecayParticles3B= 
            Join[ListDecayParticles3B,{{AllFermionNonSM[[i]],
                  ToString[AllFermionNonSM[[i]]]<>"_"<>ModelName<>".f90"}}];
          i++;];
         ];
      
      If[Head[LowScaleParameter]=!=List || Head[HighScaleParameter]=!=List,
        
        NeededParametersForRGEs = {};
        
        If[IntermediateScale ===True,
          LowScaleParameter = MinimalParameterSetUp;,
          
          LowScaleParameter = {hyperchargeCoupling,leftCoupling,
                strongCoupling,ElectronYukawa,DownYukawa,UpYukawa};
          ];
        
        HighScaleParameter = Table[Gauge[[i,4]],{i,1,AnzahlGauge}];
        
        For[i=1,i\[LessEqual]Length[BetaGauge],
          
          NeededParametersForRGEs= 
            Join[NeededParametersForRGEs,{{BetaGauge[[i,1]],
                  getInvolvedParameters[BetaGauge[[i]]]}}];
          i++;];
        
        
        If[Length[listWtriOne]\[NotEqual] 0,
          
          tempList=
            Transpose[
                Transpose[
                    listWtriOne /. Delta[a__]\[Rule]1 /. 
                        epsTensor[a__]\[Rule]1 /. 
                      RM[a__][b__]\[Rule]1][[2]]][[2]];
          HighScaleParameter = Join[HighScaleParameter,tempList];
          
          For[i=1,i\[LessEqual]Length[BetaYijk],
            
            NeededParametersForRGEs= 
              Join[NeededParametersForRGEs,{{BetaYijk[[i,1]],
                    getInvolvedParameters[BetaYijk[[i]]]}}];
            i++;];
          ];
        
        If[Length[listW4One]\[NotEqual] 0,
          
          tempList=
            Transpose[
                Transpose[
                    listW4One/. Delta[a__]\[Rule]1 /. epsTensor[a__]\[Rule]1 /. 
                      RM[a__][b__]\[Rule]1][[2]]][[2]];
          HighScaleParameter = Join[HighScaleParameter,tempList];
          
          For[i=1,i\[LessEqual]Length[BetaWijkl],
            
            NeededParametersForRGEs= 
              Join[NeededParametersForRGEs,{{BetaWijkl[[i,1]],
                    getInvolvedParameters[BetaWijkl[[i]]]}}];
            i++;];
          ];
        
        
        If[Length[listWbiOne]\[NotEqual] 0,
          
          tempList=
            Transpose[
                Transpose[
                    listWbiOne/. Delta[a__]\[Rule]1 /. 
                        epsTensor[a__]\[Rule]1 /. 
                      RM[a__][b__]\[Rule]1][[2]]][[2]];
          HighScaleParameter = Join[HighScaleParameter,tempList];
          
          For[i=1,i\[LessEqual]Length[BetaMuij],
            
            NeededParametersForRGEs= 
              Join[NeededParametersForRGEs,{{BetaMuij[[i,1]],
                    getInvolvedParameters[BetaMuij[[i]]]}}];
            i++;];
          
          ];
        
        
        If[Length[listAtriOne]\[NotEqual] 0,
          
          tempList=
            Transpose[
                Transpose[
                    listAtriOne/. Delta[a__]\[Rule]1 /. 
                        epsTensor[a__]\[Rule]1 /. 
                      RM[a__][b__]\[Rule]1][[2]]][[2]];
          HighScaleParameter = Join[HighScaleParameter,tempList];
          
          For[i=1,i\[LessEqual]Length[BetaTijk],
            
            NeededParametersForRGEs= 
              Join[NeededParametersForRGEs,{{BetaTijk[[i,1]],
                    getInvolvedParameters[BetaTijk[[i]]]}}];
            i++;];
          
          
          ];
        
        If[Length[listAbiOne]\[NotEqual] 0,
          
          tempList=
            Transpose[
                Transpose[
                    listAbiOne/. Delta[a__]\[Rule]1 /. 
                        epsTensor[a__]\[Rule]1 /. 
                      RM[a__][b__]\[Rule]1][[2]]][[2]];
          HighScaleParameter = Join[HighScaleParameter,tempList];
          
          For[i=1,i\[LessEqual]Length[BetaBij],
            
            NeededParametersForRGEs= 
              Join[NeededParametersForRGEs,{{BetaBij[[i,1]],
                    getInvolvedParameters[BetaBij[[i]]]}}];
            i++;];
          
          ];
        
        If[Length[listSM]\[NotEqual] 0,
          
          tempList=
            Transpose[
                  listSM/. Delta[a__]\[Rule]1 /. epsTensor[a__]\[Rule]1 /. 
                    RM[a__][b__]\[Rule]1][[2]] /. Delta[a__]\[Rule]1;
          HighScaleParameter = Join[HighScaleParameter,tempList];
          
          For[i=1,i\[LessEqual]Length[Betam2ij],
            
            NeededParametersForRGEs= 
              Join[NeededParametersForRGEs,{{Betam2ij[[i,1]],
                    getInvolvedParameters[Betam2ij[[i]]]}}];
            i++;];
          ];
        
        If[Length[listWone]\[NotEqual] 0,
          
          tempList=
            Transpose[
                  Transpose[
                      listWone/. Delta[a__]\[Rule]1 /. 
                          epsTensor[a__]\[Rule]1 /. 
                        RM[a__][b__]\[Rule]1][[2]]][[2]] /. 
              Delta[a__]\[Rule]1;
          HighScaleParameter = Join[HighScaleParameter,tempList];
          
          For[i=1,i\[LessEqual]Length[BetaLi],
            
            NeededParametersForRGEs= 
              Join[NeededParametersForRGEs,{{BetaLi[[i,1]],
                    getInvolvedParameters[BetaLi[[i]]]}}];
            i++;];
          ];
        
        If[Length[listAone]\[NotEqual] 0,
          
          tempList=
            Transpose[
                  Transpose[
                      listAone/. Delta[a__]\[Rule]1 /. 
                          epsTensor[a__]\[Rule]1 /. 
                        RM[a__][b__]\[Rule]1][[2]]][[2]] /. 
              Delta[a__]\[Rule]1;
          HighScaleParameter = Join[HighScaleParameter,tempList];
          
          For[i=1,i\[LessEqual]Length[BetaLSi],
            NeededParametersForRGEs= 
              Join[NeededParametersForRGEs,{{BetaLSi[[i,1]],
                    getInvolvedParameters[BetaLSi[[i]]]}}];
            i++;];
          ];
        
        
        
        If[Length[listGM]\[NotEqual] 0,
          
          tempList=
            Transpose[
                  listGM/. Delta[a__]\[Rule]1 /. epsTensor[a__]\[Rule]1 /. 
                    RM[a__][b__]\[Rule]1][[2]] /. Delta[a__]\[Rule]1;
          HighScaleParameter = Join[HighScaleParameter,tempList];
          
          For[i=1,i\[LessEqual]Length[BetaMi],
            
            NeededParametersForRGEs= 
              Join[NeededParametersForRGEs,{{BetaMi[[i,1]],
                    getInvolvedParameters[BetaMi[[i]]]}}];
            i++;];
          
          ];
        
        For[i=1,i\[LessEqual]Length[BoundaryEWSB],
          If[FreeQ[HighScaleParameter,BoundaryEWSB[[i,1]]]\[Equal]False,
            LowScaleParameter=Join[LowScaleParameter,{BoundaryEWSB[[i,1]]}];
            ];
          i++;];
        
        For[i=1,i\[LessEqual]Length[BoundarySUSY],
          
          If[FreeQ[HighScaleParameter,BoundarySUSY[[i,1]]]\[Equal]False && 
              FreeQ[LowScaleParameter,BoundarySUSY[[i,1]]],
            LowScaleParameter=Join[LowScaleParameter,{BoundarySUSY[[i,1]]}];
            ];
          i++;];
        
        
        For[i=1,i\[LessEqual]Length[BoundaryConditionsUp],
          For[i2=1,i2\[LessEqual]Length[BoundaryConditionsUp[[i]]],
            
            If[FreeQ[HighScaleParameter,
                  BoundaryConditionsUp[[i,i2,1]]]\[Equal]False,
              
              LowScaleParameter=
                  Join[LowScaleParameter,{BoundaryConditionsUp[[i,i2,1]]}];
              ];
            i2++;];
          i++;];
        
        
        SolveTadpoleEquationFirst = False;
        
        If[Head[BoundaryHigh]===List,
          conditionalParameters = Transpose[BoundaryHigh][[2]];,
          conditionalParameters = {};
          ];
        
        For[i=1,i\[LessEqual]Length[NeededParametersForRGEs],
          For[j=1,j\[LessEqual]Length[ParametersToSolveTadpoles],
            
            If[FreeQ[NeededParametersForRGEs[[i,2]], 
                    ParametersToSolveTadpoles[[j]]]\[Equal]False || 
                FreeQ[conditionalParameters , 
                    ParametersToSolveTadpoles[[j]]]\[Equal]False,
              
              If[FreeQ[ParametersToSolveTadpoles,
                      NeededParametersForRGEs[[i,1]]]\[Equal]True,
                  SolveTadpoleEquationFirst= True;
                  ];
              ];
            j++;];
          i++;];
        
        
        
        If[SolveTadpoleEquationFirst\[Equal]True,
          
          LowScaleParameter=
              Join[LowScaleParameter,ParametersToSolveTadpoles];
          ];
        
        LowScaleParameterOld=nix;
        FirstRun=True;
        
        LowScaleParameter = 
          LowScaleParameter /. a_[b_Integer]\[Rule]a /. 
            a_[b_Integer,c_Integer]\[Rule]a;
        
        
        
        While[
          LowScaleParameterOld =!= LowScaleParameter || First\[Equal]True,
          LowScaleParameterOld=LowScaleParameter;
          LowScaleParameter={};
          FirstRun=False;
          For[i=1,i\[LessEqual]Length[LowScaleParameterOld],
            
            If[FreeQ[Transpose[NeededParametersForRGEs][[1]],
                LowScaleParameterOld[[i]]],
              Print["Unknown Parameter: ",LowScaleParameterOld[[i]]];
              Interrupt[];
              ]; 
            
            pos = Position[Transpose[NeededParametersForRGEs][[1]],
                  LowScaleParameterOld[[i]]][[1,1]];
            
            LowScaleParameter = 
              Join[LowScaleParameter,
                Extract[NeededParametersForRGEs,pos][[2]]];
            
            LowScaleParameter=
              Complement[Intersection[LowScaleParameter],UnfixedCharges];
            i++;];
          ];
        
        
        HighScaleParameter = 
          DeleteCases[
              DeleteCases[DeleteCases[HighScaleParameter,gen1,3],gen2,3],gen3,
              3] /. a_[] \[Rule]a;
        
        HighScaleParameter = 
          Complement[Complement[HighScaleParameter,LowScaleParameter],
            UnfixedCharges];
        ];
      
      If[HighScaleParameter==={},
        AllRGEsRunning=True;,
        If[Complement[HighScaleParameter,ParametersToSolveTadpoles]==={},
            AllRGEsRunning=True;
            HighScaleParameter={};
            
            LowScaleParameter = 
              Join[LowScaleParameter,ParametersToSolveTadpoles];,
            AllRGEsRunning=False;
            ];
        ];
      
      
      
      
      ];


getInvolvedParameters[x_]:=Block[{i,temp,i1,i2},
      temp={};
      For[i=1,i\[LessEqual]Length[parameters],
        If[FreeQ[x,parameters[[i,1]]]\[Equal]False,
          temp = Join[temp,{parameters[[i,1]]}];
          ];
        i++;];
      Return[temp];
      ];


GenerateInformationForThresholds:=
    Block[{i,j,k,temp,sf,pos, gIndexNeeded,tempMasses, tempFinal,i1,i2},
      Print["Generate information for thresholds"];
      
      ThresholdInvolvedCouplings={};
      ThresholdParticles={};
      ThresholdCouplings={};
      ThresholdMasses={};
      
      For[i=1,i\[LessEqual]Length[Thresholds],
        temp={};
        tempMasses={};
        For[j=1,j\[LessEqual]Length[Thresholds[[i,2]]],
          If[Depth[Thresholds[[i,2,j]]]\[Equal]1,
            sf=Thresholds[[i,2,j]];
            gIndexNeeded=False;
            tempMasses=Join[tempMasses,{{sf,1,getGenSF[sf]}}];,
            sf=Thresholds[[i,2,j,0]];
            gIndexNeeded=True;
            gIndex = Thresholds[[i,2,j,1]];
            If[FreeQ[tempMasses,sf],
              
              tempMasses=
                  Join[tempMasses,{{sf,Thresholds[[i,2,j,1]],
                        Thresholds[[i,2,j,1]]}}];,
              pos = Position[tempMasses,sf][[1,1]];
              If[tempMasses[[pos,2]]>Thresholds[[i,2,j,1]],
                tempMasses[[pos,2]]=Thresholds[[i,2,j,1]];
                ];
              If[tempMasses[[pos,3]]<Thresholds[[i,2,j,1]],
                tempMasses[[pos,3]]=Thresholds[[i,2,j,1]];
                ];
              ];
            ];
          ThresholdParticles=Join[ThresholdParticles,{sf}];
          pos=Position[Transpose[SuperPotential][[2]],sf];
          AnalyzedPos={};
          For[k=1,k\[LessEqual]Length[pos],
            If[gIndexNeeded\[Equal]False,
              temp = Join[temp,{{SuperPotential[[pos[[k,1]],1,2]],ALL}}];
              
              temp = Join[
                  temp,{{getSoftBreaking[SuperPotential[[pos[[k,1]],1,2]]],
                      ALL}}];,
              
              temp = Join [
                  temp,{{SuperPotential[[pos[[k,1]],1,2]],
                      getPositionIndex[SuperPotential[[pos[[k,1]],2]],sf,
                        Count[AnalyzedPos,pos[[k,1]]]+1],
                      Length[getDimSPheno[SuperPotential[[pos[[k,1]],1,2]]]],
                      gIndex}}];
              
              temp = Join [
                  temp,{{getSoftBreaking[SuperPotential[[pos[[k,1]],1,2]]],
                      getPositionIndex[SuperPotential[[pos[[k,1]],2]],sf,
                        Count[AnalyzedPos,pos[[k,1]]]+1],
                      Length[getDimSPheno[SuperPotential[[pos[[k,1]],1,2]]]],
                      gIndex}}];
              ];
            AnalyzedPos=Join[AnalyzedPos,{pos[[k,1]]}];
            
            ThresholdCouplings = 
              Join[ThresholdCouplings,{SuperPotential[[pos[[k,1]],1,2]],
                  getSoftBreaking[SuperPotential[[pos[[k,1]],1,2]]]}];
            k++;];
          ThresholdCouplings = Join[ThresholdCouplings,{MassScalar[sf]}];
          If[gIndexNeeded\[Equal]False,
            temp = Join[temp,{{MassScalar[sf],ALL}}];,
            temp = Join [temp,{{MassScalar[sf],1,2,gIndex}}];
            temp = Join [temp,{{MassScalar[sf],2,2,gIndex}}];
            ];
          j++;];
        ThresholdInvolvedCouplings=Join[ThresholdInvolvedCouplings,{temp}];
        ThresholdMasses = Join[ThresholdMasses,{tempMasses}];
        i++;];
      ThresholdCouplings=Intersection[ThresholdCouplings];
      ThresholdParticles = Intersection[ThresholdParticles];
      
      BilinearSuperpotential = Cases[SuperPotential,{{a___},{b_,c_}}];
      NeededOtherFields={};
      
      tempFinal={};
      For[i=1,i\[LessEqual]Length[ThresholdMasses],
        temp={};
        For[j=1,j\[LessEqual]Length[ThresholdMasses[[i]]],
          pos = Position[BilinearSuperpotential,ThresholdMasses[[i,j,1]]];
          
          otherfield=
            DeleteCases[Extract[Extract[BilinearSuperpotential,pos[[1,1]]],2],
              ThresholdMasses[[i,j,1]]];
          If[otherfield==={},
            otherfield=NOTNEEDED;,
            otherfield=otherfield[[1]];
            ];
          
          If[FreeQ[ThresholdMasses,otherfield]\[Equal]True && 
              otherfield=!=NOTNEEDED,
            
            Print["ERROR in Thresholds: No Superpotential mass for ",
              ThresholdMasses[[i,j,1]]];
            Interrupt[];,
            If[FreeQ[temp,otherfield]\[Equal]True,
                
                temp = Join[
                    temp,{Join[
                        ThresholdMasses[[i,
                            j]],{Extract[BilinearSuperpotential[[pos[[1,1]]]],
                              1][[2]]}]}];
                If[ otherfield=!=NOTNEEDED,
                  
                  NeededOtherFields=
                      Join[NeededOtherFields,{{ThresholdMasses[[i,j,1]],
                            otherfield}}];
                  ];
                ];
            ];
          j++;];
        tempFinal = Join[tempFinal,{temp}];
        i++;];
      ThresholdMasses = tempFinal;
      
      ];

getPositionIndex[list_,particle_,app_]:=
    Block[{i,found,foundNr,IndexNr,index,i1,i2},
      found=False;
      IndexNr=1;
      index=1;
      foundNr=0;
      While[found\[Equal]False,
        If[list[[index]]===particle,
            foundNr++;
            If[foundNr\[Equal]app,
              found=True;,
              If[getGenSF[list[[index]]]>1,
                IndexNr++;
                ];
              index++;
              ];,
            If[getGenSF[list[[index]]]>1,
              IndexNr++;
              ];
            index++;
            ];
        ];
      Return[IndexNr];
      ];

CalculateIntermediateScale[nr_,readlists_]:=Block[{},
      inputfile=OpenWrite["SARAH-Intermediate.m"];
      $sarahMetaDir=
        ToFileName[{ToFileName[{$sarahModelDir,Modelname}],"Meta"}];
      outputfile = 
        ToFileName[$sarahMetaDir,"Output-Regime"<>ToString[nr]<>".m"];
      WriteString[inputfile,"<<"<>$sarahDir<>"/SARAH.m \n"];
      WriteString[inputfile,
        "Start[\""<>Modelname<>"\",\"Regime-"<>ToString[nr]<>"\" ] \n"];
      
      (* minSet=GenerateMinimalSetOfParameters[ListFormerParameters,nr];
        
        WriteString[inputfile,
          "MinimalParameterSetUp = "<>ToString[minSet] <>"; \n"]; *)
      
      WriteString[inputfile,
        "MakeSPheno[ReadLists->"<>ToString[readlists]<>"] \n"];
      WriteString[inputfile,"Exit \n"];
      Close[inputfile];
      
      Run["math < SARAH-Intermediate.m > "<> outputfile];
      
      Run["rm SARAH-Intermediate.m"];
      
      ListFormerParameters = minSet;
      
      ];


WriteMetaInformation[nr_,ES_]:=
    Block[{i,i1,i2,temp, RealParameters,pos, temp1,fac,field},
      $sarahMetaDir=
        ToFileName[{ToFileName[{$sarahModelDir,Modelname}],"Meta"}];
      metafile=
        OpenWrite[ToFileName[$sarahMetaDir,"Regime"<>ToString[nr]<>".m"]];
      WriteString[metafile,
        "HeavyFields = "<> ToString[HeavyFields]  <>"; \n \n"];
      WriteString[metafile,
        "numberLowCurrent = " <> ToString[numberLow] <>"; \n"];
      WriteString[metafile,
        "numberAllCurrent = " <> ToString[numberAll] <>"; \n \n"];
      WriteString[metafile,
        "numberAllwithVEVsCurrent = " <> ToString[numberAllwithVEVs] <>
          "; \n \n"];
      WriteString[metafile,
        "YukawaCouplingsCurrent = " <> ToString[Transpose[BetaYijk][[1]]] <>
          "; \n \n"];
      
      WriteString[metafile, 
        "listAll = "<> ToString[listAllParameters]<> "; \n \n"];
      WriteString[metafile, 
        "listAllwithVEVs = "<> ToString[listAllParametersAndVEVs]<> 
          "; \n \n"];
      WriteString[metafile, 
        "listLow = "<> ToString[lowScaleNames]<> "; \n \n"];
      WriteString[metafile, 
        "listVEVsCurrent = "<> ToString[listVEVs]<> "; \n \n"];
      WriteString[metafile, 
        "listGaugeCurrent = "<> ToString[
            Table[Gauge[[i,4]],{i,1,AnzahlGauge}]]<> "; \n \n"];
      WriteString[metafile, 
        "listGauginosCurrent = "<> ToString[
            Table[MassGauge[i],{i,1,AnzahlGauge}]]<> "; \n \n"];
      
      WriteString[metafile, 
        "LHnamesCurrent = "<> ToString[SA`LHList]<> "; \n \n"];
      WriteString[metafile, 
        "ParametersToSolveTadpolesCurrent = "<> ToString[
            ParametersToSolveTadpoles]<> "; \n \n"];
      
      
      temp ={};
      RealParameters={};
      
      For[i=1,i\[LessEqual]Length[listAllParametersAndVEVs],
        temp = 
          Join[temp,{{listAllParametersAndVEVs[[i]],
                getDimSPheno[listAllParametersAndVEVs[[i]]]}}];
        If[FreeQ[realVar,listAllParametersAndVEVs[[i]]]\[Equal]False,
          
          RealParameters = 
              Join[RealParameters,{listAllParametersAndVEVs[[i]]}];
          ];
        i++;];
      
      For[i=1,i\[LessEqual]Length[U1MixingParameters],
        temp = 
          Join[temp,{{U1MixingParameters[[i]],
                getDimSPheno[U1MixingParameters[[i]]]}}];
        If[FreeQ[realVar,U1MixingParameters[[i]]]\[Equal]False,
          RealParameters = Join[RealParameters,{U1MixingParameters[[i]]}];
          ];
        i++;];
      
      WriteString[metafile, "DimParameters = "<> ToString[temp] <>"; \n \n"];
      WriteString[metafile, 
        "RealParameters = "<> ToString[RealParameters] <>"; \n \n"];
      
      
      temp={};
      For[i=1,i\[LessEqual]Length[HeavyFields],
        temp = 
          Join[temp,{{HeavyFields[[i]],getStartHeavy[HeavyFields[[i]]],
                getGenSPheno[HeavyFields[[i]]]}}];
        i++;];
      
      WriteString[metafile, 
        "GenHeavyFields = "<> ToString[temp] <>"; \n \n"];
      
      WriteString[metafile, "eigenstateName = "<> ToString[ES] <>"; \n \n"];
      
      temp = {};
      
      For[i=1,i\[LessEqual]Length[listAllParametersAndVEVs],
        temp = 
          Join[temp,{{listAllParametersAndVEVs[[i]],
                SPhenoForm[listAllParametersAndVEVs[[i]]]}}];
        i++;];
      
      WriteString[metafile, "FortranNames = "<> ToString[temp] <>"; \n \n"];
      
      For[i=1,i\[LessEqual]Length[HeavyFields],
        For[i2=1,i2\[LessEqual]Length[NextGauge],
          mul=1;
          For[i1=1,i1\[LessEqual]Length[NextGauge],
            If[NextGauge[[i1]]=!=U[1] && i1=!=i2,
              mul=mul*Abs[NextQN[[i,i1+1]]];
              ];
            i1++;];
          MultiplicityFactorNext[i2,i]=mul;
          i2++;];
        i++;];
      
      
      temp={};
      For[i=1,i\[LessEqual]Length[HeavyFields],
        field=HeavyFields[[i]] /. A_[b_]\[Rule]A;
        pos = Position[NextQN,field][[1,1]];
        temp1={};
        If[AntiField[field]===field,
          fac=1/8;,fac=1/4;
          ];
        If[getType[field]===F,fac=2 fac ];
        For[i1=1,i1\[LessEqual]Length[NextGauge],
          If[NextGauge[[i1]]===U[1],
            
            temp1=Join[
                  temp1,{NextQN[[pos,i1+1]]^2*
                      MultiplicityFactorNext[i1,pos] fac}];,
            If[NextQN[[pos,i1+1]]===1,
                temp1=Join[temp1,{0}];,
                
                temp1=Join[
                      temp1,{TestDim[NextQN[[pos,i1+1]],
                              NextGauge[[i1,1]]][[5]]*
                          MultiplicityFactorNext[i1,pos] fac}];
                ];
            ];
          i1++;];
        temp =Join[temp,{temp1}];
        i++;];
      
      WriteString[metafile, 
        "HeavyFieldFactors = "<> ToString[InputForm[temp]] <>"; \n \n"];
      
      
      Close[metafile];
      
      ];

ReadInformationOtherRegimes[nr_]:=Block[{i,temp,i1,i2},
      $sarahMetaDir=
        ToFileName[{ToFileName[{$sarahModelDir,Modelname}],"Meta"}];
      metafile=ToFileName[$sarahMetaDir,"Regime"<>ToString[nr]<>".m"];
      
      Get[metafile];
      
      
      DimensionsOtherRegimes[[nr]] = DimParameters;
      GenerationsOfHeavyFieldsAllRegimes[[nr]] = GenHeavyFields;
      LowScaleParametersAllRegimes[[nr]]= listLow;
      HighScaleParametersAllRegimes[[nr]]= listAll;
      HighScaleParametersAllwithVEVsRegimes[[nr]]= listAllwithVEVs;
      NumberLowAllRegimes[[nr]]= numberLowCurrent;
      NumberHighAllRegimes[[nr]]= numberAllCurrent;
      NumberAllwithVEVsAllRegimes[[nr]]= numberAllwithVEVsCurrent;
      ListOfRegimeEigenstates[[nr]] = eigenstateName;
      ListVEVsAllRegimes[[nr]] = listVEVsCurrent;
      LHnamesAllRegimes[[nr]] = LHnamesCurrent;
      
      ParametersToSolveTadpolesAllRegimes[[nr]]=
        ParametersToSolveTadpolesCurrent;
      
      
      YukawaCouplingsAllRegimes[[nr]] = YukawaCouplingsCurrent;
      
      For[i=1,i\[LessEqual]Length[listGaugeCurrent],
        If[FreeQ[GaugeCouplingsAllRegimes[[nr]], listGaugeCurrent[[i]]],
          
          GaugeCouplingsAllRegimes[[nr]] =
              Join[GaugeCouplingsAllRegimes[[nr]],{ listGaugeCurrent[[i]]}];
          ];
        i++;];
      For[i=1,i\[LessEqual]Length[listGauginosCurrent],
        If[FreeQ[GauginosAllRegimes[[nr]], listGauginosCurrent[[i]]],
          
          GauginosAllRegimes[[nr]] =
              Join[GauginosAllRegimes[[nr]],{ listGauginosCurrent[[i]]}];
          ];
        i++;];
      GroupFactorHeavyFields[[nr]] =HeavyFieldFactors;
       
      SA`LHList = Join[SA`LHList,LHnamesCurrent];
      
      realVar = Join[realVar,RealParameters];
      
      For[i=1,i\[LessEqual]Length[FortranNames],
        If[
          FreeQ[parameters,FortranNames[[i,1]]] &&  
            FreeQ[ListOfAdditionalParameters,FortranNames[[i,1]]],
          
          ListOfAdditionalParameters = 
              Join[ListOfAdditionalParameters,{FortranNames[[i]]}];
          ];
        i++;];
      
      ParameterDefinitionsSave=ParameterDefinitions;
      ParameterFile=
        ToFileName[{ToFileName[{ToFileName[{$sarahModelDir,Modelname}],
                "Regime-"<>ToString[nr]}]},"parameters.m"];
      Get[ParameterFile];
      ParameterDefinitions=
        Join[ParameterDefinitionsSave,ParameterDefinitions];
      CreateParameterFile;
      
      
      ];

GenerateMinimalSetOfParameters[startlist_,nr_]:=Block[{temp,i,j,i1,i2},
      temp={};
      For[i=1,i\[LessEqual]Length[startlist],
        If[FreeQ[BoundaryConditionsUp[[nr]],startlist[[i]]],
          temp = Join[temp,{startlist[[i]]}];,
          pos=Position[BoundaryConditionsUp[[nr]],startlist[[i]]];
          For[j=1,j\[LessEqual]Length[pos],
            
            temp = Join[
                temp,{Extract[BoundaryConditionsUp[[nr]],pos[[j,1]]][[1]]}];
            j++;];
          ];
        i++;];
      Return[temp];
      ];


CreateHiggs2Loop :=Block[{i1,i2},
      sphenoHiggs2Loop=
        OpenWrite[
          ToFileName[$sarahCurrentSPhenoDir,"TwoLoopHiggsMass_SARAH.f90"]];
      AppendSourceCode["TwoLoopHiggsMass.f90",sphenoHiggs2Loop];
      Close[sphenoHiggs2Loop]
      ];



CheckDefinitionParameters:=Block[{i,j,k,temp, down, up, pRunningDown},
      If[IntermediateScale =!= True && Head[RegimeNr] =!= Integer,
          If[SeveralBoundaryConditions\[Equal]True,
              For[k=1,k\[LessEqual]Length[BoundaryHighScale],
                  
                  temp=Select[
                      HighScaleParameter,(MemberQ[
                              TransposeChecked[
                                  BoundaryHighScale[[k]]][[1]],#]\[Equal]\
False)&];
                  For[i=1,i\[LessEqual]Length[temp],
                    If[MemberQ[ParametersToSolveTadpoles,temp[[i]]],
                      
                      BoundaryHighScale[[k]] = 
                          Join[BoundaryHighScale[[k]],{{temp[[i]],0}}];,
                      Message[SPheno::NoBoundaryGUT,temp[[i]]];
                      ];
                    i++;];
                  
                  
                  temp=Select[
                      LowScaleParameter,(MemberQ[
                                TransposeChecked[
                                    BoundaryHighScale[[k]]][[1]],#]\[Equal]\
False && MemberQ[TransposeChecked[
                                    BoundaryEWSBScale[[k]]][[1]],#]\[Equal]\
False && MemberQ[TransposeChecked[
                                    BoundarySUSYScale[[k]]][[1]],#]\[Equal]\
False)&];
                  
                  temp=Select[
                      temp,(FreeQ[{UpYukawa,DownYukawa,ElectronYukawa,
                              hyperchargeCoupling,leftCoupling,
                              strongCoupling},#])&];
                  For[i=1,i\[LessEqual]Length[temp],
                    
                    If[MemberQ[ParametersToSolveTadpoles,temp[[i]]]\[Equal]
                        False,
                      Message[SPheno::NoConditionForParameter,temp[[i]]];
                      ];
                    i++;];
                  
                  k++;];,
              
              If[ImplementThresholds,
                
                down = Table[
                        TransposeChecked[BoundaryConditionsDown[[i]]][[1]],{i,
                          1,Length[BoundaryConditionsDown]}][[1]] /. {a_[
                          index1,b___]\[Rule]a};
                
                up = Table[
                        TransposeChecked[BoundaryConditionsUp[[i]]][[1]],{i,1,
                          Length[BoundaryConditionsUp]}][[1]]/. {a_[index1,
                          b___]\[Rule]a};
                ];
              
              
              temp=Select[
                  HighScaleParameter,(MemberQ[
                          Transpose[
                              BoundaryHighScale][[1]],#]\[Equal]False)&];
              For[i=1,i\[LessEqual]Length[temp],
                If[MemberQ[ParametersToSolveTadpoles,temp[[i]]],
                  
                  BoundaryHighScale = 
                      Join[BoundaryHighScale,{{temp[[i]],0}}];,
                  If[MemberQ[down,temp[[i]]],
                      
                      BoundaryHighScale = 
                          Join[BoundaryHighScale,{{temp[[i]],0}}];,
                      Message[SPheno::NoBoundaryGUT,temp[[i]]];
                      ];
                  ];
                i++;];
              
              
              temp=Select[
                  LowScaleParameter,(MemberQ[
                            Transpose[
                                BoundaryHighScale][[1]],#]\[Equal]False && 
                        MemberQ[
                            Transpose[
                                BoundaryEWSBScale][[1]],#]\[Equal]False && 
                        MemberQ[
                            Transpose[
                                BoundarySUSYScale][[1]],#]\[Equal]False && 
                        MemberQ[down,#]\[Equal]False && 
                        MemberQ[up,#]\[Equal]False)&];
              
              temp=Select[
                  temp,(FreeQ[{UpYukawa,DownYukawa,ElectronYukawa,
                          hyperchargeCoupling,leftCoupling,
                          strongCoupling},#])&];
              For[i=1,i\[LessEqual]Length[temp],
                If[MemberQ[ParametersToSolveTadpoles,temp[[i]]]\[Equal]False,
                  Message[SPheno::NoConditionForParameter,temp[[i]]];
                  ];
                i++;];
              ];,
          
          If[IntermediateScale=!=True,
              
              down = Flatten[
                    Table[TransposeChecked[
                          BoundaryConditionsDown[[i]]][[1]],{i,1,
                        Length[BoundaryConditionsUp]}]]/. {a_[index1,
                        b___]\[Rule]a};
              
              up =Flatten[
                    Table[TransposeChecked[BoundaryConditionsUp[[i]]][[1]],{i,
                        1,Length[BoundaryConditionsUp]}]]/. {a_[index1,
                        b___]\[Rule]a};
              
              
              pRunningDown=
                Table[Complement[HighScaleParametersAllRegimes[[i]],
                    LowScaleParametersAllRegimes[[i]]],{i,1,
                    Length[LowScaleParametersAllRegimes]}];
              
              For[i=1,i\[LessEqual]Length[pRunningDown],
                If[i\[Equal]1,
                  
                  temp = Select[
                        pRunningDown[[i]],(MemberQ[
                                  TransposeChecked[
                                      BoundaryHighScale][[1]],#]\[Equal]
                                False && 
                              MemberQ[(TransposeChecked[
                                        BoundaryConditionsDown[[i]]][[1]]/. \
{a_[index1,b___]\[Rule]a}),#]\[Equal]False ) &];,
                  
                  temp = Select[
                        pRunningDown[[i]],(MemberQ[
                                  Flatten[
                                    Table[
                                      pRunningDown[[j]],{j,1,
                                        i-1}]],#]\[Equal]False &&
                              MemberQ[(TransposeChecked[
                                        BoundaryConditionsDown[[i-1]]][[1]]/. \
{a_[index1,b___]\[Rule]a}),#]\[Equal]False)&];
                  ];
                For[j=1,j\[LessEqual]Length[temp],
                  
                  If[MemberQ[Flatten[ParametersToSolveTadpolesAllRegimes],
                        temp[[j]]]\[Equal]False,
                    Message[SPheno::NoConditionForParameter,temp[[j]]];
                    ];
                  j++;];
                i++;];
              
              For[i=1,i\[LessEqual]Length[LowScaleParametersAllRegimes],
                
                temp = Select[
                    LowScaleParametersAllRegimes[[i]],(MemberQ[
                              up,#]\[Equal]False && 
                          MemberQ[
                              TransposeChecked[
                                  BoundaryHighScale][[1]],#]\[Equal]False && 
                          MemberQ[
                              TransposeChecked[
                                  BoundarySUSYScale][[1]],#]\[Equal]False && 
                          MemberQ[
                              TransposeChecked[
                                  BoundaryEWSBScale][[1]],#]\[Equal]False && 
                          MemberQ[down,#]\[Equal]False)&];
                
                temp=Select[
                    temp,(FreeQ[{UpYukawa,DownYukawa,ElectronYukawa,
                            hyperchargeCoupling,leftCoupling,
                            strongCoupling},#])&];
                For[j=1,j\[LessEqual]Length[temp],
                  
                  If[MemberQ[Flatten[ParametersToSolveTadpolesAllRegimes],
                        temp[[j]]]\[Equal]False,
                    Message[SPheno::NoConditionForParameter,temp[[j]]];
                    ];
                  j++;];
                i++;];
              
              ];
          ];
      
      ];
