(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)

MakeDecayLists3Body[particle_,file_]:=Block[{i,temp, channels,addedDecays},
      
      Print["Decay of ", particle];
      
      temp2=ThreeBodyDecay[particle];
      
      (* temp2={{temp2[[1]][[7]]},{temp2[[2]][[7]]}};  *)
      
      If[getGenSPheno[particle]>1,
        temp=temp2[[2]];,
        temp={};
        For[i=1,i\[LessEqual]Length[temp2[[2]]],
          If[FreeQ[temp2[[2,i,1]],particle]\[Equal]True,
            temp = Join[temp,{temp2[[2,i]]}];
            ];
          i++;];
        ];
      
      If[AntiField[particle]===particle,
        temp2 = temp;
        temp = {};
        addedDecays={};
        For[i=1,i\[LessEqual]Length[temp2],
          
          If[FreeQ[addedDecays,temp2[[i,1]]/. FinalStates\[Rule]C] && 
              FreeQ[addedDecays,
                AntiField/@(temp2[[i,1]]/. FinalStates\[Rule]C)],
            temp=Join[temp,{temp2[[i]]}];
            
            addedDecays=
              Join[addedDecays,{temp2[[i,1]]/. FinalStates\[Rule]C}];
            ];
          i++;];
        ];
      
      NeededMasses=Table[{},{Length[temp]}];
      NeededWidths=Table[{},{Length[temp]}];
      NeededWidthsTemp=Table[{},{Length[temp]}];
      NeededCouplings=Table[{},{Length[temp]}];
      NeededCouplingsAll=Table[{},{Length[temp]}];
      NeededCouplingsInsert=Table[{},{Length[temp]}];
      NeededIntegrals=Table[{},{Length[temp]}];
      
      For[i=1,i\[LessEqual]Length[temp],
        For[j=2,j\[LessEqual]Length[temp[[i]]],
          
          If[FreeQ[NeededMasses[[i]], SPhenoMass[Final1/.temp[[i,j]]]]\[Equal]
                True  && FreeQ[massless,getBlank[Final1/.temp[[i,j]]]]\[Equal]
                True,
            
            NeededMasses[[i]] = 
                Join[NeededMasses[[i]],{SPhenoMass[Final1/.temp[[i,j]]]}];
            ];
          
          
          If[FreeQ[NeededMasses[[i]], SPhenoMass[Final2/.temp[[i,j]]]]\[Equal]
                True && FreeQ[massless,getBlank[Final2/.temp[[i,j]]]]\[Equal]
                True,
            
            NeededMasses[[i]] = 
                Join[NeededMasses[[i]],{SPhenoMass[Final2/.temp[[i,j]]]}];
            ];
          
          
          If[FreeQ[NeededMasses[[i]], SPhenoMass[Final3/.temp[[i,j]]]]\[Equal]
                True && FreeQ[massless,
                  getBlank[Final3/.temp[[i,j]]]]\[Equal]True, 
            
            NeededMasses[[i]] = 
                Join[NeededMasses[[i]],{SPhenoMass[Final3/.temp[[i,j]]]}];
            ];
          
          
          If[FreeQ[NeededMasses[[i]], 
                  SPhenoMass[Propagator/.temp[[i,j]]]]\[Equal]True && 
              FreeQ[massless,getBlank[Propagator/.temp[[i,j]]]]\[Equal]True,
            
            NeededMasses[[i]] = 
                Join[NeededMasses[[i]],{SPhenoMass[
                      Propagator/.temp[[i,j]]]}];
            ];
          
          
          If[FreeQ[NeededWidths[[i]], 
                  SPhenoWidth[Propagator/.temp[[i,j]]]]\[Equal]True && 
              FreeQ[massless,getBlank[Propagator/.temp[[i,j]]]]\[Equal]True,
            
            NeededWidths[[i]] = 
              Join[NeededWidths[[i]],{SPhenoWidth[Propagator/.temp[[i,j]]]}];
            
            NeededWidthsTemp[[i]] = 
              Join[NeededWidthsTemp[[i]],{ToExpression[
                    ToString[SPhenoWidth[Propagator/.temp[[i,j]]]]<>
                      "temp"]}];
            ];
          
          
          If[FreeQ[
                NeededCouplingsInsert[[i]], (Couplings /. 
                      temp[[i,j]])[[1]]]\[Equal]True,
            
            NeededCouplingsInsert[[i]]=
              Join[NeededCouplingsInsert[[i]],{{(Couplings /. 
                          temp[[i,j]])[[1]]}}];
            
            NeededCouplings[[i]]=
              Join[NeededCouplings[[i]],{getSPhenoCoupling[(Couplings /. 
                            temp[[i,j]])[[1]]][[1]]}];
            ];
          
          
          NeededCouplingsAll[[i]]=
            Join[NeededCouplingsAll[[i]],{getSPhenoCoupling[(Couplings /. 
                        temp[[i,j]])[[1]]]}];
          
          
          If[FreeQ[
                NeededCouplingsInsert[[i]], (Couplings /. 
                      temp[[i,j]])[[2]]]\[Equal]True,
            
            NeededCouplingsInsert[[i]]=
              Join[NeededCouplingsInsert[[i]],{{(Couplings /. 
                          temp[[i,j]])[[2]]}}];
            
            NeededCouplings[[i]]=
              Join[NeededCouplings[[i]],{getSPhenoCoupling[(Couplings /. 
                            temp[[i,j]])[[2]]][[1]]}];
            ];
          
          
          NeededCouplingsAll[[i]]=
            Join[NeededCouplingsAll[[i]],{getSPhenoCoupling[(Couplings /. 
                        temp[[i,j]])[[2]]]}];
          
          j++;];
        
        If[FreeQ[NeededMasses[[i]],SPhenoMass[particle]]\[Equal]True,
          NeededMasses[[i]] = 
              Join[NeededMasses[[i]],{SPhenoMass[particle]}];];
        
        
        NeededIntegrals[[i]]=
          Intersection[MakeListNeededIntegrals[temp[[i]]]];
        NeededCouplings[[i]] = Intersection[NeededCouplings[[i]]];
        i++;];
      
      
      NeededMassesComplete=Intersection[Flatten[NeededMasses]];
      NeededWidthsComplete=Intersection[Flatten[NeededWidths]];
      NeededCouplingsComplete=Intersection[Flatten[NeededCouplings]];
      
      SPhenoThreeBody=OpenWrite[ToFileName[$sarahCurrentSPhenoDir,file]];
      
      
      WriteString[SPhenoThreeBody,
        "Module "<>ToString[particle]<>"3Decays_"<>ModelName<>" \n \n"];
      WriteString[SPhenoThreeBody,"Use Control \n"];
      WriteString[SPhenoThreeBody,"Use ThreeBodyPhaseSpace \n \n"];
      WriteString[SPhenoThreeBody,"Contains \n \n"];
      
      channels=0;
      
      DecayWidth3B={};
      DecayWidth3BI={};
      
      For[i=1,i\[LessEqual]Length[NeededMasses],
        finalStates=getBlank[List@@temp[[i,1]]];
        nameWidth=
          ToExpression[
            "g"<>ToString[particle]<>SPhenoShortName[finalStates[[1]]]<>
              SPhenoShortName[finalStates[[2]]]<>
              SPhenoShortName[finalStates[[3]]]];
        nameWidthI=
          ToExpression[
            "g"<>ToString[particle]<>SPhenoShortName[finalStates[[1]]]<>
              SPhenoShortName[finalStates[[2]]]<>
              SPhenoShortName[finalStates[[3]]]<>"i"];
        SPhenoParameters=
          Join[SPhenoParameters,{{nameWidth,{generation,generation,generation,
                  generation},{getGenSPheno[particle],
                  getGenSPheno[finalStates[[1]]],
                  getGenSPheno[finalStates[[2]]],
                  getGenSPheno[finalStates[[3]]]}}}];
        SPhenoParameters=
          Join[SPhenoParameters,{{nameWidthI,{generation,generation,
                  generation},{getGenSPheno[finalStates[[1]]],
                  getGenSPheno[finalStates[[2]]],
                  getGenSPheno[finalStates[[3]]]}}}];
        
        channels +=
          getGenSPheno[finalStates[[1]]]*getGenSPheno[finalStates[[2]]]*
            getGenSPheno[finalStates[[3]]];
        
        DecayWidth3B = Join[DecayWidth3B,{nameWidth}];
        DecayWidth3BI = Join[DecayWidth3BI,{nameWidthI}];
        realVar=Join[realVar,{nameWidth,nameWidthI}];
        All3BodyWidths = Join[All3BodyWidths,{nameWidth}];
        i++;];
      
      
       WriteThreeBodyDecayTotal[particle,NeededMassesComplete,
        NeededCouplingsComplete,NeededIntegralsComplete,NeededWidthsComplete,
        DecayWidth3B,DecayWidth3BI,NeededCouplings,NeededMasses, 
        NeededIntegrals,NeededWidthsTemp,temp,SPhenoThreeBody];
      
      savedDecayInfos3Body=
        Join[savedDecayInfos3Body,{{particle,NeededMassesComplete,
              NeededCouplingsComplete,NeededWidthsComplete,DecayWidth3B,
              temp}}];
      
      
      If[FreeQ[SPhenoParameters,SPhenoWidth[particle]]\[Equal]True,
        SPhenoParameters= 
          Join[SPhenoParameters,{{ToExpression[
                  "gP"<>ToString[particle]],{generation,
                  generation},{getGenSPheno[particle],channels}}}];
        SPhenoParameters= 
          Join[SPhenoParameters,{{ToExpression[
                  "gT"<>ToString[particle]],{generation},{getGenSPheno[
                    particle]}}}];
        SPhenoParameters = 
          Join[SPhenoParameters,{{ToExpression[
                  "BR"<>ToString[particle]],{generation,
                  generation},{getGenSPheno[particle],channels}}}];,
        
        
        pos=
          Position[SPhenoParameters,
              ToExpression["gP"<>ToString[particle]]][[1,1]];
        oldLength = SPhenoParameters[[pos,3,2]];
        BR2and3 = Join[BR2and3,{{particle,oldLength,oldLength+channels}}];
        SPhenoParameters[[pos,3,2]]= SPhenoParameters[[pos,3,2]] + channels;
        pos=
          Position[SPhenoParameters,
              ToExpression["BR"<>ToString[particle]]][[1,1]];
        SPhenoParameters[[pos,3,2]]= SPhenoParameters[[pos,3,2]] + channels;
        
        
        ];
      
      For[i=1,i\[LessEqual]Length[NeededCouplings],
         WriteThreeBodyDecay[particle,Map[getBlank,List@@temp[[i,1]]],
          Delete[temp[[i]],1],NeededMasses[[i]],NeededCouplings[[i]],
          NeededCouplingsAll[[i]],NeededIntegrals[[i]],NeededWidths[[i]],
          SPhenoThreeBody];
        i++;];  
      
      WriteString[SPhenoThreeBody,
        "End Module "<>ToString[particle]<>"3Decays_"<>ModelName<>" \n \n"];
      Close[SPhenoThreeBody];
      
      ];

MakeListNeededIntegrals[list_]:=Block[{i,j,tempList,name,name2,temp},
      tempList={};
      For[i=2,i\[LessEqual]Length[list],
        temp =getIntegralDiagonal[list[[i]]];
        tempList=
          Join[tempList,{{SPhenoIntName[temp],SPhenoIntNr1[temp],
                SPhenoIntNr2[temp],SPhenoIntNameN[temp]}}];
        For[j=i,j\[LessEqual]Length[list],
          
          temp =getIntegralOffDiagonal[list[[i]],list[[j]], 
              Final1 /. list[[i]], Final1 /. list[[j]]];
          
          tempList=
            Join[tempList,{{SPhenoIntName[temp],SPhenoIntNr1[temp],
                  SPhenoIntNr2[temp],SPhenoIntNameN[temp]}}];
          
          
          If[(Final1 /. list[[i]]) === (Final2 /. list[[i]]) || (Final1 /. 
                    list[[i]]) === (Final3 /. list[[i]]), 
            
            temp =getIntegralOffDiagonal[list[[i]],list[[j]], 
                One[Final1 /. list[[i]]], Final2 /. list[[j]]];
            
            tempList=
              Join[tempList,{{SPhenoIntName[temp],SPhenoIntNr1[temp],
                    SPhenoIntNr2[temp],SPhenoIntNameN[temp]}}];,
            
            If[(Final1 /. list[[j]]) === (Final2 /. list[[j]]) || (Final1 /. 
                        list[[j]]) === (Final3 /. list[[j]]), 
                
                temp =getIntegralOffDiagonal[list[[i]],list[[j]], 
                    One[Final1 /. list[[i]]], Final2 /. list[[j]]];
                
                tempList=
                  Join[tempList,{{SPhenoIntName[temp],SPhenoIntNr1[temp],
                        SPhenoIntNr2[temp],SPhenoIntNameN[temp]}}];
                ];
            ];
          
          
          j++;];
        i++;];
      Return[tempList];
      ];



getIntegralDiagonal[process_]:=Block[{temp},
      If[getType[Propagator /. process]===V,
          Return[Vs];,
          Return[Ss];
          ];
      ]; 


getIntegralOffDiagonal[process1_, process2_,f1a_, f1b_]:=
    Block[{temp,channel},
      type1=getType[Propagator /. process1];
      type2=getType[Propagator /. process2];
      
      prop1=Propagator /. process1;
      prop2=Propagator /. process2;
      
      If[f1a===f1b,channel="ss";,channel="st";];
      
      If[type1===S && type2===V,
        type1t=type2;type2=type1; type1=type1t;
        ]; 
      
      Return[ToExpression[ToString[type1]<>ToString[type2]<>channel]]; 
      
      ];

MakeListPhaseSpaceIntegrals[Vector1_,Scalar1_,SchannelV_,STchannelV_,
      SchannelS_,SSchannelVS_,STchannelVS_]:=Block[{name,name2,i},
      
      ListDiagonal={{Vs,Vector1,SchannelV},{Vst,Vector1,STchannelV},{Ss,
            Scalar1,SchannelS}};
      
      ListOffDiagonal={{VVst,Vector1,STchannelV},{VVss,Scalar1,
            SSchannelVS},{VSss,Scalar1,SSchannelVS},{VSst,Scalar1,
            STchannelVS},
          {SSss,Scalar1,SSchannelVS},{SSst,Scalar1,STchannelVS}};
      
      
      realVar = Join[realVar,{IntegralVVss}];
      
      For[i=1,i\[LessEqual]Length[ListDiagonal],
        name=ToExpression["Integral"<>ToString[ListDiagonal[[i,1]]]];
        name2=ToExpression["N"<>ToString[ListDiagonal[[i,1]]]];
        
        SPhenoIntName[ListDiagonal[[i,1]]]=name;
        SPhenoIntNameN[ListDiagonal[[i,1]]]=name2;
        SPhenoIntNr1[ListDiagonal[[i,1]]]=ListDiagonal[[i,2]];
        SPhenoIntNr2[ListDiagonal[[i,1]]]=ListDiagonal[[i,3]];
        
        SPhenoParameters=
          Join[SPhenoParameters,{{name,{generation,
                  generation},{ListDiagonal[[i,2]],ListDiagonal[[i,3]]}}}];
        SPhenoParameters=Join[SPhenoParameters,{{name2,{},{}}}];
        NeededIntegralsComplete= 
          Join[NeededIntegralsComplete,{{name,ListDiagonal[[i,2]],
                ListDiagonal[[i,3]],name2}}];
        realVar=Join[realVar,{name}];
        i++;
        ];
      
      For[i=1,i\[LessEqual]Length[ListOffDiagonal],
        name=ToExpression["Integral"<>ToString[ListOffDiagonal[[i,1]]]];
        name2=ToExpression["N"<>ToString[ListOffDiagonal[[i,1]]]];
        SPhenoParameters=
          Join[SPhenoParameters,{{name,{generation,
                  generation},{ListOffDiagonal[[i,2]],
                  ListOffDiagonal[[i,3]]}}}];
        SPhenoParameters=Join[SPhenoParameters,{{name2,{},{}}}];
        
        SPhenoIntName[ListOffDiagonal[[i,1]]]=name;
        SPhenoIntNameN[ListOffDiagonal[[i,1]]]=name2;
        SPhenoIntNr1[ListOffDiagonal[[i,1]]]=ListOffDiagonal[[i,2]];
        SPhenoIntNr2[ListOffDiagonal[[i,1]]]=ListOffDiagonal[[i,3]];
        
        
        NeededIntegralsComplete= 
          Join[NeededIntegralsComplete,{{name,ListOffDiagonal[[i,2]],
                ListOffDiagonal[[i,3]],name2}}];
        i++;
        ];
      
      ];



 WriteThreeBodyDecayTotal[particle_,masses_,couplings_,integrals_,
      neededwidths_,widths_,widthsI_,detailcouplings_,detailmasses_,
      detailintegrals_,detailwidths_,processes_,file_]:=Block[{i,tempString},
      
      MakeSubroutineTitle[ToString[particle]<>"ThreeBodyDecay",
        Flatten[{masses,couplings,neededwidths,widths}],{"n_in"},{"epsI", "deltaM",
          "CheckRealStates","gT","gP","BR"},file];
      
      WriteString[file,"Implicit None \n \n"];
      
      MakeVariableList[masses,",Intent(in)",file];
      MakeVariableList[couplings,",Intent(in)",file];
      MakeVariableList[widths,",Intent(inout)",file];
      MakeVariableList[neededwidths,",Intent(in)",file];
      MakeVariableList[widthsI,"",file];
      
      
      tempString="";
      For[i=1,i\[LessEqual]Length[neededwidths],
        If[getDimSPheno[neededwidths[[i]]]=!={},
          
          tempString=
              tempString <>ToString[neededwidths[[i]]]<>"temp("<>
                ToString[getDimSPheno[neededwidths[[i]]][[1]]] <>"),";,
          tempString=tempString <>ToString[neededwidths[[i]]]<>"temp,";
          ];
        i++;];
      tempString=StringDrop[tempString,-1];
      WriteString[file,"Real(dp) :: "<> FortranLineBreak[tempString]<>"\n"]; 
      
      tempString="";
      tempStringIntR="";
      tempStringIntC="";
      For[i=1,i\[LessEqual]Length[integrals],
        tempString=tempString <> ToString[integrals[[i,4]]]<>",";
        If[FreeQ[realVar,integrals[[i,1]]]\[Equal]False,
          
          tempStringIntR=
              tempStringIntR <> ToString[integrals[[i,1]]]<>"(:,:),";,
          
          tempStringIntC=
              tempStringIntC <> ToString[integrals[[i,1]]]<>"(:,:),";
          ];
        i++;];
       tempString=StringDrop[tempString,-1];
       tempStringIntR=StringDrop[tempStringIntR,-1];
      tempStringIntC=StringDrop[tempStringIntC,-1];
      WriteString[file,"Integer :: "<> FortranLineBreak[tempString]<>"\n"]; 
      WriteString[file,
        "Complex(dp), Allocatable :: "<> FortranLineBreak[tempStringIntC]<>
          "\n"]; 
      WriteString[file,
        "Real(dp), Allocatable :: "<> FortranLineBreak[tempStringIntR]<>
          "\n"]; 
      
      WriteString[file,
        "Real(dp), Intent(inout), Optional :: BR(:,:), gP(:,:) \n"];
      If[getGenSPheno[particle]>1,
        WriteString[file,"Real(dp), Intent(inout) :: gT(:) \n"];,
        WriteString[file,"Real(dp), Intent(inout) :: gT \n"];
        ];
      
      WriteString[file,"Integer, Intent(in) :: n_in \n"];
      WriteString[file,"Real(dp), Intent(in) :: epsI, deltaM \n"];
      WriteString[file, "Logical, Intent(in) ::  CheckRealStates \n"];
      WriteString[file,
        "Integer :: i_start, i_end, i_run, n_out, n_length, gt1, gt2, gt3, i1 \n"]\
;
      WriteString[file, "Logical :: check \n"];
      
      WriteString[file, "Iname = Iname +1 \n"];
      WriteString[file, 
        "NameOfUnit(Iname) = '"<>ToString[particle]<>
          "ThreeBodyDecay' \n \n"];
      
      
      For[i=1,i\[LessEqual]Length[integrals],
        WriteString[file, 
          "Allocate( "<>ToString[integrals[[i,1]]] <>"("<>
            ToString[integrals[[i,2]]]<>","<>ToString[integrals[[i,3]]]<>
            ") ) \n"];
        i++;];
      
      WriteString[file, "\n \n"];
      
      
      
      WriteString[file,"If (CheckRealStates) Then \n"];
      For[i=1,i\[LessEqual]Length[neededwidths],
        WriteString[file, ToString[neededwidths[[i]]]<> "temp = 0._dp \n"];
        i++;];
      WriteString[file, "Else \n"];
      For[i=1,i\[LessEqual]Length[neededwidths],
        WriteString[file, 
          ToString[neededwidths[[i]]]<> "temp = "<>
            ToString[neededwidths[[i]]]<>" \n"];
        i++;];
      WriteString[file, "End If \n \n"];
      WriteString[file, "check=CheckRealStates \n"];
      
      
      WriteString[file, "\n \n"];
      
      WriteString[file,"If (n_in.Lt.0) Then \n"];
      WriteString[file, " i_start = 1 \n"];
      WriteString[file, 
        " i_end = "<>ToString[getGenSPheno[particle]]<>" \n "];
      WriteString[file, 
        "Else If ( (n_in.Ge.1).And.(n_in.Le. "<>ToString[
            getGenSPheno[particle]]<>") ) Then \n"];
      WriteString[file, " i_start = n_in \n"];
      WriteString[file, " i_end = n_in \n"];
      WriteString[file, "Else \n"];
      WriteString[file, " If (ErrorLevel.Ge.-1) Then \n"];
      WriteString[file, 
        "   Write (ErrCan, *) 'Problem in subroutine'//NameOfUnit(Iname) \n"];\

      WriteString[file, 
        "   Write (ErrCan, *) 'Value of n_in out of range, (n_in,"<>ToString[
            getGenSPheno[particle]]<>") = ',n_in,"<>
          ToString[getGenSPheno[particle]]<>" \n"];
      WriteString[file, " End If \n \n"];
      WriteString[file, " If (ErrorLevel.Gt.0) Call TerminateProgram \n \n"];
      WriteString[file, " If (Present(BR)) BR = 0._dp \n"];
      WriteString[file, " Iname = Iname - 1 \n"];
      WriteString[file, " Return \n"];
      WriteString[file, "End If \n \n"];
      
      If[getGenSPheno[particle]>1,
        WriteString[file, "Do i_run = i_start, i_end \n \n"];,
        WriteString[file, "i_run = 1 \n \n"];
        ];
      
      For[i=1,i\[LessEqual]Length[integrals],
        WriteString[file, ToString[integrals[[i,1]]] <>" = 0._dp \n"];
        WriteString[file, ToString[integrals[[i,4]]] <>" = 0  \n"];
        i++;];
      
      WriteString[file,"\n \n"];
      
      
      For[i=1,i\[LessEqual]Length[detailmasses],
        finalparticles= Map[getBlank,List @@ processes[[i,1]]];
        
        WriteString[file,ToString[widthsI[[i]]] <>" = 0._dp \n"];
        
        MakeCall[
          ToString[particle]<>"To"<>ToString[finalparticles[[1]]]<>
            ToString[finalparticles[[2]]]<>ToString[finalparticles[[3]]],
          Flatten[{detailmasses[[i]],detailcouplings[[i]],
              Transpose[detailintegrals[[i]]][[1]],
              Transpose[detailintegrals[[i]]][[4]],
              detailwidths[[i]]}],{"i_run"},{"deltaM", "epsI","check",
            ToString[widthsI[[i]]] },file];
        
        WriteString[file,
          ToString[widths[[i]]] <>"(i_run,:,:,:) = "<>ToString[widthsI[[i]]]<>
            " \n"];
        If[(AntiField[particle]===
                particle) && (C@@
                  processes[[i,1]]=!=(AntiField/@(C@@processes[[i,1]]))),
          If[getGenSPheno[particle]>1,
              
              WriteString[file,
                  "gT(i_run) = gT(i_run) + 2._dp*Sum("<>ToString[
                      widthsI[[i]]]<>") \n \n"];,
              
              WriteString[file,
                  "gT = gT + 2._dp*Sum("<>ToString[widthsI[[i]]]<>") \n \n"];
              ];,
          If[getGenSPheno[particle]>1,
              
              WriteString[file,
                  "gT(i_run) = gT(i_run) + Sum("<>ToString[widthsI[[i]]]<>
                    ") \n \n"];,
              
              WriteString[file,
                  "gT = gT + Sum("<>ToString[widthsI[[i]]]<>") \n \n"];
              ];
          ];
        
        i++;];
      If[getGenSPheno[particle]>1,
        WriteString[file, "End Do \n \n\n"];
        ];
      
      WriteString[file, "If (Present(gP)) Then\n"];
      WriteString[file, "Do i1 = i_start, i_end \n \n"];
      WriteString[file, "n_length=1\n"];
      
      For[i=1,i\[LessEqual]Length[processes],
        finalparticles= Map[getBlank,List @@ processes[[i,1]]];
        WriteString[file,
          "Do gt1=1,"<>ToString[getGenSPheno[finalparticles[[1]]]] <> "\n"];
        WriteString[file,
          "  Do gt2=1,"<>ToString[getGenSPheno[finalparticles[[2]]]] <> 
            "\n"];
        WriteString[file,
          "    Do gt3=1,"<>ToString[getGenSPheno[finalparticles[[3]]]] <> 
            "\n"];
        
        If[(AntiField[particle]===
                particle) && (C@@
                  processes[[i,1]]=!=(AntiField/@(C@@processes[[i,1]]))),
          
          WriteString[file, 
              "gP(i1,n_length)= 2._dp*"<>ToString[widths[[i]]]<>
                "(i1,gt1,gt2,gt3)\n"];,
          
          WriteString[file, 
              "gP(i1,n_length)= "<>ToString[widths[[i]]]<>
                "(i1,gt1,gt2,gt3)\n"];
          ];
        
        WriteString[file, "n_length=n_length+1\n"];
        WriteString[file, "     End Do \n"];  
        WriteString[file, "  End Do \n"];  
        WriteString[file, "End Do \n"];  
        i++;];
      
      If[getGenSPheno[particle]>1,
        WriteString[file, "If (Present(BR).And.(gT(i1).Gt.0._dp)) Then \n"];
        WriteString[file, "BR(i1,:)=gP(i1,:)/gT(i1)\n"];
        WriteString[file, "Else If (Present(BR)) Then\n"];
        WriteString[file, "BR(i1,:)=0._dp\n"];
        WriteString[file, "End If\n \n"];,
        WriteString[file, "If (Present(BR).And.(gT.Gt.0._dp)) Then \n"];
        WriteString[file, "BR(i1,:)=gP(i1,:)/gT\n"];
        WriteString[file, "Else If (Present(BR)) Then\n"];
        WriteString[file, "BR(i1,:)=0._dp\n"];
        WriteString[file, "End If\n \n"];
        ];
      
      WriteString[file, "End Do \n"];
      WriteString[file, "End if \n"];
      
      For[i=1,i\[LessEqual]Length[integrals],
        WriteString[file, 
          "Deallocate( "<>ToString[integrals[[i,1]]] <>" ) \n"];
        i++;];
      
      
      
      
      WriteString[file, "Iname = Iname - 1 \n \n"];
      WriteString[file, 
        "End Subroutine "<>ToString[particle]<>"ThreeBodyDecay"<>"\n \n \n"];
      
      ];

MakeDiagonalProcess[
      particle_, {f1_,n1_},{f2_,n2_},{f3_,n3_},{f1b_,f2b_,f3b_},{prop_,
        nProp_},{couplingsAll_, NRC_},process_,file_]:=Block[{temp1,temp2},
      
      listCorrInd=
        getCorrespondingIndices[{f1,n1}, {f2,n2},{f3,n3},f1b,f2b,f3b];
      temp1=
        MakeIndicesCoupling[{AntiField[particle],iIN},{prop,
            nProp},{Final1 /. process,listCorrInd[[1]]},
          couplingsAll[[2*(NRC-1)+1,2]]];
      temp2=
        MakeIndicesCoupling[{AntiField[prop],nProp},{Final2 /. process,
            listCorrInd[[2]]},{Final3 /. process,listCorrInd[[3]]},
          couplingsAll[[2*NRC,2]]];
      
      ind1=temp1[[1]];
      checkHC1=temp1[[2]];
      ind2=temp2[[1]];
      checkHC2=temp2[[2]];
      
      WriteString[file, 
        "mass(2) = "<> SPhenoMass[
            f1b /. {One[x_]\[Rule]x, Two[x_]\[Rule]x, Three[x_]\[Rule]x},
            listCorrInd[[1]]]<>" \n"];
      WriteString[file, 
        "mass(3) = -"<> SPhenoMass[
            f2b/. {One[x_]\[Rule]x, Two[x_]\[Rule]x, Three[x_]\[Rule]x},
            listCorrInd[[2]]]<>" \n"];
      WriteString[file, 
        "mass(4) = "<> SPhenoMass[
            f3b/. {One[x_]\[Rule]x, Two[x_]\[Rule]x, Three[x_]\[Rule]x},
            listCorrInd[[3]]]<>" \n \n"];
      
      If[checkHC1\[Equal]False,
        WriteString[file, 
          "coup(2) = Conjg("<>ToString[ couplingsAll[[2*(NRC-1)+1,1,1]]] <> 
            ind1 <>") \n"];
        WriteString[file, 
          "coup(1) = Conjg("<> ToString[couplingsAll[[2*(NRC-1)+1,1,2]]] <> 
            ind1 <>") \n"];,
        WriteString[file, 
          "coup(1) = "<>ToString[ couplingsAll[[2*(NRC-1)+1,1,1]]] <> ind1 <>
            " \n"];
        WriteString[file, 
          "coup(2) = "<> ToString[couplingsAll[[2*(NRC-1)+1,1,2]]] <> ind1 <>
            " \n"];
        ];
      If[checkHC2\[Equal]False,
        WriteString[file, 
          "coup(4) = Conjg("<> ToString[couplingsAll[[2*NRC,1,1]]] <>ind2 <>
            ") \n"];
        WriteString[file, 
          "coup(3) = Conjg("<> ToString[couplingsAll[[2*NRC,1,2]]] <>ind2 <>
            ")\n"];,
        WriteString[file, 
          "coup(3) = "<> ToString[couplingsAll[[2*NRC,1,1]]] <>ind2 <>" \n"];
        WriteString[file, 
          "coup(4) = "<> ToString[couplingsAll[[2*NRC,1,2]]] <>ind2 <>"\n"];
        ];
      
      tempInt=getIntegralDiagonal[process];
      
      name=ToString[SPhenoIntName[tempInt]];
      name2=ToString[SPhenoIntNameN[tempInt]];
      
      If[getType[prop]===S,
        WriteString[file,
            "Call IntegrateScalarSS(Boson2,mass,coup,deltaM,epsI,"<>name<>","<>
              name2<>",resR, check) \n"];,
        WriteString[file,
            "Call IntegrateGaugeSS(Boson2,mass,coup,deltaM,epsI,"<>name<>","<>
              name2<>",resR, check) \n"];
        ];
      
      MakeSymmFactorPart[{f1 /. {One[x_]\[Rule]x, Two[x_]\[Rule]x},
          n1},{f2/. {One[x_]\[Rule]x, Two[x_]\[Rule]x},
          n2},{f3/. {One[x_]\[Rule]x, Two[x_]\[Rule]x},n3},"resR",file];
      WriteString[file, "resD = resD + resR \n \n "];
      
      
      ];

GenerateAllSquaredDiagramsDiagonal[
      particle_,{f1_,n1_},{f2_,n2_},{f3_,n3_}, {process1_,nr1_},{couplings_, 
        nrC1_},file_]:=Block[{temp,i},
      
      
      listFinalStates={f1,f2,f3};
      listFinalStatesPro1 = {Final1 /. process1, Final2 /. process1,
          Final3 /. process1};
      
      If[Length[Intersection[listFinalStates]]\[Equal]3,
        MakeDiagonalProcess[
            particle,{f1,n1},{f2,n2},{f3,n3},{Final1 /. process1,
              Final2 /. process1,Final3 /. process1},{Propagator /. process1,
              nr1},{couplings,nrC1},process1,file];,
        
        If[Length[Intersection[listFinalStates]]\[Equal]2,
            
            temp=MakeCorrespondingStates[{f1,f2,f3},{Final1 /. process1, 
                  Final2 /. process1,Final3 /. process1},{Final1 /. process1, 
                  Final2 /. process1,Final3 /. process1}];
            listFinalStatesRep=temp[[1]];
            FinalListProcess1=temp[[2]];
            
            
            MakeDiagonalProcess[
              particle, {listFinalStatesRep[[1]],n1},{listFinalStatesRep[[2]],
                n2},{listFinalStatesRep[[3]],n3},{FinalListProcess1[[1]],
                FinalListProcess1[[2]],
                FinalListProcess1[[3]]},{Propagator /. process1,
                nr1},{couplings,nrC1},process1,file];
            
            
            
            If[(Final1 /.process1)===(Final3 /.process1) || (Final1 \
/.process1)===(Final3 /.process1) ,
              
              MakeDiagonalProcess[
                  particle, {listFinalStatesRep[[1]],
                    n1},{listFinalStatesRep[[2]],n2},{listFinalStatesRep[[3]],
                    n3},{FinalListProcess1[[1]] /. {One[x_]\[Rule]Two[x], 
                        Two[x_]\[Rule]One[x]},
                    FinalListProcess1[[2]] /. {One[x_]\[Rule]Two[x], 
                        Two[x_]\[Rule]One[x]},
                    FinalListProcess1[[3]] /. {One[x_]\[Rule]Two[x], 
                        Two[x_]\[Rule]One[x]}},{Propagator /. process1,
                    nr1},{couplings,nrC1},process1,file];
              ];
            
            
            MakeOffDiagonalProcess[
              particle,{listFinalStatesRep[[1]],n1},{listFinalStatesRep[[2]],
                n2},{listFinalStatesRep[[3]],
                n3},{FinalListProcess1[[1]] /. {One[x_]\[Rule]Two[x], 
                    Two[x_]\[Rule]One[x]},
                FinalListProcess1[[2]]/. {One[x_]\[Rule]Two[x], 
                    Two[x_]\[Rule]One[x]},
                FinalListProcess1[[3]]/. {One[x_]\[Rule]Two[x], 
                    Two[x_]\[Rule]One[x]}},{FinalListProcess1[[1]],
                FinalListProcess1[[2]],
                FinalListProcess1[[3]]}, {Propagator /. process1, 
                nr1},{Propagator /. process1, nr1},{couplings,nrC1,nrC1},
              process1,process1,-1,file];,
            
            
            listFinalStatesRep={One[f1],Two[f2],Three[f3]};
            
            FinalListProcess1={One[Final1 /. process1],
                Two[Final2 /. process1],Three[Final3 /. process1]};
            
            
            MakeDiagonalProcess[
              particle, {listFinalStatesRep[[1]],n1},{listFinalStatesRep[[2]],
                n2},{listFinalStatesRep[[3]],n3},{FinalListProcess1[[1]],
                FinalListProcess1[[2]],
                FinalListProcess1[[3]]},{Propagator /. process1,
                nr1},{couplings,nrC1},process1,file];
            
            
            
            MakeDiagonalProcess[
              particle, {listFinalStatesRep[[1]],n1},{listFinalStatesRep[[2]],
                n2},{listFinalStatesRep[[3]],
                n3},{FinalListProcess1[[1]] /. {One[x_]\[Rule]Two[x], 
                    Two[x_]\[Rule]One[x]},
                FinalListProcess1[[2]] /. {One[x_]\[Rule]Two[x], 
                    Two[x_]\[Rule]One[x]},
                FinalListProcess1[[3]] /. {One[x_]\[Rule]Two[x], 
                    Two[x_]\[Rule]One[x]}},{Propagator /. process1,
                nr1},{couplings,nrC1},process1,file];
            
            
            
            listSubCrossingST1={{One[x_]\[Rule]One[x],Two[x_]\[Rule]Two[x], 
                  Three[x_]\[Rule]Three[x]},
                				{One[x_]\[Rule]One[x],Two[x_]\[Rule]Two[x], 
                  Three[x_]\[Rule]Three[x]},
                				{One[x_]\[Rule]Three[x],Two[x_]\[Rule]One[x], 
                  Three[x_]\[Rule]Two[x]},
                				{One[x_]\[Rule]Three[x],Two[x_]\[Rule]One[x], 
                  Three[x_]\[Rule]Two[x]},
                				{One[x_]\[Rule]Two[x],Two[x_]\[Rule]One[x], 
                  Three[x_]\[Rule]Three[x]},
                				{One[x_]\[Rule]Two[x],Two[x_]\[Rule]One[x], 
                  Three[x_]\[Rule]Three[x]}};
            
            For[i=1,i\[LessEqual]6,
              
              MakeOffDiagonalProcess[
                particle,{listFinalStatesRep[[1]],
                  n1},{listFinalStatesRep[[2]],n2},{listFinalStatesRep[[3]],
                  n3},{FinalListProcess1[[1]] /. listSubCrossingST1[[i]],
                  FinalListProcess1[[2]] /. listSubCrossingST1[[i]],
                  FinalListProcess1[[3]] /. 
                    listSubCrossingST1[[i]]},{FinalListProcess1[[1]],
                  FinalListProcess1[[2]],
                  FinalListProcess1[[3]]}, {Propagator /. process1, 
                  nr1},{Propagator /. process1, nr1},{couplings,nrC1,nrC1},
                process1,process1,-1,file];
              i++;];
            
            ];
        ];
      ];


WriteThreeBodyDecay[particle_,finalparticles_,diagrams_,masses_,couplings_,
      couplingsAll_,integrals_,widths_,file_]:=
    Block[{i,j,name,name2,tempString, factor,temp1a,temp2a,temp1b,temp2b, 
        temp,nrSaved},
      MakeSubroutineTitle[
        ToString[particle]<>"To"<>ToString[finalparticles[[1]]]<>
          ToString[finalparticles[[2]]]<>ToString[finalparticles[[3]]],
        Flatten[{masses,couplings,Transpose[integrals][[1]],
            Transpose[integrals][[4]],widths}],{"iIN"},{"deltaM", "epsI","check",
          "g", "WriteContributions"},file];
      
      WriteString[file,"Implicit None \n \n"];
      MakeVariableList[Flatten[{masses,couplings}],",Intent(in)", file];
      MakeVariableList[Transpose[integrals][[1]],",Intent(inout)", file];
      (* MakeVariableList[Transpose[integrals][[4]],",Intent(inout)", file]; *)

            MakeVariableList[widths,",Intent(inout)",file];
      
      tempString="";
      For[i=1,i\[LessEqual]Length[integrals],
        tempString=tempString <> ToString[integrals[[i,4]]]<>",";
        i++;];
       tempString=StringDrop[tempString,-1];
      WriteString[file,
        "Integer, Intent(inout) :: "<> FortranLineBreak[tempString]<>"\n"]; 
      WriteString[file,"Real(dp),Intent(inout)::g(:,:,:) \n"];
      
      
      WriteString[file,"Logical, Intent(in) :: check \n"];
      WriteString[file,"Integer, Intent(in) :: iIN \n"];
      WriteString[file,"Real(dp), Intent(in) :: epsI, deltaM \n"];
      WriteString[file,"Logical, Optional :: WriteContributions \n"];
      WriteString[file,"Integer :: i1,i2,gt1,gt2,gt3, Isum \n"];
      WriteString[file,
        "Real(dp) :: Boson2(2), mass(4), resR, Boson4(4), res1, res2, resD \n"]\
;
      WriteString[file,
        "Complex(dp) :: coup(4), coup2(8), resC, resS, coupT \n"];
      WriteString[file,"Real(dp), Allocatable :: gSum(:,:,:,:) \n"];
      WriteString[file,
        "Character(len=20), Allocatable :: Contribution(:,:,:,:) \n"];
      
      WriteString[file,"mass(1) = " <>SPhenoMass[particle,iIN]<>" \n \n"];
      
      WriteString[file, 
        "Isum = "<>ToString[NumberOfDiagrams[diagrams]]<>" \n"];
      nrSaved = ToString[NumberOfDiagrams[diagrams]];
      
      WriteString[file, 
        "Allocate( gSum("<>ToString[getGenSPheno[Final1 /. diagrams[[1]]]] <>","<>
          ToString[getGenSPheno[Final2 /. diagrams[[1]]]]   <>","<>
          ToString[getGenSPheno[Final3 /. diagrams[[1]]]]  <>", Isum) ) \n"];
      WriteString[file, 
        "Allocate( Contribution("<>ToString[
            getGenSPheno[Final1 /. diagrams[[1]]]] <>","<>
          ToString[getGenSPheno[Final2 /. diagrams[[1]]]]   <>","<>
          ToString[getGenSPheno[Final3 /. diagrams[[1]]]]  <>", Isum) ) \n"];
      
      
      WriteString[file, "gSum = 0._dp  \n"];
      WriteString[file, "Contribution = ' ' \n \n"];
      
      WriteString[file, "Isum = 0 \n \n"];
      
      
       FinalParticle1=Final1 /. diagrams[[1]];
      FinalParticle2=Final2 /. diagrams[[1]];
      FinalParticle3=Final3 /. diagrams[[1]]; 
      
      
      
      If[getGenSPheno[FinalParticle1]>1,
        var1="gt1";
        If[FinalParticle1===particle,
          DoLoop1="    Do gt1=1, iIN-1\n";
          DoLoopEnd1= "   End Do \n";,
          
          DoLoop1="    Do gt1=1,"<>ToString[getGenSPheno[FinalParticle1]] <> 
              "\n";
          DoLoopEnd1= "   End Do \n";
          ];,
        DoLoop1="";
        DoLoopEnd1= "";
        var1="1";
        ];
      
      If[getGenSPheno[FinalParticle2]>1,
        var2="gt2";
        If[FinalParticle2===particle,
          DoLoop2="      Do gt2=1, iIN-1\n";
          DoLoopEnd2= "     End Do \n";,
          
          DoLoop2="      Do gt2=1,"<>ToString[getGenSPheno[FinalParticle2]] <> 
              "\n";
          DoLoopEnd2= "     End Do \n";
          ];,
        DoLoop2="";
        DoLoopEnd2= "";
        var2="1";
        ];
      
      If[getGenSPheno[FinalParticle3]>1,
        var3="gt3";
        If[FinalParticle3===particle,
          DoLoop3="        Do gt3=1, iIN-1\n";
          DoLoopEnd3= "       End Do \n";,
          
          DoLoop3="        Do gt3=1,"<>
              ToString[getGenSPheno[FinalParticle3]] <> "\n";
          DoLoopEnd3= "       End Do \n";
          ];,
        DoLoop3="";
        DoLoopEnd3= "";
        var3="1";
        ];
      
      
      
      WriteString[file, DoLoop1];  WriteString[file, DoLoop2];  
      WriteString[file, DoLoop3];
      WriteString[file, "Isum = 0 \n \n"];
      
      
      WriteString[file, 
        "If(Abs("<>SPhenoMass[particle,iIN]<>").gt.(Abs("<>
          SPhenoMass[FinalParticle3,gt3]<>")+Abs("<>
          SPhenoMass[FinalParticle2,gt2]<>")+Abs("<>
          SPhenoMass[FinalParticle1,gt1]<>"))) Then \n"];
      
      For[i=1,i\[LessEqual]Length[diagrams],
        
        WriteString[file,"!-------------- \n"];
        WriteString[file,
          "!  " <> ToString[Propagator /. diagrams[[i]]] <>" \n"];
        WriteString[file,"!-------------- \n"];
        
        If[getGenSPheno[Propagator/. diagrams[[i]]]>1,
          WriteString[file,
              "Do i1=1,"<>ToString[
                  getGenSPheno[Propagator /. diagrams[[i]]]] <> "\n"];];
        WriteString[file, "Isum = Isum + 1 \n"];
        
        WriteString[file, 
          "Boson2(1) = "<>SPhenoMass[Propagator /. diagrams[[i]], i1] <>
            " \n"];
        WriteString[file, 
          "Boson2(2) ="<>SPhenoWidth[Propagator /. diagrams[[i]], i1] <>
            " \n"];
        WriteString[file, "\n resD=0._dp \n \n"];
        GenerateAllSquaredDiagramsDiagonal[
          particle,{FinalParticle1,gt1},{FinalParticle2,gt2},{FinalParticle3,
            gt3}, {diagrams[[i]],i1},{couplingsAll, i},file];
        
        
        WriteString[file,"gSum("<>var1<>","<>var2<>",",
          var3<>",Isum)=resD\n"];
        WriteString[file,"Contribution("<>var1<>","<>var2<>",",
          var3<>",Isum)='"<>ToString[Propagator /. diagrams[[i]]] <>"'\n"];
        
        If[getGenSPheno[Propagator/. diagrams[[i]]]>1,
          WriteString[file,"      End Do \n"];];
        WriteString[file,"\n\n\n"];
        i++;];
      
      
      For[i=1,i\[LessEqual]Length[diagrams],
        For[j=i,j\[LessEqual]Length[diagrams],
          
          If[i=!=j || getGenSPheno[Propagator/. diagrams[[i]]]>1,
            
            WriteString[file,"!-------------- \n"];
            
            WriteString[file,
              "!  " <> ToString[Propagator /. diagrams[[i]]]<>", "<> 
                ToString[Propagator /. diagrams[[j]]] <>" \n"];
            WriteString[file,"!-------------- \n"];
            
            If[i\[Equal]j ,
              
              If[getGenSPheno[Propagator/. diagrams[[i]]]>1,
                  WriteString[file,
                      "Do i1=1,"<>ToString[
                          getGenSPheno[Propagator /. diagrams[[i]]]-1] <> 
                        "\n"];];,
              
              If[getGenSPheno[Propagator/. diagrams[[i]]]>1,
                  WriteString[file,
                      "Do i1=1,"<>ToString[
                          getGenSPheno[Propagator /. diagrams[[i]]]] <> 
                        "\n"];];
               ];
            
            If[i\[Equal]j ,
              
              If[getGenSPheno[Propagator/. diagrams[[j]]]>1,
                  WriteString[file,
                      "  Do i2=i1+1,"<>ToString[
                          getGenSPheno[Propagator /. diagrams[[j]]]] <> 
                        "\n"];];,
              
              If[getGenSPheno[Propagator/. diagrams[[j]]]>1,
                  WriteString[file,
                      "  Do i2=1,"<>ToString[
                          getGenSPheno[Propagator /. diagrams[[j]]]] <> 
                        "\n"];];
              ];
            
            
            WriteString[file, 
              "Boson4(1) = "<>SPhenoMass[Propagator /. diagrams[[i]],i1] <>
                " \n"];
            
            WriteString[file, 
              "Boson4(2) = "<>SPhenoWidth[Propagator /. diagrams[[i]],i1] <>
                " \n"];
            
            WriteString[file, 
              "Boson4(3) = "<>SPhenoMass[Propagator /. diagrams[[j]],i2] <>
                " \n"];
            
            WriteString[file, 
              "Boson4(4) = "<>SPhenoWidth[Propagator /. diagrams[[j]],i2] <>
                " \n"];
            
            WriteString[file, "Isum = Isum + 1 \n \n"];
            
            WriteString[file, "resS = 0._dp \n"];
            
            
            GenerateAllSquaredDiagrams[
              particle,{FinalParticle1,gt1},{FinalParticle2,
                gt2},{FinalParticle3,gt3}, {diagrams[[i]],i1}, {diagrams[[j]],
                i2},{couplingsAll, i, j},file];
            
            
            WriteString[file,"gSum("<>var1<>","<>var2<>",",
              var3<>",Isum)= resS  \n"];
            
            WriteString[file,"Contribution("<>var1<>","<>var2<>",",
              var3<>",Isum)='"<>ToString[Propagator /. diagrams[[i]]] <>","<>
                ToString[Propagator /. diagrams[[j]]] <>"'\n"];
            
            
            If[getGenSPheno[Propagator/. diagrams[[i]]]>1,
              WriteString[file,"        End Do \n"];];
            If[getGenSPheno[Propagator/. diagrams[[j]]]>1,
              WriteString[file,"      End Do \n"];];
            
            WriteString[file,"\n\n\n"];
            ];
          j++;];
        i++;];
      
      WriteString[file, "Else \n"];
      WriteString[file,"gSum("<>var1<>","<>var2<>",",var3<>",:)= 0._dp  \n"];
      
      WriteString[file, "End If \n"];
      WriteString[file, DoLoopEnd3];  WriteString[file, DoLoopEnd2];  
      WriteString[file, DoLoopEnd1];
      
      
      WriteString[file,"!---------- \n"];
      WriteString[file,"!Summing \n"];
      WriteString[file,"!---------- \n"];
      
      WriteString[file,"g=0._dp \n"];
      
      WriteString[file, DoLoop1];  WriteString[file, DoLoop2];  
      WriteString[file, DoLoop3];
      
      WriteString[file,"g("<>var1<>","<>var2<>",",
        var3<>")=Sum(gSum("<>var1<>","<>var2<>",",
        var3<>",1:"<>nrSaved<>"))\n"];
      WriteString[file,"If (g("<>var1<>","<>var2<>",",
        var3<>").Lt.0._dp) Then\n"];
      WriteString[file,
        "  Write (ErrCan,*)'Error in Subroutine'//NameOfUnit(Iname)\n"];
      WriteString[file,"  g("<>var1<>","<>var2<>",",var3<>")=0._dp\n"];
      WriteString[file,"End If\n"];
      
      WriteString[file, DoLoopEnd3];  WriteString[file, DoLoopEnd2];  
      WriteString[file, DoLoopEnd1];
      
      factor=
        CalculateColorFactorDecay[getBlank[particle],
            getBlank[Final1 /. diagrams[[1]]],
            getBlank[Propagator /. diagrams[[1]]]]*
          CalculateColorFactorDecay[getBlank[Propagator /. diagrams[[1]]],
            getBlank[Final3 /. diagrams[[1]]],
            getBlank[Final2 /. diagrams[[1]]]];
      
      WriteString[file,
        "  g = "<>SPhenoForm[factor] <>"*oo512pi3 / Abs("<>
          SPhenoMass[particle,iIN]<>")**3*g\n"];
      
      WriteString[file, 
        "End Subroutine "<>ToString[particle]<>"To"<>
          ToString[finalparticles[[1]]]<>ToString[finalparticles[[2]]]<>
          ToString[finalparticles[[3]]]<> " \n \n \n"];
      
      ]; 




MakeCorrespondingStates[listCorr_,list1_,list2_]:=
    Block[{i,f1,f2,f3,f1T,f2T,f3T, listFinalStatesRep,FinalListProcess1,
        FinalListProcess2, tempList1,tempList2},
      f1=listCorr[[1]]; f2=listCorr[[2]]; f3=listCorr[[3]];
      If[f1===f2, 
        f1T=One[f1]; 
        f2T=Two[f2];
        f3T = f3;,
        If[f1===f3, 
            f1T=One[f1]; 
            f2T = f2; 
            f3T = Two[f3];,
            If[f2===f3, 
                f1T=f1;f2T=One[f2]; f3T=Two[f3];];
            ];
        ];
      
      listFinalStatesRep={f1T,f2T,f3T};
      
      tempList1 = listCorr;
      tempList2 = listFinalStatesRep;
      FinalListProcess1={};
      
      For[i=1,i\[LessEqual]3,
        pos=Position[tempList1,list1[[i]],1][[1,1]]; 
        FinalListProcess1 = Join[FinalListProcess1,{tempList2[[pos]]}];
        tempList1=Delete[tempList1,pos];
        tempList2=Delete[tempList2,pos];
        i++;
        ];
      
      tempList1 = listCorr;
      tempList2 = listFinalStatesRep;
      FinalListProcess2={};
      
      For[i=1,i\[LessEqual]3,
        pos=Position[tempList1,list2[[i]],1][[1,1]]; 
        FinalListProcess2 = Join[FinalListProcess2,{tempList2[[pos]]}];
        tempList1=Delete[tempList1,pos];
        tempList2=Delete[tempList2,pos];
        i++;
        ];
      
      Return[{listFinalStatesRep, FinalListProcess1,FinalListProcess2}];
      
      ];


GenerateAllSquaredDiagrams[
      particle_,{f1_,n1_},{f2_,n2_},{f3_,n3_}, {process1_,nr1_}, {process2_,
        nr2_},{couplings_, nrC1_, nrC2_},file_]:=Block[{i},
      
      listFinalStates={f1,f2,f3};
      listFinalStatesPro1 = {Final1 /. process1, Final2 /. process1,
          Final3 /. process1};
      listFinalStatesPro2 = {Final1 /. process2, Final2 /. process2,
          Final3 /. process2};
      
      
      If[Length[Intersection[listFinalStates]]\[Equal]3,
        MakeOffDiagonalProcess[
            particle,{f1,n1},{f2,n2},{f3,n3},{Final1/.process1, 
              Final2 /. process1, Final3 /. process1},{Final1/.process2, 
              Final2 /. process2, 
              Final3 /. process2}, {Propagator /. process1, 
              nr1},{Propagator /. process2, nr2},{couplings,nrC1,nrC2},
            process1,process2,1,file];,
        
        If[Length[Intersection[listFinalStates]]\[Equal]2,
            
            temp = MakeCorrespondingStates[listFinalStates,
                listFinalStatesPro1 ,listFinalStatesPro2];
            listFinalStatesRep=temp[[1]];
            FinalListProcess1=temp[[2]];
            FinalListProcess2=temp[[3]];
            
            
            
            MakeOffDiagonalProcess[
              particle,{listFinalStatesRep[[1]],n1},{listFinalStatesRep[[2]],
                n2},{listFinalStatesRep[[3]],n3},{FinalListProcess1[[1]],
                FinalListProcess1[[2]],
                FinalListProcess1[[3]]},{FinalListProcess2[[1]],
                FinalListProcess2[[2]],
                FinalListProcess2[[3]]}, {Propagator /. process1, 
                nr1},{Propagator /. process2, nr2},{couplings,nrC1,nrC2},
              process1,process2,1,file];
            
            
            If[(Final1 /. process1) === (Final2 /. process1) || (Final1 /. 
                      process1) === (Final3 /. process1),
              
              MakeOffDiagonalProcess[
                particle,{listFinalStatesRep[[1]],
                  n1},{listFinalStatesRep[[2]],n2},{listFinalStatesRep[[3]],
                  n3},{FinalListProcess1[[1]] /. {One[x_]\[Rule]Two[x], 
                      Two[x_]\[Rule]One[x]},
                  FinalListProcess1[[2]]/. {One[x_]\[Rule]Two[x], 
                      Two[x_]\[Rule]One[x]},
                  FinalListProcess1[[3]]/. {One[x_]\[Rule]Two[x], 
                      Two[x_]\[Rule]One[x]}},{FinalListProcess2[[1]],
                  FinalListProcess2[[2]],
                  FinalListProcess2[[3]]}, {Propagator /. process1, 
                  nr1},{Propagator /. process2, nr2},{couplings,nrC1,nrC2},
                process1,process2,-1,file];
              
              
              If[(Final1 /. process2) === (Final2 /. process2) || (Final1 /. 
                        process2) === (Final3 /. process2),
                
                MakeOffDiagonalProcess[
                  particle,{listFinalStatesRep[[1]],
                    n1},{listFinalStatesRep[[2]],n2},{listFinalStatesRep[[3]],
                    n3},{FinalListProcess1[[1]] /. {One[x_]\[Rule]Two[x], 
                        Two[x_]\[Rule]One[x]},
                    FinalListProcess1[[2]]/. {One[x_]\[Rule]Two[x], 
                        Two[x_]\[Rule]One[x]},
                    FinalListProcess1[[3]]/. {One[x_]\[Rule]Two[x], 
                        Two[x_]\[Rule]
                          One[x]}},{FinalListProcess2[[1]]/. {One[x_]\[Rule]
                          Two[x], Two[x_]\[Rule]One[x]},
                    FinalListProcess2[[2]]/. {One[x_]\[Rule]Two[x], 
                        Two[x_]\[Rule]One[x]},
                    FinalListProcess2[[3]]/. {One[x_]\[Rule]Two[x], 
                        Two[x_]\[Rule]One[x]}}, {Propagator /. process1, 
                    nr1},{Propagator /. process2, nr2},{couplings,nrC1,nrC2},
                  process1,process2,1,file];
                
                
                
                MakeOffDiagonalProcess[
                  particle,{listFinalStatesRep[[1]],
                    n1},{listFinalStatesRep[[2]],n2},{listFinalStatesRep[[3]],
                    n3},{FinalListProcess1[[1]] ,FinalListProcess1[[2]],
                    FinalListProcess1[[3]]},{FinalListProcess2[[1]]/. {One[
                            x_]\[Rule]Two[x], Two[x_]\[Rule]One[x]},
                    FinalListProcess2[[2]]/. {One[x_]\[Rule]Two[x], 
                        Two[x_]\[Rule]One[x]},
                    FinalListProcess2[[3]]/. {One[x_]\[Rule]Two[x], 
                        Two[x_]\[Rule]One[x]}}, {Propagator /. process1, 
                    nr1},{Propagator /. process2, nr2},{couplings,nrC1,nrC2},
                  process1,process2,-1,file];
                ];,
              
              
              If[(Final1 /. process2) === (Final2 /. process2) || (Final1 /. 
                          process2) === (Final3 /. process2),
                  
                  MakeOffDiagonalProcess[
                      particle,{listFinalStatesRep[[1]],
                        n1},{listFinalStatesRep[[2]],
                        n2},{listFinalStatesRep[[3]],
                        n3},{FinalListProcess1[[1]] ,FinalListProcess1[[2]],
                        FinalListProcess1[[3]]},{FinalListProcess2[[1]]/. \
{One[x_]\[Rule]Two[x], Two[x_]\[Rule]One[x]},
                        FinalListProcess2[[2]]/. {One[x_]\[Rule]Two[x], 
                            Two[x_]\[Rule]One[x]},
                        FinalListProcess2[[3]]/. {One[x_]\[Rule]Two[x], 
                            Two[x_]\[Rule]One[x]}}, {Propagator /. process1, 
                        nr1},{Propagator /. process2, nr2},{couplings,nrC1,
                        nrC2},process1,process2,-1,file];
                  ];
              ];,
            
            listFinalStatesRep={One[f1],Two[f2],Three[f3]};
            FinalListProcess1={One[Final1 /. process1],
                Two[Final2 /. process1],Three[Final3 /. process1]};
            
            FinalListProcess2={One[Final1 /. process2],
                Two[Final2 /. process2],Three[Final3 /. process2]};
            
            
            
            listSubCrossingSS={{One[x_]\[Rule]One[x],Two[x_]\[Rule]Two[x], 
                  Three[x_]\[Rule]Three[x]},
                				{One[x_]\[Rule]Two[x],Two[x_]\[Rule]One[x], 
                  Three[x_]\[Rule]Three[x]},
                				{One[x_]\[Rule]Three[x],Two[x_]\[Rule]Two[x], 
                  Three[x_]\[Rule]One[x]}};
            
            For[i=1,i\[LessEqual]3,
              
              MakeOffDiagonalProcess[
                particle,{listFinalStatesRep[[1]],
                  n1},{listFinalStatesRep[[2]],n2},{listFinalStatesRep[[3]],
                  n3},{FinalListProcess1[[1]] ,FinalListProcess1[[2]],
                  FinalListProcess1[[3]]},{FinalListProcess2[[1]]/. 
                    listSubCrossingSS[[i]],
                  FinalListProcess2[[2]]/. listSubCrossingSS[[i]],
                  FinalListProcess2[[3]]/. 
                    listSubCrossingSS[[i]]}, {Propagator /. process1, 
                  nr1},{Propagator /. process2, nr2},{couplings,nrC1,nrC2},
                process1,process2,-1,file];
              i++;];
            
            
            
            listSubCrossingST1={{One[x_]\[Rule]One[x],Two[x_]\[Rule]Two[x], 
                  Three[x_]\[Rule]Three[x]},
                				{One[x_]\[Rule]One[x],Two[x_]\[Rule]Two[x], 
                  Three[x_]\[Rule]Three[x]},
                				{One[x_]\[Rule]Three[x],Two[x_]\[Rule]One[x], 
                  Three[x_]\[Rule]Two[x]},
                				{One[x_]\[Rule]Three[x],Two[x_]\[Rule]One[x], 
                  Three[x_]\[Rule]Two[x]},
                				{One[x_]\[Rule]Two[x],Two[x_]\[Rule]One[x], 
                  Three[x_]\[Rule]Three[x]},
                				{One[x_]\[Rule]Two[x],Two[x_]\[Rule]One[x], 
                  Three[x_]\[Rule]Three[x]}};
            
            
            listSubCrossingST2={{One[x_]\[Rule]Three[x],Two[x_]\[Rule]One[x], 
                  Three[x_]\[Rule]Two[x]},
                				{One[x_]\[Rule]Two[x],Two[x_]\[Rule]One[x], 
                  Three[x_]\[Rule]Three[x]},
                				{One[x_]\[Rule]One[x],Two[x_]\[Rule]Two[x], 
                  Three[x_]\[Rule]Three[x]},
                				{One[x_]\[Rule]Two[x],Two[x_]\[Rule]One[x], 
                  Three[x_]\[Rule]Three[x]},
                				{One[x_]\[Rule]One[x],Two[x_]\[Rule]Two[x], 
                  Three[x_]\[Rule]Three[x]},
                				{One[x_]\[Rule]Three[x],Two[x_]\[Rule]One[x], 
                  Three[x_]\[Rule]Two[x]}};
            
            
            For[i=1,i\[LessEqual]6,
              
              MakeOffDiagonalProcess[
                particle,{listFinalStatesRep[[1]],
                  n1},{listFinalStatesRep[[2]],n2},{listFinalStatesRep[[3]],
                  n3},{FinalListProcess1[[1]] /. listSubCrossingST1[[i]],
                  FinalListProcess1[[2]] /. listSubCrossingST1[[i]],
                  FinalListProcess1[[3]] /. 
                    listSubCrossingST1[[i]]},{FinalListProcess2[[1]]/. 
                    listSubCrossingST2[[i]],
                  FinalListProcess2[[2]]/. listSubCrossingST2[[i]],
                  FinalListProcess2[[3]]/. 
                    listSubCrossingST2[[i]]}, {Propagator /. process1, 
                  nr1},{Propagator /. process2, nr2},{couplings,nrC1,nrC2},
                process1,process2,-1,file];
              i++;];
            ];
        ];
      ];




MakeOffDiagonalProcess[
      particle_, {f1_,n1_},{f2_,n2_},{f3_,n3_},{f1a_,f2a_,f3a_},{f1b_,f2b_,
        f3b_},{prop1_,nProp1_},{prop2_,nProp2_},{couplingsAll_, NRC1_,NRC2_},
      process1_, process2_,relativeFactor_,file_]:=Block[{temp1,temp2, fac},
      
      
      
      
      
      listCorrInd=
        getCorrespondingIndices[{f1,n1}, {f2,n2},{f3,n3},f1a,f2a,f3a];
      temp1a=
        MakeIndicesCoupling[{AntiField[particle],iIN},{prop1,
            nProp1},{Final1 /. process1,listCorrInd[[1]]},
          couplingsAll[[2*(NRC1-1)+1,2]]];
      temp1b=
        MakeIndicesCoupling[{AntiField[prop1],nProp1},{Final2 /. process1,
            listCorrInd[[2]]},{Final3 /. process1,listCorrInd[[3]]},
          couplingsAll[[2*NRC1,2]]];
      
      (*
        
        listCorrInd1=
          getCorrespondingIndices[{f1,n1}, {f2,n2},{f3,n3},f1b,f2b,f3b];
        temp2a=
          MakeIndicesCoupling[{AntiField[particle],iIN},{prop2,
              nProp2},{Final1 /. process2,listCorrInd1[[1]]},
            couplingsAll[[2*(NRC2-1)+1,2]],True];
        temp2b=
          MakeIndicesCoupling[{AntiField[prop2],nProp2},{Final2 /. process2,
              listCorrInd1[[2]]},{Final3 /. process2,listCorrInd1[[3]]},
            couplingsAll[[2*NRC2,2]],True];
        *)
      
      listCorrInd1=
        getCorrespondingIndices[{f1,n1}, {f2,n2},{f3,n3},f1b,f2b,f3b];
      temp2a=
        MakeIndicesCoupling[{particle,iIN},{AntiField[prop2],
            nProp2},{AntiField[Final1 /. process2],listCorrInd1[[1]]},
          couplingsAll[[2*(NRC2-1)+1,2]],True];
      temp2b=
        MakeIndicesCoupling[{prop2,nProp2},{AntiField[Final2 /. process2],
            listCorrInd1[[2]]},{AntiField[Final3 /. process2],
            listCorrInd1[[3]]},couplingsAll[[2*NRC2,2]],True];
      
      
      ind1a=temp1a[[1]];
      check1a=temp1a[[2]];
      ind2a=temp2a[[1]];
      check2a=temp2a[[2]];
      ind1b=temp1b[[1]];
      check1b=temp1b[[2]];
      ind2b=temp2b[[1]];
      check2b=temp2b[[2]];
      
      If[getType[prop1]===V,
        LRconjugated1={"1","2","5","6"};,
        LRconjugated1={"2","1","6","5"};
        ];
      
      If[getType[prop2]===V,
        LRconjugated2={"3","4","7","8"};,
        LRconjugated2={"4","3","8","7"};
        ];
      
      
      If[f1a=== f1b,
        WriteString[file, 
          "mass(2) = "<> SPhenoMass[
              f1a/. {One[x_]\[Rule]x, Two[x_]\[Rule]x, Three[x_]\[Rule]x},
              listCorrInd[[1]]]<>" \n"];
        WriteString[file, 
          "mass(3) = -"<> SPhenoMass[
              f2a/. {One[x_]\[Rule]x, Two[x_]\[Rule]x, Three[x_]\[Rule]x},
              listCorrInd[[2]]]<>" \n"];
        WriteString[file, 
          "mass(4) = "<> SPhenoMass[
              f3a/. {One[x_]\[Rule]x, Two[x_]\[Rule]x, Three[x_]\[Rule]x},
              listCorrInd[[3]]]<>" \n \n"];,
        WriteString[file, 
          "mass(2) = "<> SPhenoMass[
              f1b /. {One[x_]\[Rule]x, Two[x_]\[Rule]x, Three[x_]\[Rule]x},
              listCorrInd1[[1]]]<>" \n"];
        WriteString[file, 
          "mass(4) = "<> SPhenoMass[
              f1a/. {One[x_]\[Rule]x, Two[x_]\[Rule]x, Three[x_]\[Rule]x},
              listCorrInd[[1]]]<>" \n"];
        mass3 = DeleteCases[{f2a,f3a},f1b][[1]];
        pos3=Position[{f1a,f2a,f3a},mass3][[1,1]];
        WriteString[file, 
          "mass(3) = -"<> SPhenoMass[
              mass3/. {One[x_]\[Rule]x, Two[x_]\[Rule]x, Three[x_]\[Rule]x},
              listCorrInd[[pos3]]]<>" \n \n"];
        ];
      
      
      If[check1a\[Equal]True,
        WriteString[file,
          "coup2("<>LRconjugated1[[1]] <>") = Conjg("<> 
            ToString[couplingsAll[[2*(NRC1-1)+1,1,1]]] <> ind1a <>") \n"];
        WriteString[file,
          "coup2("<>LRconjugated1[[2]] <>") = Conjg("<> 
            ToString[couplingsAll[[2*(NRC1-1)+1,1,2]] ]<> ind1a <>") \n"];,
        WriteString[file,
          "coup2(1) = "<> ToString[couplingsAll[[2*(NRC1-1)+1,1,1]]] <> 
            ind1a <>" \n"];
        WriteString[file,
          "coup2(2) = "<> ToString[couplingsAll[[2*(NRC1-1)+1,1,2]] ]<> 
            ind1a <>" \n"];
        ];
      
      If[check2a\[Equal]False,
        WriteString[file,
          "coup2("<>LRconjugated2[[1]] <>") = Conjg("<> 
            ToString[couplingsAll[[2*(NRC2-1)+1,1,1]]] <> ind2a <>") \n"];
        WriteString[file,
          "coup2("<>LRconjugated2[[2]] <>") = Conjg("<> 
            ToString[couplingsAll[[2*(NRC2-1)+1,1,2]]] <> ind2a <>")  \n"];,
        WriteString[file,
          "coup2(3) = "<> ToString[couplingsAll[[2*(NRC2-1)+1,1,1]]] <> 
            ind2a <>" \n"];
        WriteString[file,
          "coup2(4) = "<> ToString[couplingsAll[[2*(NRC2-1)+1,1,2]]] <> 
            ind2a <>"  \n"];
        ];
      
      If[check1b\[Equal]True,
        WriteString[file,
          "coup2("<>LRconjugated1[[3]] <>") = Conjg("<> 
            ToString[couplingsAll[[2*NRC1,1,1]]] <> ind1b <>") \n"];
        WriteString[file,
          "coup2("<>LRconjugated1[[4]] <>") = Conjg("<> 
            ToString[couplingsAll[[2*NRC1,1,2]]] <> ind1b <>") \n"];,
        WriteString[file,
          "coup2(5) = "<> ToString[couplingsAll[[2*NRC1,1,1]]] <> ind1b <>
            " \n"];
        WriteString[file,
          "coup2(6) = "<> ToString[couplingsAll[[2*NRC1,1,2]]] <> ind1b <>
            " \n"];
        ];
      
      If[check2b\[Equal]False,
        WriteString[file,
          "coup2("<>LRconjugated2[[3]] <>") = Conjg("<> 
            ToString[couplingsAll[[2*NRC2,1,1]]] <> ind2b <>") \n"];
        WriteString[file,
          "coup2("<>LRconjugated2[[4]] <>") = Conjg("<> 
            ToString[couplingsAll[[2*NRC2,1,2]]] <> ind2b <>") \n"];,
        WriteString[file,
          "coup2(7) = "<> ToString[couplingsAll[[2*NRC2,1,1]]] <> ind2b <>
            " \n"];
        WriteString[file,
          "coup2(8) = "<> ToString[couplingsAll[[2*NRC2,1,2]]] <> ind2b <>
            " \n"];
        ];
      
      
      
      
      tempInt=getIntegralOffDiagonal[process1,process2, f1a, f1b];
      name=ToString[SPhenoIntName[tempInt]];
      name2=ToString[SPhenoIntNameN[tempInt]];
      
      If[getType[prop1] ===S && getType[prop2]===S,
        If[f1a===f1b,
            
            WriteString[file, 
              "Call IntegrateScalarS1S2(Boson4, mass, coup2, deltaM, epsI,"<>
                name<>","<>name2<>", resC, check) \n"];
            fac=2.*relativeFactor;
            
            WriteString[file,
              "resC = "<>ToString[FortranForm[fac]]<>"*resC \n"];,
            
            WriteString[file, 
              "Call IntegrateScalarST(Boson4, mass, coup2, deltaM, epsI,"<>
                name<>","<>name2<>", resC, check) \n"];
            fac=-2.*relativeFactor;
            fac=-2.;
            
            WriteString[file,
              "resC = "<>ToString[FortranForm[fac]]<>"*resC \n"];
            ];,
        If[getType[prop1] ===V && getType[prop2]===V,
            If[f1b=== f1a,
                
                WriteString[file, 
                  "Call IntegrateGaugeSS(Boson4, mass, coup2, deltaM, epsI,"<>
                    name<>","<>name2<>", resR, check) \n"];
                fac=2.*relativeFactor;
                
                WriteString[file,
                  "resC = "<>ToString[FortranForm[fac]]<>"*resR \n"];,
                
                WriteString[file, 
                  "Call IntegrateGaugeST(Boson4, mass, coup2, deltaM, epsI,"<>
                    name<>","<>name2<>", resC, check) \n"];
                fac=-2.;
                
                WriteString[file,
                  "resC = "<>ToString[FortranForm[fac]]<>"*resC \n"];
                ];,
            If[f1b=== f1a,
                
                WriteString[file, 
                  "Call IntegrateGaugeSscalarS(Boson4, mass, coup2, deltaM, epsI,"<>
                    name<>","<>name2<>", resC, check) \n"];
                fac=2.*relativeFactor;
                
                WriteString[file,
                  "resC = "<>ToString[FortranForm[fac]]<>"*resC \n"];,
                If[AntiField[particle]=!=particle,
                  If[f2b===f2,
                      fac=-2.;
                      WriteString[file, "coupT = coup2(7) \n"];
                      WriteString[file, "coup2(7) = coup2(8) \n"];
                      WriteString[file, "coup2(8) = coupT \n"];,
                      fac =2;
                      WriteString[file, "coupT = coup2(2) \n"];
                      WriteString[file, "coup2(2) = coup2(1) \n"];
                      WriteString[file, "coup2(1) = coupT \n"];
                      ];,
                  If[f2b===f2,
                      fac=2.;
                      WriteString[file, "coupT = coup2(5) \n"];
                      WriteString[file, "coup2(5) = coup2(6) \n"];
                      WriteString[file, "coup2(6) = coupT \n"];,
                      fac =-2;
                      ];
                  ];
                
                WriteString[file, 
                  "Call IntegrateGaugeSscalarT(Boson4, mass, coup2, deltaM, epsI,"<>
                    name<>","<>name2<>", resC, check) \n"];
                (* fac=-2.*relativeFactor; *)
                
                
                WriteString[file,
                  "resC = "<>ToString[FortranForm[fac]]<>"*resC \n"];
                ];
            ];
        ];
      
      MakeSymmFactorPart[{f1 /. {One[x_]\[Rule]x, Two[x_]\[Rule]x, 
              Three[x_]\[Rule]x},
          n1},{f2/. {One[x_]\[Rule]x, Two[x_]\[Rule]x, Three[x_]\[Rule]x},
          n2},{f3/. {One[x_]\[Rule]x, Two[x_]\[Rule]x, Three[x_]\[Rule]x},n3},
        "resC",file];
      
      WriteString[file, "resS = resS + resC \n"];
      
      ];


NumberOfDiagrams[list_]:=Block[{i,temp},
      temp=0;
      For[i=1,i\[LessEqual]Length[list],
        temp +=getGenSPheno[Propagator/. list[[i]]];
        i++;];
      
      Return[temp^2];
      ];


MakeSymmFactorPart[{p1_,n1_},{p2_,n2_},{p3_,n3_},string_,file_]:=Block[{},
      If[p1===p2===p3,
          
          WriteString[file,
            "If (("<>ToString[n1]<>".Eq."<>ToString[n2]<>").And.("<>
              ToString[n2]<>".Eq."<>ToString[n3]<>")) Then \n"];
          WriteString[file,string <>"="<>string<>"/6._dp\n"];
          
          WriteString[file,
            "Else If (("<>ToString[n1]<>".Eq."<>ToString[n2]<>").Or.("<>
              ToString[n2]<>".Eq."<>ToString[n3]<>").Or.("<>ToString[n1]<>".Eq."<>
              ToString[n3]<>")) Then\n"];
          	  WriteString[file,string<>"="<> string <>"/2._dp \n"];
          WriteString[file,"End If\n"];,
          If[p1===p2,
              
              WriteString[file,
                "If ("<>ToString[n1]<>".Eq."<>ToString[n2]<>") Then \n"];
              WriteString[file,string<>"="<> string <>"/2._dp \n"];
              WriteString[file,"End If\n"];,
              If[p1===p3,
                  
                  WriteString[file,
                    "If ("<>ToString[n1]<>".Eq."<>ToString[n3]<>") Then \n"];
                  WriteString[file,string<>"="<> string <>"/2._dp \n"];
                  WriteString[file,"End If\n"];,
                  If[p2===p3,
                      
                      WriteString[file,
                        "If ("<>ToString[n3]<>".Eq."<>ToString[n2]<>
                          ") Then \n"];
                      WriteString[file,string<>"="<> string <>"/2._dp \n"];
                      WriteString[file,"End If\n"];
                      ];
                  ];
              ];
          ];
      
      
      ];