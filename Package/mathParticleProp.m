(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)


(* ------------------------------------*)
(* Zeros                            \
   *)
(* ------------------------------------*)

SetAttributes[conj,Constant];
SetAttributes[bar,Constant];
SetAttributes[Mom,Constant];
SetAttributes[sum,Constant];
SetAttributes[GetGen,Constant];
SetAttributes[GetGenStart,Constant];

conj[a_][b__]:=conj[a[b]]; 
NoEffect[x_]=x;

SA`Casimir[x_,y_]:=
  SA`Casimir[(x /. diracSub)[[1]],y] /; FreeQ[diracFermion,x]\[Equal]False
SA`Dynkin[x_,y_]:=
  SA`Dynkin[(x/. diracSub)[[1]],y] /;
    FreeQ[Transpose[dirac][[1]],x]\[Equal]False

 
pmue[0]=0;
Mom[0,_]=0;

nix[___]:=0;
zero[a_][b_]:=zero[a[b]];

Mom[zero[a_],l_]:=Mom[a,l];
Mass[zero[a_]]:=Mass[a];
Mass[x_]:=0 /; (FreeQ[massless,x]\[Equal]False && Head[x]=!=Pattern);
Mass[x_conj]:=Mass[RE[x]];
Mass[a_]:=Mass[(a /. {zero[x_]\[Rule]x})] /; FreeQ[a,zero]\[Equal]False
vacHead[x_]:= Return[x\[Rule]zero[x]];




(* ----------------------- *)
(* 
  Group Properties *)
(* ----------------------- *)

v[j_,m_]:=1/Sqrt[2 m (m+1)] (Sum[Delta[j,k],{k,1,m}]-m Delta[j,m+1]);
vec[k_,n_]:=Table[v[k,i],{i,1,n-1}];
weight[i_,n_]:=Sum[vec[k,n],{k,1,i}];

SA`Casimir[vector_]:=
    Sum[weight[i,Length[vector]+1] vector[[i]],{i,1,
          Length[vector]}].(Sum[
            weight[i,Length[vector]+1] vector[[i]],{i,1,
              Length[vector]}]+2 Sum[
              weight[i,Length[vector]+1],{i,1,Length[vector]}]);

YoungTableaux[rows_,N_]:=
    Block[{p,q,i,j,k, DynkinVector,hook,columns,cas,dimm},
      dimm=1;
      For[i=1,i\[LessEqual]Length[rows],
        For[j=1,j\[LessEqual]rows[[i]],
          hook=rows[[i]]-j+1;
          For[k=i+1,k\[LessEqual]Length[rows],
            If[rows[[k]]\[GreaterEqual]j,hook++;];
            k++;];
          distance=-i+j;
          dimm=dimm*(N+distance)/hook;
          j++;];
        i++;];
      p=0;
      q=0;
      columns=Table[1,{i,1,rows[[1]]}];
      For[i=2,i\[LessEqual]Length[rows],
        For[k=1,k\[LessEqual]rows[[i]],
          columns[[k]]=columns[[k]]+1;
          k++;];
        i++;];
      
      For[i=1,i\[LessEqual]Length[columns],
        If[columns[[i]]\[Equal]1,p++;,
          q=q+(N-columns[[i]]);];
        i++;];
      saveRows=rows;
      DynkinVector={};
      rowLengthOld=rows[[1]];
      For[i=2,i\[LessEqual]N,
        If[Length[rows]<i,rowLength=0;,rowLength=rows[[i]];];
        DynkinVector=Join[DynkinVector,{rowLengthOld-rowLength}];
        rowLengthOld=rowLength;
        i++;];
      cas=Simplify[SA`Casimir[DynkinVector]];
      Return[{dimm,p,q,cas,cas*dimm/(N^2-1), DynkinVector}];
      ];

FieldDim[field_,gauge_]:=Block[{},
      If[Head[Fields[[field,gauge+3]]]===List,
          Return[Fields[[field,gauge+3,1]]];,
          Return[Fields[[field,gauge+3]]];
          ];
      ];

CalculateDynkinAndCasimir[gauge_,dim_]:=Block[{i,temp55},
      If[Gauge[[gauge,2]]===U[1],
          temp55=CheckIrrepSUN[dim,1];
          Return[{GUTren[gauge]^2*temp55[[4]],GUTren[gauge]^2*temp55[[5]]}];,
          If[dim===1,
              Return[{0,0}];,
              temp55=CheckIrrepSUN[dim,Gauge[[gauge,2]][[1]]];
              Return[{temp55[[4]],temp55[[5]]}];
              ];
          ];
      ];


MakeInteractionListRGE[SP_]:=
    Block[{i,j,k,PM,listNew= {},SymmetryFactor=1,tempList,pos,pos2,symmetric,
        tempsub,nfac,rtemp},
      If[Length[SP[[1]]]\[Equal]2,
        GivenIndexStructure=MakeIndexStructure[SP[[2]] ];,
        GivenIndexStructure=SP[[1,3]];
        ];
      
      
      PM=Permutations[Table[i,{i,1,Length[SP[[2]]]}]];
      
      tempList = 
        Table[{Table[
              parts[[PM[[j,i]]]],{i,1,
                Length[SP[[2]]]}],{SP[[1,
                  1]],(GivenIndexStructure genTest[SP[[1,2]],SP[[2]],
                      False] /.  
                  Flatten[
                    Table[subGCRE[i,Position[PM[[j]],i][[1,1]]],{i,1,
                        Length[SP[[2]]]}]] )}},{j,1,Length[PM]}];
      symmetric=Intersection[Select[SP[[2]],(Count[SP[[2]],#1]>1)&]];
      
      If[Length[symmetric]>0,
        pos = 
          Table[Position[SP[[2]],symmetric[[i]]],{i,1,Length[symmetric]}];
        SymmetryFactor = 
          Times@@Table[Factorial[Length[pos[[i]]]],{i,1,Length[pos]}];
        PMC = 
          PM /. Flatten[
              Table[Table[
                  pos[[j,i,1]]\[Rule]iAdd[j],{i,1,Length[pos[[j]]]}],{j,1,
                  Length[pos]}]];
        PMF = Intersection[PMC];
        For[j=1,j\[LessEqual]Length[PMF],
          pos2=Position[PMC,PMF[[j]]];
           
          listNew = 
            Join[listNew,{{tempList[[pos2[[1,1]],
                      1]],{tempList[[pos2[[1,1]],2,1]],
                    Sum[tempList[[pos2[[k,1]],2,2]],{k,1,Length[pos2]}]}}}]; 
          j++;];,
        listNew = tempList;
        ];
      
      tempList[[1,2,1]]=tempList[[1,2,1]]*SymmetryFactor;
      
      Return[{(tempList[[1]]),listNew}];
      ];


CheckIrrepSUN[x_,1]:={x,0,0,x^2,x^2,{1}};
CheckIrrepSUN[a_,b_]:=TestDim[a,b];
CheckIrrepSUN[{a_,b_},c_]:=TestDim[{a,b},c];


TestDim[dim_,N_]:=Block[{height, max},
      correctTableaux=False; height=1; max=N;
      While[height\[LessEqual]N-1&&correctTableaux\[Equal]False,
        AddRow[10 N,1,height,{},dim,N];
        height++;];
      If[Ytab[[2]]\[Equal]0 && Ytab[[3]] > N/2,Ytab[[2]]=N-Ytab[[3]]; 
        Ytab[[3]]=0];
      Return[Ytab];
      ];

TestDim[{dim_,dyn_},N_]:=Block[{height, max},
      correctTableaux=False;height=1;max=N;
      While[height\[LessEqual]N-1&&correctTableaux\[Equal]False,
        AddRow[10 N,1,height,{},dim,dyn,N];
        height++;];
      If[Ytab[[2]]\[Equal]0 && Ytab[[3]] > N/2,Ytab[[2]]=N-Ytab[[3]]; 
        Ytab[[3]]=0];
      Return[Ytab];
      ];


AddRow[max_,height_,maxheight_,tableaux_,dim_,dyn_,N_]:=Block[{i},
      i=1;
      While[i\[LessEqual]max&&correctTableaux\[Equal]False,
        tab=Join[tableaux,{i}];
        If[height\[Equal]maxheight,
          Ytab=YoungTableaux[tab,N];
          If[Ytab[[1]]\[Equal]dim &&  Ytab[[6]]\[Equal]dyn,
            correctTableaux=True;
            ];,
          AddRow[i,height+1,maxheight,tab,dim,dyn,N];
          ];
        i++];
      ];

AddRow[max_,height_,maxheight_,tableaux_,dim_,N_]:=Block[{i},
      i=1;
      While[i\[LessEqual]max&&correctTableaux\[Equal]False,
        tab=Join[tableaux,{i}];
        If[height\[Equal]maxheight,
          Ytab=YoungTableaux[tab,N];
          If[Ytab[[1]]\[Equal]dim,correctTableaux=True;];,
          AddRow[i,height+1,maxheight,tab,dim,N];
          ];
        i++];
      ];


ExistingGenerators={};
SA`CasimirList={};
Traceless={};

MakeGroupConstants[fieldNr_,gaugeNr_,p_,q_,casimir_,dyn___]:=
    Block[{dynkin,dimIrrep,k},
      k=gaugeNr+3;
      dimIrrep=Abs[FieldDim[fieldNr,gaugeNr]];
      If[FreeQ[ExistingGenerators,{gaugeNr,dimIrrep}]\[Equal]True,
        MakeGenerator[gaugeNr, dimIrrep,p,q];
        ExistingGenerators = Join[ExistingGenerators,{{k-3,dimIrrep}}];
        ];
      If[Gauge[[gaugeNr,6]]<(p+q),Gauge[[gaugeNr,6]]=(p+q);];
      
      If[ValueQ[dyn]=!=ValueQ[],
        dynkin =dyn;,
        dynkin=casimir*dimIrrep/(Gauge[[gaugeNr,2,1]]^2-1);
        ];
      SA`CasimirList=Join[SA`CasimirList,{{fieldNr,gaugeNr,casimir,dynkin}}];
      ];

MakeGenerator[gaugeNr_,dim_,cov_,con_]:=Block[{temp,temp2,i,j,complete},
      complete=cov+con;
       (* dimGauge=Gauge[[gaugeNr,2,1]];  *)
       
      dimGauge=Gauge[[gaugeNr,2]]; 
       temp = 
        Plus@@Table[(Hold[TA[DIMGAUGE,genf[lor],
                            listIndizes[[GAUGE,NR]]/.subGC[p1],
                            listIndizes[[GAUGE,NR]]/.subGC[
                                p2]]]/.NR\[Rule]i/.GAUGE\[Rule]gaugeNr/.\
DIMGAUGE\[Rule]dimGauge)Product[
                  If[j\[Equal]i,
                    1,(Hold[Delta[listIndizes[[GAUGE,NR]]/.subGC[p1],
                              listIndizes[[GAUGE,NR]]/.subGC[
                                  p2]]]/.NR\[Rule]j/.GAUGE\[Rule]gaugeNr)],{j,
                    1,complete}],{i,1,cov}]-
          
          Plus@@Table[(Hold[
                          TA[DIMGAUGE,genf[lor],
                            listIndizes[[GAUGE,NR]]/.subGC[p2],
                            listIndizes[[GAUGE,NR]]/.subGC[
                                p1]]]/.NR\[Rule]i/.GAUGE\[Rule]gaugeNr/.\
DIMGAUGE\[Rule]dimGauge)Product[
                  If[j\[Equal]i,
                    1,(Hold[Delta[listIndizes[[GAUGE,NR]]/.subGC[p1],
                              listIndizes[[GAUGE,NR]]/.subGC[
                                  p2]]]/.NR\[Rule]j/.GAUGE\[Rule]gaugeNr)],{j,
                    1,complete}],{i,cov+1,complete}]; 
      
      Generator[dimGauge,gaugeNr,dim,lor_,p1_,p2_]=temp;
      ];

TestTraceless[Nr_]:=Block[{k},
      tless=True;
      For[k=1,k\[LessEqual]AnzahlGauge,
        If[(FieldDim[Nr,k]=!=1 ) && (FieldDim[Nr,k] =!= 
                Gauge[[k,2,1]]^2-1) && (Gauge[[k,2]]=!=U[1]),
          tless=False;,
          If[FieldDim[Nr,k]=!=0 && Gauge[[k,2]]===U[1],
              tless=False;
              ];
          ];
        k++;];
      Return[tless];
      ];

GenerateAllIndizes[Nr_]:=Block[{i,j,k,l,m,n,res,states,templ,resSusyno},
      notExpanded={generation}; expanded={};
      notShort={generation}; expShort={};
      
      For[k=1,k\[LessEqual]AnzahlGauge,
        temp={};
        If[Head[Gauge[[k,2]]]===U || Head[Gauge[[k,2]]]===SU,
          If[FieldDim[Nr,k]=!=1 && Gauge[[k,2]]=!=U[1],
              searchedDim=FieldDim[Nr,k];
              Switch[searchedDim,
                Gauge[[k,2,1]],
                	temp= {Gauge[[k,3]]};
                	
                MakeGroupConstants[Nr,k,1,
                  0,(Gauge[[k,2,1]]^2-1)/(2 Gauge[[k,2,1]])];,
                Gauge[[k,2,1]]^2-1, 
                	temp= {Gauge[[k,3]],-Gauge[[k,3]]};
                	MakeGroupConstants[Nr,k,1,1,Gauge[[k,2,1]]];
                	If[TestTraceless[Nr]\[Equal]True,
                  	
                  Traceless=
                      Join[Traceless,{{Nr,(Gauge[[k,2,1]]^2-1)/(Gauge[[k,2,
                                      1]]^2)}}];
                  	];,
                _, 
                	If[Head[Fields[[Nr,k]]]===List,
                  	res=TestDim[Abs/@Fields[[Nr,k+3]],Gauge[[k,2,1]]];,
                  	res=TestDim[Abs[Fields[[Nr,k+3]]],Gauge[[k,2,1]]];
                  	];
                	
                temp=Join[Table[Gauge[[k,3]],{res[[2]]}],
                    Table[-Gauge[[k,3]],{res[[3]]}]];
                	MakeGroupConstants[Nr,k,res[[2]],res[[3]],res[[4]]];
                 ];
              
              For[i=1,i\[LessEqual]Length[temp],
                If[Gauge[[k,5]]\[Equal]False,
                  
                  notShort = 
                      Join[notShort,{ToExpression[
                            ToString[temp[[i]]]<>appendIndex[[i]]]}];,
                  
                  expShort = 
                      Join[expShort,{ToExpression[
                            ToString[temp[[i]]]<>appendIndex[[i]]]}];
                  ];
                i++;];
              
              
              If[FieldDim[Nr,k]<0 && Head[Fields[[Nr,k+3]]]=!=List, 
                temp = - temp;];
              
              If[Gauge[[k,5]]\[Equal]False,
                notExpanded=Join[notExpanded,temp];,
                expanded=Join[expanded,temp];
                ];,
              If[Gauge[[k,2]]===U[1],
                  
                  SA`CasimirList = 
                    Join[SA`CasimirList,{{Nr,k,FieldDim[Nr,k]^2 GUTren[k]^2,
                          FieldDim[Nr,k]^2 GUTren[k]^2}}];
                  If[NumericQ[FieldDim[Nr,k]]\[Equal]False, 
                    templ =Cases[{FieldDim[Nr,k]},x_Symbol,4];
                    For[i=1,i\[LessEqual]Length[templ],
                      If[FreeQ[parameters,templ[[i]]], 
                        parameters=Join[parameters,{{templ[[i]],{},{}}}];
                        UnfixedCharges = Join[UnfixedCharges,{templ[[i]]}];
                        realVar = Join[realVar,{templ[[i]]}];
                        ];
                      i++;];
                    ];,
                  SA`CasimirList = Join[SA`CasimirList,{{Nr,k,0,0}}];
                  ];
              ];,
          
          GetInformationSusyno[Nr,k];
          
          ];
        k++;];
      
      
      MultiplicityList[[Nr]] = 
        Join[MultiplicityList[[Nr]],
          Table[Product[
              If[i\[NotEqual]j && Gauge[[j,2]]=!=U[1] && FieldDim[Nr,j]=!=1 && 
                  Gauge[[j,5]]=!=True,Abs[FieldDim[Nr,j]],1],{j,1,
                AnzahlGauge}], {i,1,AnzahlGauge}]];
      
      notShort = DeleteCases[notShort,x_?NumericQ,3];
      expShort = DeleteCases[expShort,x_?NumericQ,3];
      
      Return[{notExpanded,expanded, notShort,expShort}];
      
      ];


testM=Module[{n,result,k,checkvariableexistsModule},print[nix];];





(* ------------------------------------*)
(* Momentum                         \
   *)
(* ------------------------------------*)


Deri[x_,l_]:=Block[{erg, erg2},
      If[Head[x] \[Equal] List,
        erg = List@@x;
        erg2 = Deri/@Table[{erg[[i]],l},{i,1,Length[erg]}];
        Return[List@@erg2/.a_[{b_,c_}]\[Rule]a[b,c]];
        ];
      Return[Der[x,l]];
      ];


Der[x_,lor_]:=Block[{erg,erg2},
      If[Head[x]\[Equal] List,erg = List@@x;
        erg2= Table[Der[erg[[i]],lor],{i,1,Length[erg]}];
        Return[List@@erg2];];
      If[Head[x]\[Equal]Plus,erg=List@@x;
        erg2=Table[Der[erg[[i]],lor],{i,1,Length[erg]}];
        Return[Plus@@erg2];]; 
      If[Head[x]\[Equal]Times,erg=List@@x;
        erg2=Table[Der[erg[[i]],lor],{i,1,Length[erg]}];Return[Times@@erg2]];
      If[Head[x]\[Equal]Power,Return[x];];
      If[Head[x]\[Equal]sum,Return[x];];
      If[Head[x]\[Equal]Integer,Return[x];];
      If[Head[x]\[Equal]Sin,Return[x];];
      If[Head[x]\[Equal]Cos,Return[x];];
      If[Head[x]\[Equal]Delta,Return[x];];
      If[Head[x]\[Equal]repl,Return[x];];
      If[Head[x]\[Equal]Rational,Return[x];];
      If[Head[x]\[Equal]Complex,Return[x];];
      
      If[Head[x] \[Equal] conj,
        If[FreeQ[Particles[Current],Head[x[[1]]]]\[Equal]False,
            If[getType[x[[1]]]=!=G,
                Return[x Mom[x,lor]];,
                Return[x];
                ];,
            Return[x];
            ];
        ];
      
      If[FreeQ[Particles[Current],Head[x]]\[Equal]False,
        If[getType[x]=!=G,
            Return[x Mom[x,lor]];,
            Return[x];
            ];,
        Return[x];
        ];
      ] /; (CalcImp \[Equal] True || Head[x]\[Equal]List || 
          Head[x]\[Equal]Plus || Head[x]\[Equal]Times || 
          Head[x]\[Equal]Power || Head[x]\[Equal]repl) && (Head[x]=!=DeltaGT)

Mom[x_,l_]:=Mom[x /. zero[y_]\[Rule]y,l] /;FreeQ[x,zero]== False; 

(* ------------------------------------------- *)
(* 
  Generation Handling *)
(* ------------------------------------------- *)


replaceGen[x_,nr_] :=Block[{i,temp},
      temp=x;
      For[i=1,i\[LessEqual]genMax,
        temp=( (D[temp,repl[genf[i]]] /. genf[i]\[Rule]intf[nr,i]) + temp) /. 
            repl[genf[i]]\[Rule]0;
        i++;];
      
      temp=
        temp/.{ n1\[Rule]gen1,n2\[Rule]gen2,n3\[Rule]gen3,n4\[Rule]gen4,
                  n5\[Rule]gen5,n6\[Rule]gen6} /. 
              Mom[repl[a_]]\[Rule]1 /.repl[a_]\[Rule]1  /. Mom[1]\[Rule]1 ;
      
      Return[temp];
      ];

repl[1]:=1;

CheckOne:=Block[{part,i,j,k,liste1,liste2,listen},
      listen={Particles[ALL],Particles[Current]};
      ParticleListOneGeneration={};
      
      For[i=1,i\[LessEqual]Length[NameOfStates],
        listen=Join[listen,{ParticlesTemp[NameOfStates[[i]]]}];
        i++;
        ];
      
      For[j=1,j\[LessEqual]Length[listen],
        For[i=1,i\[LessEqual]Length[listen[[j]]],
          If[listen[[j,i,4]]===VEV && listen[[j,i,3]]>1, 
            listen[[j,i,1]][{a__}]=listen[[j,i,1]][a];
            ];
          
          If[listen[[j,i,3]]==1 &&  
              FreeQ[listen[[j,i,5]],generation]\[Equal]False,
            Clear[part];
            If[Length[listen[[j,i,5]]]\[Equal]1,
              
              ReleaseHold[
                ReplaceAll[Hold[SetDelayed[part[{a_}],part]] , 
                  part\[Rule]listen[[j,i,1]]]];
              
              If[FreeQ[ParticleListOneGeneration,listen[[j,i,1]]]\[Equal]
                  True,
                
                ParticleListOneGeneration=
                    Join[ParticleListOneGeneration,{{listen[[j,i,1]],One}}];
                ];,
              
              ReleaseHold[
                ReplaceAll[
                  Hold[SetDelayed[part[liste1],part[liste2]]], {part\[Rule]
                      listen[[j,i,1]],
                    liste1\[Rule] 
                      Table[ToExpression["a"<>ToString[k]<>"_"],{k,1,
                          Length[listen[[j,i,5]]]}],
                    liste2->Table[
                        ToExpression["a"<>ToString[k]],{k,2,
                          Length[listen[[j,i,5]]]}]}]];
              
              If[FreeQ[ParticleListOneGeneration,listen[[j,i,1]]]\[Equal]
                  True,
                
                ParticleListOneGeneration=
                    Join[ParticleListOneGeneration,{{listen[[j,i,1]],
                          Table[ToExpression["a"<>ToString[k]<>"_"],{k,1,
                              Length[listen[[j,i,5]]]}]}}];
                ];
              ];
              
            listen[[j,i,5]]=DeleteCases[listen[[j,i,5]], generation,2];
            ];
          i++;
          ];
        j++;];
      
      For[i=1,i\[LessEqual]Length[listen],
        listen[[i]] = DeleteCases[listen[[i]],x_?deletedTotal];
        i++;];
      
      
      Particles[ALL]=listen[[1]];Particles[Current]=listen[[2]];
      
      
      
      For[i=1,i\[LessEqual]Length[NameOfStates],
        Particles[NameOfStates[[i]]]=listen[[i+2]];
        i++;
        ];
      
      OnesChecked=True;
      ];

deletedTotal[x_]:=If[x[[2]]>x[[3]], Return[True];,Return[False];];



(* ------------------------------------------- *)
(* 
  Particle Insertion *)
(* ------------------------------------------- *)

FieldQ[x_]:=
    If[MemberQ[Transpose[ListFields][[1]],x],Return[True];,Return[False];];
ParticleQ[x_]:=
    If[MemberQ[vacuum,x] || MemberQ[vacuum,Head[x]],Return[True];,
      Return[False]];
LorentzQ[x_]:= 
    If[FreeQ[x,lt1] &&  FreeQ[x,lt2] && FreeQ[x,lt3] && FreeQ[x,lt4],
      Return[False];,Return[True];];

part[particle_,nr_]:=Block[{res,sub,i,temp,ind,sumStates,nonSUN,pos,pos2},
      ind=Cases[RE[particle],x_?ListQ,2][[1]];
      (* 
        nonSUN = Select[ind,(MemberQ[NonSUNindices,#])&];
        ind = Select[ind,(FreeQ[NonSUNindices,#])&]; 
        sumNonSUN=1;
        For[i=1,i\[LessEqual]Length[nonSUN],
          pos2=Position[{SFields,AFields,FFields},Fq][[1,2]];
          pos=Position[Gauge,nonSUN][[1,1]];
          sumNonSUN=sumNonSUN*sum[nonSUN[[i]],1,Fields[[pos2,3+pos]][[1]]];
          i++;];
        *)
      temp = particle /. subGC[nr];
      If[ind=!={},
        sumStates = 
            Product[If[ind[[i]]=!= generation && ind[[i]] =!=lorentz,
                sum[ind[[i]] /. subGC[nr],1,NumberStates[ind[[i]],particle]],
                1],{i,1,Length[ind]}];,
        sumStates=1;
        ];
      If[getType[particle,True]===F,
        Return[
            temp[nr]*sumStates*
              sum[genf[nr],GetGenStart[particle[1] /. subGC[nr]],
                GetGen[particle[1] /. subGC[nr]]]];, 
        Return[
            temp*sumStates*
              sum[genf[nr],GetGenStart[particle /. subGC[nr]],
                GetGen[particle /. subGC[nr]]]]; 
        ];
      ];

partBlank[particle_,nr_]:=Block[{res,sub,i,temp,ind,sumStates},
      temp=RE[particle];
      sumStates=1;
      ind=getIndizes[temp];
      
      temp = getFull[particle] /. subGC[nr];
      
      If[getType[particle]===F,
        If[Head[RE[particle]]===List,
            temp[[1]] = temp[[1]][nr];
            temp[[2]] = temp[[2]][nr];,
            temp = temp[nr];
            ];
        ];
      
      For[i=1,i\[LessEqual]Length[ind],
        If[ind[[i]]=!= generation && ind[[i]] =!=lorentz,
          
          sumStates=
              sumStates*
                sum[ToExpression[
                    StringTake[ToString[ind[[i]]],3]<>ToString[nr]],1,
                  getNumberStates[ind[[i]]]];
          ];
        i++;
        ];
      
      If[Head[RE[particle]]===List,
        res = {temp[[1]]*sumStates*
                sum[genf[nr],GetGenStart[RE[particle][[1]]],
                  GetGen[RE[particle][[1]]]],
              temp[[2]]*sumStates*
                sum[genf[nr],GetGenStart[RE[particle][[2]]],
                  GetGen[RE[particle][[2]]]]};,
        res = 
            temp*sumStates*
              sum[genf[nr],GetGenStart[RE[particle]],GetGen[RE[particle]]]; 
        ];
      
      Return[res];
      ];


addParticle[name_, ind_, gens_,type_,fla___]:=Block[{},
      Particles[Current] = 
        Join[Particles[Current],{{name,1, gens,type,ind,fla}}];
      Particles[ALL] = Join[Particles[ALL],{{name,1, gens,type,ind,fla}}];
      
      If[type=!=VEV,
        vacuum=Join[vacuum,{name}];
        Switch[type,
          F, vacuumF=Join[vacuumF,{name\[Rule]zero[name]}];,
          S, vacuumS=Join[vacuumS,{name\[Rule]zero[name]}];,
          V, vacuumV=Join[vacuumV,{name\[Rule]zero[name]}];,
          G, vacuumG=Join[vacuumG,{name\[Rule]zero[name]}];,
          A, vacuumA=Join[vacuumA,{name\[Rule]zero[name]}];
          ];
        ];
      
      ];

delParticle[part_]:=Block[{pos},
      If[FreeQ[Particles[Current],part]\[Equal]False,
          pos =Position[Particles[Current],RE[part]][[1,1]];
          Particles[Current]=Delete[Particles[Current],pos];
          ];
      ];

makeDelta[listP_, skip_]:=Block[{i,j,k,res, listIndices,listIndicesNoSUN},
      listIndices =
        MapIndexed[
          If[getGen[listP[[#2[[1]],1]]]==1,DeleteCases[#1,generation,4],#1]&, 
          DeleteCases[Table[getIndizes[listP[[i,1]]],{i,1,Length[listP]}],
            x_/; MemberQ[skip,x],4]];
      Return[
        Product[Times@@
            Map[Delta[#1 /. subGC[listP[[i,2]]],#1/. subGC[listP[[j,2]]]]&,
              Intersection[listIndices[[i]],listIndices[[j]]] ],{i,1,
            Length[listP]-1},{j,i+1,Length[listP]}]];
      ];

(*
  makeDelta[listP_, skip_]:=
      Block[{i,j,k,res, listIndices,listIndicesNoSUN},
        listIndices =
          MapIndexed[
            If[getGen[listP[[#2[[1]],1]]]==1,
                DeleteCases[#1,generation,4],#1]&, 
            DeleteCases[Table[getIndizes[listP[[i,1]]],{i,1,Length[listP]}],
              x_/; MemberQ[skip,x],4]];
        listIndicesNoSUN=
          DeleteCases[listIndices,
            DeleteCases[test,_?((FreeQ[NonSUNindices,#]&&Head[#]=!=List)&),
              3]];
        listIndices=
          DeleteCases[listIndices,
            DeleteCases[test,_?((MemberQ[NonSUNindices,#]&&Head[#]=!=List)&),
              3]];
        Return[
          Product[Times@@
              Map[Delta[#1 /. subGC[listP[[i,2]]],#1/. subGC[listP[[j,2]]]]&,
                Intersection[listIndices[[i]],listIndices[[j]]] ],{i,1,
              Length[listP]-1},{j,i+1,Length[listP]}]];
        ];
  *)


makeDelta[particleNr_,nr1_,nr2_, skip_]:=
    Block[{i,j,k,res, deltas, list,SKIP,gnr},
      If[particleNr > Length[Fields],Return[0];];
      SKIP=skip;
      If[Extract[Fields,particleNr][[2]]\[Equal]1,
        SKIP = Join[SKIP,{generations}];
        ];
      deltas = 1;
      
      listNames = 
        Join[ListFields[[particleNr,2,1]],ListFields[[particleNr,3,1]]];
      listTypes = 
        DeleteCases[
          Join[ListFields[[particleNr,2,2]],ListFields[[particleNr,3,2]]],
          x_?NumericQ,3];
      
      For[i=1,i\[LessEqual]Length[listNames],
        If[FreeQ[SKIP,listTypes[[i]]]\[Equal]True,
          (* If[FreeQ[NonSUNindices,listTypes[[i]]], *)
          
          deltas = 
              deltas* Delta[listNames[[i]] /. subGC[nr1],
                  listNames[[i]] /. subGC[nr2]]; (*,
                gnr=Position[Gauge,listTypes[[i]]][[1,1]];
                
                deltas = 
                    deltas*RM[Gauge[[gnr,2]],FieldDim[particleNr,gnr],
                          DynkinLabels[Gauge[[gnr,2]],
                            Fields[[particleNr,3]]]][
                        listNames[[i]] /. subGC[nr1],
                        listNames[[i]] /. subGC[nr2]];
                ]; *)
          ];
        i++;];
      Return[deltas];
      ];




MakeIndexStructure[partList_]:=Block[{i,j,k,l,pos,pos2,temp,dyn,ind},
      IndexTypes = {};
      IndexTypesNonSUN = {};
      IndexNames=Table[{},{Length[partList]}];
      IndexFull = Table[{},{Length[partList]}];
      IndexNamesNonSUN = Table[{},{Length[partList]}];
      
      For[i=1,i\[LessEqual]Length[partList],
        pos=Position[ListFields,RE[partList[[i]]]][[1,1]];
        IndexTypes = 
          Join[IndexTypes,
            Select[ListFields[[pos,2,2]],(FreeQ[NonSUNindices,#])&]];
        IndexTypes = 
          Join[IndexTypes,
            Select[ListFields[[pos,3,2]],(FreeQ[NonSUNindices,#])&]];
        IndexTypesNonSUN = 
          Join[IndexTypesNonSUN,
            Select[ListFields[[pos,2,2]],(MemberQ[NonSUNindices,#])&]];
        IndexTypesNonSUN = 
          Join[IndexTypesNonSUN,
            Select[ListFields[[pos,3,2]],(MemberQ[NonSUNindices,#])&]];
        IndexNames[[i]] = 
          Join[IndexNames[[i]],
            Select[ListFields[[pos,2,1]],(FreeQ[NonSUNindices,#])&] /. 
              subGC[i]];
        IndexNames[[i]] = 
          Join[IndexNames[[i]],
            Select[ListFields[[pos,3,1]],(FreeQ[NonSUNindices,#])&]/. 
              subGC[i]];
        IndexNamesNonSUN[[i]] = 
          Join[IndexNames[[i]],
            Select[ListFields[[pos,2,1]],(MemberQ[NonSUNindices,#])&] /. 
              subGC[i]];
        IndexNamesNonSUN[[i]] = 
          Join[IndexNames[[i]],
            Select[ListFields[[pos,3,1]],(MemberQ[NonSUNindices,#])&]/. 
              subGC[i]];
        
        If[Head[partList[[i]]]===conj,
          
          IndexFull[[i]] = 
            Join[IndexFull[[i]],-Select[
                  ListFields[[pos,2,2]],(FreeQ[NonSUNindices,#])&]];
          
          IndexFull[[i]] = 
            Join[IndexFull[[i]],-Select[
                  ListFields[[pos,3,2]],(FreeQ[NonSUNindices,#])&]];,
          
          IndexFull[[i]] = 
            Join[IndexFull[[i]],
              Select[ListFields[[pos,2,2]],(FreeQ[NonSUNindices,#])&]];
          
          IndexFull[[i]] = 
            Join[IndexFull[[i]],
              Select[ListFields[[pos,3,2]],(FreeQ[NonSUNindices,#])&]];
          ];
        i++;];
      
      IndexTypes=
        DeleteCases[Intersection[DeleteCases[IndexTypes,x_?NumericQ,5]],
          generation];
      
      resNonSUN=
        GeneratInvariantMatrixSusyno[Intersection[IndexTypesNonSUN],
          partList];
      
      NeededStructures = Table[{},{Length[IndexTypes]},{Length[partList]}];
      CurrentNumberStates=
        Table[{getNumberStates[IndexTypes[[i]]]},{i,1,Length[IndexTypes]}];
      
      For[i=1,i\[LessEqual]Length[IndexTypes],
        For[j=1,j\[LessEqual]Length[partList],
          For[k=1,k\[LessEqual]Length[IndexNames[[j]]],
            If[FreeQ[IndexFull[[j,k]],IndexTypes[[i]]]\[Equal]False,
              If[Head[IndexFull[[j,k]]]===Times,
                  
                  NeededStructures[[i,j]]=
                      Join[NeededStructures[[i,j]],{Con[
                            IndexNames[[j,k]]]}];,
                  
                  NeededStructures[[i,j]]=
                      Join[NeededStructures[[i,j]],{Cov[IndexNames[[j,k]]]}];
                  ];
              ];
            k++;];
          j++;];
        i++;];
      
      structure=1;
      
      For[i=1,i\[LessEqual]Length[NeededStructures],
        If[Length[NeededStructures[[i]]]>1,
          If[Length[NeededStructures[[i]]]\[Equal]2,
              
              res=ContractIndizes[NeededStructures[[i,1]],
                  NeededStructures[[i,2]]];
              NeededStructures[[i,1]]=res[[1]];
              NeededStructures[[i,2]]=res[[2]];
              structure = structure * res[[3]];,
              
              list1a=Cases[Flatten[NeededStructures[[i,1]]],x_Cov];
              list1b=Cases[Flatten[NeededStructures[[i,1]]],x_Con];
              list2a=Cases[Flatten[NeededStructures[[i,2]]],x_Cov];
              list2b=Cases[Flatten[NeededStructures[[i,2]]],x_Con];
              list3a=Cases[Flatten[NeededStructures[[i,3]]],x_Cov];
              list3b=Cases[Flatten[NeededStructures[[i,3]]],x_Con];
              
              res13=ContractIndizes[list1a,list3b];
              res12=ContractIndizes[list1b,list2a];
              res23=ContractIndizes[list2b,list3a];
              
              NeededStructures[[i,1]]=Join[res13[[1]],res12[[1]]];
              NeededStructures[[i,2]]=Join[res23[[1]],res12[[2]]];
              NeededStructures[[i,3]]=Join[res23[[2]],res13[[2]]];
              
              structure = structure*res12[[3]] res13[[3]]  res23[[3]];
              
              
              
              res=ContractIndizes[NeededStructures[[i,1]],
                  NeededStructures[[i,2]]];
              NeededStructures[[i,1]]=res[[1]];
              NeededStructures[[i,2]]=res[[2]];
              structure = structure * res[[3]];
              
              res=ContractIndizes[NeededStructures[[i,1]],
                  NeededStructures[[i,3]]];
              NeededStructures[[i,1]]=res[[1]];
              NeededStructures[[i,3]]=res[[2]];
              structure = structure * res[[3]];
              
              res=ContractIndizes[NeededStructures[[i,2]],
                  NeededStructures[[i,3]]];
              NeededStructures[[i,2]]=res[[1]];
              NeededStructures[[i,3]]=res[[2]];
              structure = structure * res[[3]];
              
              ];
          ];
        
        
        list1=Cases[Flatten[NeededStructures[[i]]],x_Cov];
        list2=Cases[Flatten[NeededStructures[[i]]],x_Con];
        res=ContractIndizes[list1,list2];
        NeededStructures[[i]]=Join[res[[1]],res[[2]]];
        structure = structure * res[[3]];
        
        
        If[Length[NeededStructures[[i]]]>0,
          
          If[FreeQ[NeededStructures[[i]],Cov,3] ||  
                FreeQ[NeededStructures[[i]],Con,3],
              
              ind=Flatten[
                  NeededStructures[[i]] /. {Cov[x_]\[Rule]x, 
                      Con[x_]\[Rule]x}];
              term=epsTensor[];
              For[j=1,j\[LessEqual]Length[ind],
                term = Append[term,ind[[j]]];
                If[Mod[j,CurrentNumberStates[[i,1]]]\[Equal]0,
                  structure=structure*term;
                  term=epsTensor[];
                  ];
                j++;];
              
              If[Mod[Length[ind],CurrentNumberStates[[i,1]]]=!=0,
                Print["Problem in contracting ",partList];];
              (* structure = structure * term; *)
              ];
          ];
        
        i++;];
      
      Return[structure*resNonSUN];
      
      
      ];

ContractIndizes[a_,b_]:=Block[{i,j},
      tempA=a; tempB=b; term=1;
      For[i=0,i\[LessEqual]Length[a]-1,
        contracted=False;
        j=1;
        While[j\[LessEqual]Length[tempB] && contracted\[Equal]False,
          If[Head[a[[Length[a]-i]]]=!=Head[tempB[[j]]],
              contracted=True;,
              j++;
              ];
          ];
        If[contracted==True,
          
          term = term*(Delta[a[[Length[a]-i]],tempB[[j]]] /. {Cov[x_]\[Rule]x,
                    Con[x_]\[Rule]x});
          tempA = DeleteCases[tempA,a[[Length[a]-i]]];
          tempB = Delete[tempB,j];
          ];
        i++;];
      
      Return[{tempA,tempB,term}];
      ];

SumOverExpandedIndizes[term_,partList_]:=
    SumOverExpandedIndizes[term,partList,False];

SumOverExpandedIndizes[term_,partList_,Matrix_]:=Block[{j,i,temp, temp1,pos},
      IndexNames={};
      For[i=1,i\[LessEqual]Length[partList],
        If[partList[[i]]=!=None,
          pos=Position[ListFields,partList[[i]]][[1,1]];
          For[j=1,j\[LessEqual]Length[ListFields[[pos,2,1]]],
            
            IndexNames = 
              Join[IndexNames,{{ListFields[[pos,2,1,j]] /. subGC[i], 
                    NumberStates[ListFields[[pos,2,1,j]],partList[[i]]]}}];
            j++;];
          ];
        i++;];
      
      
      If[Matrix\[Equal]False,
        temp=term;
        For[i=1, i\[LessEqual]Length[IndexNames],
          
          temp1 =Hold[
                Sum[temp,{iter,1,fin}]] /. {iter \[Rule] IndexNames[[i,1]], 
                fin \[Rule] IndexNames[[i,2]]};
          temp = ReleaseHold[temp1]; 
          i++;];,
        
        temp=term;
        For[i=1, i\[LessEqual]Length[IndexNames],
          temp1=
            Hold[Table[temp,iter]]/.{iter\[Rule] 
                  IndexNames[[Length[IndexNames]-i+1]]};
          temp=ReleaseHold[temp1];
          i++;];
        ];
      
      Return[ReleaseHold[temp]];
      
      ];


(* ------------------------------------------- *)
(* 
  Particle Properties *)
(* ------------------------------------------- *)

(* getGenerator[k_,dim_,lor_,p1_,p2_]:=
          If[Gauge[[k,2]]===U[1],Return[dim];,
            Return[ReleaseHold[Generator[Gauge[[k,2,1]],k,dim,lor,p1,p2]]];];/;
      dim>0; *)
getGenerator[k_,dim_,lor_,p1_,p2_]:=
        If[Gauge[[k,2]]===U[1],Return[dim];,
          Return[ReleaseHold[Generator[Gauge[[k,2]],k,dim,lor,p1,p2]]];];/;
    dim>0;
getGenerator[k_,dim_,lor_,p1_,p2_]:=-getGenerator[k,-dim,lor,p2,p1]/;dim<0;
getStructureConstant[group_,p1_,p2_,p3_]:=Block[{erg},
      If[Gauge[[group,2]]\[Equal]1,Return[0];];
      Set[erg,FST[Gauge[[group,2]]][p1,p2,p3]];
      Return[erg];
      ];
getCoeff[doub_,k_,lNr_,p1_,p2_]:=FieldDim[doub,k];

getIndexRange[x_]:=Block[{i,ind,result},
      ind=getIndizes[x];
      result={};
      For[i=1,i\[LessEqual]Length[ind],
        Switch[ind[[i]],
          lorentz,0;,
          generation,result=Join[result,{{generation,getGen[x]}}];,
          _,result = Join[result,{{ind[[i]],getNumberStates[ind[[i]]]}}];
          ];
        i++;];
      Return[result];
      ];

getScalar[x_]:=ToExpression["S"<>ToString[x]];
getSF[x_]:=Block[{pos,field},
      field = getBlank[x];
      If[FreeQ[SFields,field],
        pos=Position[FFields,field];
        If[pos=!={},
          Return[Fields[[pos[[1,1]]]][[3]]];
          ];,
        pos=Position[SFields,field];
        If[pos=!={},
          Return[Fields[[pos[[1,1]]]][[3]]];
          ];
        ];
      ];


getGhost[VBoson_]:=Block[{},
      If[Head[VBoson]===conj,
          
          Return[ToExpression[
                "g"<>StringDrop[ToString[RE[VBoson]],1]<>"C"]];,
          Return[ToExpression["g"<>StringDrop[ToString[VBoson],1]]];
          ];
      ]; 

getVectorBoson[Ghost_]:=Block[{},
      ghost=ToString[getBlank[Ghost]];
      If[StringTake[ghost,-1]==="C",ghost =StringDrop[ghost,-1];];
       Return[ToExpression["V"<>StringDrop[ghost,1]]];
      ]; 

getAuxScalar[scalar_]:=Block[{},
      If[Head[scalar]===conj,
          Return[
              conj[getFull[
                  ToExpression[
                    "A"<>StringDrop[ToString[getBlank[scalar]],1]]]]];,
          
          Return[getFull[
                ToExpression[
                  "A"<>StringDrop[ToString[getBlank[scalar]],1]]]];
          ];
      ]; 

getAuxVector[vector_]:=Block[{},
      If[Head[vector]===conj,
          
          Return[conj[
                ToExpression["A"<>StringDrop[ToString[RE[vector]],1]]]];,
          Return[ToExpression["A"<>StringDrop[ToString[vector],1]]];
          ];
      ]; 

UseSymmASymm=False;

CheckSymmetry[Op_]:=Block[{pos},
      If[FreeQ[ParameterDefinitions,Op]\[Equal]False,
          pos=Position[Transpose[ParameterDefinitions][[1]],Op][[1,1]];
          
          If[(Real/.Extract[ParameterDefinitions,pos][[2]])===True && 
              FreeQ[realVar,Op],realVar=Join[realVar,{Op}]];
          Switch[(Symmetry/.Extract[ParameterDefinitions,pos][[2]]),
            Symmetric, 
            	
            Op[a___,b_,c_,d___]:=
              Op[a,c,b,
                  d] /;(OrderedQ[{b,c}]\[Equal]False && 
                    UseSymmASymm\[Equal]True);
            	Tp[Op] =Op;
            	Adj[Op] = conj[Op]; 
            	
            If[FreeQ[ListSymmetricParameters,(Op /. conj[x_]\[Rule]x)],
              ListSymmetricParameters=Join[ListSymmetricParameters,{Op}];];,
            AntiSymmetric, 
            	
            Op[a___,b_,c_,
                d___]:=-Op[a,c,b,d] /;(OrderedQ[{b,c}]\[Equal]False && 
                    UseSymmASymm\[Equal]True); 
            	Tp[Op] = -Op;
            	Adj[Op] = -conj[Op];
            	
            If[FreeQ[ListAntiSymmetricParameters,(Op /. conj[x_]\[Rule]x)],
              ListAntiSymmetricParameters=
                  Join[ListAntiSymmetricParameters,{Op}];];,
            Hermitian,
            	
            Op[a___,b_,c_,d___]:=
              conj[Op[a,c,b,d]] /;(OrderedQ[{b,c}]\[Equal]False && 
                    UseSymmASymm\[Equal]True); 
            	Tp[Op] = conj[Op];
            	Adj[Op] = Op;
            	];
          	];
      ];


CheckSymmetryTri[Op_,same_]:=Block[{pos},
      If[FreeQ[ParameterDefinitions,Op]\[Equal]False,
          pos=Position[Transpose[ParameterDefinitions][[1]],Op][[1,1]];
          
          If[(Real/.Extract[ParameterDefinitions,pos][[2]])===True && 
              FreeQ[realVar,Op],realVar=Join[realVar,{Op}]];
          Switch[Length[same],
            3,
            Switch[(Symmetry/.Extract[ParameterDefinitions,pos][[2]]),
                Symmetric, 
                	
                Op[a___,b_,c_,d___]:=
                  Op[a,c,b,
                      d] /;(OrderedQ[{b,c}]\[Equal]False && 
                        UseSymmASymm\[Equal]True);
                	Tp[Op] =Op;
                	Adj[Op] = conj[Op]; 
                	If[FreeQ[ListSymmetricParameters,(Op /. conj[x_]\[Rule]x)],
                  ListSymmetricParameters=
                      Join[ListSymmetricParameters,{Op}];];,
                AntiSymmetric, 
                	
                Op[a___,b_,c_,
                    d___]:=-Op[a,c,b,d] /;(OrderedQ[{b,c}]\[Equal]False && 
                        UseSymmASymm\[Equal]True); 
                	Tp[Op] = -Op;
                	Adj[Op] = -conj[Op];
                	
                If[FreeQ[
                    ListAntiSymmetricParameters,(Op /. conj[x_]\[Rule]x)],
                  ListAntiSymmetricParameters=
                      Join[ListAntiSymmetricParameters,{Op}];];,
                Hermitian,
                	
                Op[a___,b_,c_,d___]:=
                  conj[Op[a,c,b,d]] /;(OrderedQ[{b,c}]\[Equal]False && 
                        UseSymmASymm\[Equal]True); 
                	Tp[Op] = conj[Op];
                	Adj[Op] = Op;
                	];,
            2,
            Switch[same,
                {1,2},
                	Switch[(Symmetry/.Extract[ParameterDefinitions,pos][[2]]),
                    Symmetric, 
                    	
                    Op[b_,c_,d_]:=
                      Op[c,b,d] /;(OrderedQ[{b,c}]\[Equal]False && 
                            UseSymmASymm\[Equal]True);
                    	Tp[Op[d_]] =Op[d];
                    	Adj[Op[d_]] = conj[Op[d]]; 
                    	
                    If[FreeQ[
                        ListSymmetricParameters,(Op /. conj[x_]\[Rule]x)],
                      ListSymmetricParameters=
                          Join[ListSymmetricParameters,{Op}];];,
                    AntiSymmetric, 
                    	
                    Op[b_,c_,
                        d_]:=-Op[c,b,d] /;(OrderedQ[{b,c}]\[Equal]False && 
                            UseSymmASymm\[Equal]True); 
                    	Tp[Op[d_]] = -Op[d];
                    	Adj[Op[d_]] = -conj[Op[d]];
                    	
                    If[FreeQ[
                        ListAntiSymmetricParameters,(Op /. conj[x_]\[Rule]x)],
                      ListAntiSymmetricParameters=
                          Join[ListAntiSymmetricParameters,{Op}];];,
                    Hermitian,
                    	
                    Op[b_,c_,d_]:=
                      conj[Op[c,b,d]] /;(OrderedQ[{b,c}]\[Equal]False && 
                            UseSymmASymm\[Equal]True); 
                    	Tp[Op[d_]] = conj[Op[d]];
                    	Adj[Op[d_]] = Op[d];
                    	];,
                {1,3},
                	Switch[(Symmetry/.Extract[ParameterDefinitions,pos][[2]]),
                    Symmetric, 
                    	
                    Op[b_,c_,d_]:=
                      Op[d,c,b] /;(OrderedQ[{b,d}]\[Equal]False && 
                            UseSymmASymm\[Equal]True);
                    	
                    If[FreeQ[
                        ListSymmetricParameters,(Op /. conj[x_]\[Rule]x)],
                      ListSymmetricParameters=
                          Join[ListSymmetricParameters,{Op}];];,
                    AntiSymmetric, 
                    	
                    Op[b_,c_,
                        d_]:=-Op[d,c,b] /;(OrderedQ[{b,d}]\[Equal]False && 
                            UseSymmASymm\[Equal]True); 
                    	
                    If[FreeQ[
                        ListAntiSymmetricParameters,(Op /. conj[x_]\[Rule]x)],
                      ListAntiSymmetricParameters=
                          Join[ListAntiSymmetricParameters,{Op}];];,
                    Hermitian,
                    	
                    Op[b_,c_,d_]:=
                        conj[Op[d,c,b]] /;(OrderedQ[{b,d}]\[Equal]False && 
                              UseSymmASymm\[Equal]True); 
                    	];,
                {2,3},
                	Switch[(Symmetry/.Extract[ParameterDefinitions,pos][[2]]),
                    Symmetric, 
                    	
                    Op[b_,c_,d_]:=
                      Op[b,d,c] /;(OrderedQ[{c,d}]\[Equal]False && 
                            UseSymmASymm\[Equal]True);
                    	
                    If[FreeQ[
                        ListSymmetricParameters,(Op /. conj[x_]\[Rule]x)],
                      ListSymmetricParameters=
                          Join[ListSymmetricParameters,{Op}];];,
                    AntiSymmetric, 
                    	
                    Op[b_,c_,
                        d_]:=-Op[b,d,c] /;(OrderedQ[{c,d}]\[Equal]False && 
                            UseSymmASymm\[Equal]True); 
                    	
                    If[FreeQ[
                        ListAntiSymmetricParameters,(Op /. conj[x_]\[Rule]x)],
                      ListAntiSymmetricParameters=
                          Join[ListAntiSymmetricParameters,{Op}];];,
                    Hermitian,
                    	
                    Op[b_,c_,d_]:=
                        conj[Op[b,d,c]] /;(OrderedQ[{c,d}]\[Equal]False && 
                              UseSymmASymm\[Equal]True); 
                    	];
                ];
            ];
          ];
      ];

genTest[Op_,listP_,AddSB_]:=
    Block[{i,res,struct,gens,genstruct,temp, SBHeader},
      If[Depth[Op]\[Equal]2,
        newHead=Op[[0]];Opc=Op[[1]];AddHead=True;,
        AddHead=False; Opc = Op;
        ];
      
      
      If[AddSB\[Equal]True,
        Switch[Length[listP],
            3, SBHeader= T;
                   
            CheckSymmetryTri[Opc,
              Position[Count[listP,#]&/@listP,_?((#>1)&),3]/.{a_}\[Rule]a];
                   
            CheckSymmetryTri[SBHeader[Opc],
              Position[Count[listP,#]&/@listP,_?((#>1)&),3]/.{a_}\[Rule]a];,
            2, SBHeader = B;
                   CheckSymmetry[Opc];
                   CheckSymmetry[SBHeader[Opc]];,
            1, SBHeader = L;
                   CheckSymmetry[Opc];
                   CheckSymmetry[SBHeader[Opc]];
            ];
        ];
      
      Switch[Length[listP],
        3,  
        CheckSymmetryTri[Opc,
            Position[Count[listP,#]&/@listP,_?((#>1)&),3]/.{a_}\[Rule]a];,
        2,  CheckSymmetry[Opc];,
        1,  CheckSymmetry[Opc];
        ];
      
      
      
      If[FreeQ[Fields,listP[[1]]]\[Equal]False,
        gens = 
            Table[Extract[Fields,Position[Fields,listP[[i]]][[1,1]]][[2]],{i,
                1,Length[listP]}];,
        gens = Table[getGen[listP[[i]]],{i,1,Length[listP]}];
        ];
      pT = Table[If[gens[[i]]>1,genf[i],0],{i,1,Length[listP]}];
      gens = DeleteCases[gens,1];
      
      If[FreeQ[ParameterDefinitions,Opc]\[Equal]False,
        Switch[(Form/.Extract[ParameterDefinitions,
                    Position[ParameterDefinitions,Opc][[1,1]]][[2]]),
            Scalar,
            		res=Opc; genStruct=1; gens={};,
            Diagonal,
            		res=DeleteCases[Opc@@pT,0] /. A_[]\[Rule]A;
            genStruct=
              DeleteCases[DeltaF@@pT,0] /. DeltaF[]\[Rule]1 /. 
                DeltaF[x_]\[Rule]1;,
            _,
            		res=DeleteCases[Opc@@pT,0] /. A_[]\[Rule]A;genStruct = 1;
            ];,
        res=DeleteCases[Opc@@pT,0] /. A_[]\[Rule]A;
        genStruct = 1;	
        ];
      
      genStruct= 
        genStruct /. {DeltaF[a_,b_]\[Rule]Delta[a,b], 
            DeltaF[a_,b_,c_]\[Rule]Delta[a,b] Delta[b,c] Delta[a,c]};
      
      
      If[FreeQ[parameters,Opc]\[Equal]True,
        parameters=
          Join[parameters,{{Opc,Table[generation,{Length[gens]}],gens}}];
        If[AddSB\[Equal]True,
          parameters=
              Join[parameters,{{SBHeader[Opc],
                    Table[generation,{Length[gens]}],gens}}];];
        ];
      
      If[Length[DeleteCases[pT,0]]\[LessEqual]1,
        Tp[Opc]=Opc;Adj[Opc]=conj[Opc];
        VectorParameters=Join[VectorParameters,{Opc,SBHeader[Opc]}];
        Tp[SBHeader[Opc]]=SBHeader[Opc];
        Adj[SBHeader[Opc]]=conj[SBHeader[Opc]];
        ];
      
      If[AddHead\[Equal]True,
        Return[newHead[res]*genStruct];,
        Return[res*genStruct];
        ];
      ];

getGenSF[part_]:=Extract[Extract[Fields,Position[Fields,part][[1,1]]],2];
getGen[part_]:=getGen[part,Current];
getGenALL[part_]:=getGen[part,ALL];
getFla[part_]:=getFla[part,Current];
getFlaALL[part_]:=getFla[part,ALL];

getGen[part_,states_]:=Block[{pos, particle,partTemp},
        partTemp= getBlank[DeleteCases[getBlank[part],x_?NumberQ,4]];
        particle = getParticleName[partTemp];
        If[FreeQ[Particles[states],getBlank[particle]]\[Equal]False,
          pos = Position[Particles[states],getBlank[particle]];
          If[pos=!={},
            
            Return[Evaluate[
                  Extract[Particles[states],pos[[1,1]]][[3]]/. 
                    GetGen \[Rule] getGen]];,
            Message[Particle::unknown ,part];
            Return[0];
            ];,
          If[FreeQ[SFields,particle]\[Equal]False,
            Return[Fields[[Position[SFields,particle][[1,1]],2]]];
            ];
          If[FreeQ[FFields,particle]\[Equal]False,
            Return[Fields[[Position[FFields,particle][[1,1]],2]]];
            ];
          Return[99];
          ];
        ]/; (FreeQ[part,getGen]\[Equal]True);

getFla[part_,states_]:=Block[{pos, particle,partTemp},
        partTemp= getBlank[DeleteCases[getBlank[part],x_?NumberQ,4]];
        particle = getParticleName[partTemp];
        If[FreeQ[Particles[states],getBlank[particle]]\[Equal]False,
          pos = Position[Particles[states],getBlank[particle]];
          If[pos=!={},
            If[Length[Extract[Particles[states],pos[[1,1]]]]\[Equal]6,
                
                Return[Evaluate[
                      Extract[Particles[states],pos[[1,1]]][[6]]/. 
                        GetGen \[Rule] getGen]];,
                Return[1];
                ];,
            Message[Particle::unknown ,part];
            Return[0];
            ];,
          Return[1];
          ];
        ]/; (FreeQ[part,getGen]\[Equal]True);



getGenOne[x_]:=Block[{part},
      If[FreeQ[GaugeMassES,getBlank[x]]\[Equal]False,
        part=
            Extract[GaugeMassESorg,
              Position[GaugeMassES,getBlank[x]][[1,1]]];,
        part=getBlank[x];
        ];
      If[FreeQ[OnlyOneGen,part]\[Equal]False,
        Return[1];,
        Return[getGen[part]];
        ];
      ];


getGenStart[part_]:=Block[{pos, particle},
        particle = getBlank[DeleteCases[getBlank[part],x_?NumberQ,4]];
        particle = getParticleName[particle];
        pos = Position[Particles[Current],particle];
        If[pos=!={},
          
          Return[Evaluate[
                Extract[Particles[Current],pos[[1,1]]][[2]]/. 
                  GetGen \[Rule] getGen]];,
          If[FreeQ[SFields,particle]\[Equal]False,
            Return[1];
            ];
          If[FreeQ[FFields,particle]\[Equal]False,
            Return[1];
            ];
          Message[Particle::unknown ,part];
          (* Print["ERROR (getGenStart)  ",part, particle]; *)
          
          Return[0];
          ];
        ] /; (FreeQ[part,getGen]\[Equal]True);


GetGen[x_]:= getGen[x] /; (SetGenerations\[Equal]True);
GetGenStart[x_]:= getGenStart[x] /; (SetGenerations\[Equal]True);


getNumberStates[charge_]:=Block[{cCharge,pos, particle,i},
      cCharge = DeleteCases[charge,x_?NumberQ];
       If[FreeQ[Gauge,cCharge],
        cCharge=ToExpression[StringDrop[ToString[cCharge],-1]];
        ]; 
      pos = Position[Gauge,cCharge][[1,1]];
      Return[(Extract[Gauge,pos][[2,1]])];
      ];

getNumberGenerators[
      charge_]:=((Extract[Gauge, Position[Gauge,charge][[1,1]]][[2,1]])^2-1);

getSumFields[field_,nr_]:=Block[{i,pos,fac, ind,type},
      ind = 
        DeleteCases[DeleteCases[First[ListFields[[field,3]]],generation],
          lorentz];
      type = 
        DeleteCases[DeleteCases[Last[ListFields[[field,3]]],generation],
          lorentz];
      Return[(sum[generation /. subGC[nr],1,Fields[[field,2]]])*
          Product[sum[DeleteCases[ind[[i]],x_?NumericQ] /. subGC[5], 1, 
              getNumberStates[type[[i]]]],{i,1,Length[ind]}]];
      ];

getType[part_]:=getType[part,False,Current];
getTypeOld[part_]:=getType[part,False,ALL];
getType[part_,True]:=getType[part,True,Current];

 getType[part_,init_,states_]:=Block[{pos, particle},
      particle = getParticleName[part];
      
      If[init\[Equal]True,
        If[FreeQ[typeList,particle]\[Equal]False,
            
            Return[Extract[typeList,
                    Position[typeList,particle][[1,1]]][[2]]];,
            Return[NoField];
            ];
        ];
      
      If[FreeQ[vacuum,particle]\[Equal]True && FreeQ[typeList,particle],
        Return[NoField];];
      If[FreeQ[Particles[states],RE[particle]]\[Equal]False,
        pos = 
          Drop[DeleteCases[Position[Particles[states],particle,3,1][[1]],
              0],-1];
        Return[Extract[Particles[states],pos][[4]]];,
        If[FreeQ[typeList,particle]\[Equal]False,
          Return[Extract[typeList,Position[typeList,particle][[1,1]]][[2]]];
          ];
        Return[NoField];
        ];
      ];

(* getColor[part_]:=If[FreeQ[getIndizes[part],color],1,3]; *)


getParticleName[part_]:=
    
    If[MemberQ[Transpose[dirac][[1]],getBlank[part]]\[Equal]True,
      Return[Select[getBlank[part]/.diracSub,#=!=0&,1][[1]]];,
      Return[getBlank[part]];
      ];

getParticleNameDirac[part_]:=
    
    If[MemberQ[Transpose[dirac][[2]],getBlank[part]]\[Equal]True || 
        MemberQ[Transpose[dirac][[3]],getBlank[part]]\[Equal]True,
      Return[(getBlank[part]/.diracSubBack1 /. diracSubBack2)];,
      Return[getBlank[part]];
      ];

getFull[part_]:=getFull[part,Current];
getFullOld[part_]:=getFull[part,ALL];
getFullSF[part_]:=SFields[[Position[SFields,getBlankSF[part]][[1,1]]]];

getFull[part_,states_]:=Block[{pos,particle,indizes,sub},
      If[FreeQ[Transpose[dirac][[1]],getBlank[part]],sub={};,
        sub=Join[diracSubBack1,diracSubBack2]];
      If[FreeQ[Particles[states],getParticleName[part]],Return[part]];
      pos = 
        Drop[DeleteCases[
            Position[Particles[states],getParticleName[part],3,1][[1]],
            0],-1];
      particle=Extract[Particles[states],pos][[1]];
      indizes = Extract[Particles[states],pos][[5]];
      If[indizes \[NotEqual] {},particle=particle[indizes]];
      If[(Head[part]===conj)||(Head[part]===bar),
        If[(Head[part]===conj),
            Return[conj[particle/.sub]];,
            Return[bar[particle/.sub]];
            ];,
        Return[particle/.sub];
        ];
      ];

getFull2[part_]:=getFull2[part,Current];
getFull2[part_,states_]:=Block[{pos,particle,indizes,sub,head},
      If[(Head[part]===conj)||(Head[part]===bar),head=Head[part];,
        head=Evaluate;];
      If[FreeQ[SFields,getBlankSF[part]]\[Equal]False,
        Return[head[SFields[[Position[SFields,getBlankSF[part]][[1,1]]]]]]];
      If[FreeQ[FFields,getBlankSF[part]]\[Equal]False,
        Return[head[FFields[[Position[FFields,getBlankSF[part]][[1,1]]]]]]];
      
      If[FreeQ[Transpose[dirac][[1]],getBlank[part]],sub={};,
        sub=Join[diracSubBack1,diracSubBack2]];
      If[FreeQ[Particles[states],getParticleName[part]],Return[part]];
      pos = 
        Drop[DeleteCases[
            Position[Particles[states],getParticleName[part],3,1][[1]],
            0],-1];
      particle=Extract[Particles[states],pos][[1]];
      indizes = Extract[Particles[states],pos][[5]];
      If[indizes \[NotEqual] {},particle=particle[indizes]];
      If[(Head[part]===conj)||(Head[part]===bar),
        If[(Head[part]===conj),
            Return[conj[particle/.sub]];,
            Return[bar[particle/.sub]];
            ];,
        Return[particle/.sub];
        ];
      ];

getIndizes[part_]:=
    If[FreeQ[Particles[Current],getParticleName[part]],{n},
      Extract[Particles[Current],
          Position[Particles[Current],getParticleName[part]][[1,1]]][[5]]];
getIndizesOld[part_]:=
    If[FreeQ[Particles[ALL],getParticleName[part]],{n},
      Extract[Particles[ALL],
          Position[Particles[ALL],getParticleName[part]][[1,1]]][[5]]];

getDescriptionField[y_]:=Block[{temp},
      temp=getEntryField[y,Description];
      If[Head[temp]===String,
        Return[temp];,
        Return[ToString[y]];
        ];
      ];

getDescriptionParameter[y_]:=Block[{temp},
      temp=getEntryParameter[y,Description];
      If[Head[temp]===String,
        Return[temp];,
        Return[ToString[y]];
        ];
      ];

getDescription[y_]:=getDescriptionParameter[y];

getDescriptionField[y_,gen_,fla___]:=Block[{temp},
      temp = getDescriptionField[y];
      If[getGenOne[y]>1,
        If[getFla[y]>1,
            Return[temp<>" "<>ToString[gen]<>" "<>ToString[fla]];,
            Return[temp<>" "<>ToString[gen]];
            ];,
        Return[temp];
        ];
      ];

getLaTeXField[y_,gen_,fla___]:=Block[{temp},
      temp = getLaTeXField[y];
      If[getGenOne[y]>1,
        If[getFla[y]>1,
            Return["{"<>temp<>"}_{"<>ToString[gen]<>ToString[fla]<>"}"];,
            Return["{"<>temp<>"}_"<>ToString[gen]];
            ];,
        Return[temp];
        ];
      ];

getLaTeXField[y_]:=Block[{temp},
      temp=getEntryField[RE[y],LaTeX];
      If[Head[temp]===List,
        If[Head[y]===bar || Head[y]===conj,
            Return[temp[[2]]];,
            Return[temp[[1]]];
            ];,
        If[Head[temp]===String,
            If[Head[y]===bar,
                Return["\\bar{"<>temp<>"}"];,
                If[Head[y]===conj,
                    Return[temp<>"^*"];,
                    Return[temp];
                    ];
                ];,
            If[Head[y]===bar,
                Return["\\bar{"<>ToString[y]<>"}"];,
                If[Head[y]===conj,
                    Return[ToString[y]<>"^*"];,
                    Return[ToString[y]];
                    ];
                ];
            ];
        ];
      ];

getLaTeXParameter[y_]:=Block[{temp},
      temp=getEntryParameter[y,LaTeX];
      If[Head[temp]===String,
        Return[temp];,
        Return[ToString[y]];
        ];
      ];

getOutputNameAnti[y_,gen_,fla___]:=Block[{temp},
      temp = getOutputName[y,gen,fla];
      If[AntiField[y]===y,
        Return[ToExpression[temp]];,
        If[getType[y]===F,
            Return[ToExpression[ToString[temp]<>"bar"]];,
            Return[ToExpression["c"<>ToString[temp]]];
            ];
        ];
      ];

getOutputName[y_]:=getEntryField[y,OutputName];
getOutputName[y_,gen_,fla___]:=Block[{temp},
      temp = getOutputName[y];
      If[gen\[Equal]0,
        If[Head[temp]===List,
            Return[ToExpression[temp[[1]]]];,
            Return[ToExpression[temp]];
            ];,
        If[Head[temp]===List,
          temp=temp[[1]];
          ];
        If[getGenOne[y]\[Equal]1,
          Return[ToExpression[temp]];,
          If[getFla[y]>1,
              Return[ToExpression[temp<>ToString[gen]<>ToString[fla]]];,
              Return[ToExpression[temp<>ToString[gen]]];
              ];
          ];
        ];
      ];

getMass[y_,gen_]:=getMassWidth[y,gen,1,"M"];
getWidth[y_,gen_]:=getMassWidth[y,gen,1,"W"];
getMass[y_,gen_,fla_]:=getMassWidth[y,gen,fla,"M"];
getWidth[y_,gen_,fla_]:=getMassWidth[y,gen,fla,"W"];
getMassWidth[y_,gen_,fla_,letter_]:=Block[{temp},
      If[FreeQ[massless,y]\[Equal]False,Return[0]];
      If[getMassNumerical[y,gen]===0,Return[0];];
      temp = letter<>ToString[y];
      If[gen\[Equal]0,
        Return[ToExpression[temp]];,
        If[getGenOne[y]==1,
            Return[ToExpression[temp]];,
            If[getFla[y]>1,
                Return[ToExpression[temp<>ToString[gen]<>ToString[fla]]];,
                Return[ToExpression[temp<>ToString[gen]]];
                ];
            ];
        ];
      ];

getMassWidthOutputName[y_,gen_,fla_,letter_]:=Block[{temp},
      If[FreeQ[massless,y]\[Equal]False,Return[0]];
      If[getMassNumerical[y,gen]===0,Return[0];];
      temp = letter<>ToString[y];
      outname=getOutputName[y];
      If[Head[outname]===List,
        temp = letter<>outname[[1]];,
        temp = letter<>outname;
        ];
      If[gen\[Equal]0,
        Return[ToExpression[temp]];,
        If[getGenOne[y]==1,
            Return[ToExpression[temp]];,
            If[getFla[y]>1,
                Return[ToExpression[temp<>ToString[gen]<>ToString[fla]]];,
                Return[ToExpression[temp<>ToString[gen]]];
                ];
            ];
        ];
      ];


getPDGList[y_]:=getPDG[y,0];
getPDG[x_]:=getPDG[x,0];
getPDG[y_,gen_,fla___]:=Block[{temp},
      temp = getEntryField[y,PDG];
      If[gen\[Equal]0,
        Return[temp];,
        If[getGenOne[y]\[Equal]1,
            Return[temp[[1]]];,
            If[getFla[y]>1,
                Return[temp[[1+(gen-1)*getFla[y]+(fla-1)]]];,
                Return[temp[[gen]]];
                ];
            ];
        ];
      ];

getEntryParameter[y_,Type_]:=Block[{pos,field,i,states,des},
      field = y;
      If[FreeQ[Transpose[ParameterDefinitions][[1]],field]\[Equal]False,
        pos = Position[Transpose[ParameterDefinitions][[1]],field];
        ];
      If[Head[pos]===List,
        If[FreeQ[ParameterDefinitions[[pos[[1,1]]]][[2]],Type],
            Return[None];,
            Return[Type /. ParameterDefinitions[[pos[[1,1]]]][[2]]];
            ];,
        Return[None];
        ];
      ];

getEntryField[y_,Type_]:=Block[{pos,field,i,states,des},
      field = y;
      For[i=1,i\[LessEqual]Length[NameOfStates],
        If[FreeQ[ParticleDefinitions[NameOfStates[[i]]],field]\[Equal]False,
          pos = Position[ParticleDefinitions[NameOfStates[[i]]],field];
          states = NameOfStates[[i]];
          ];
        i++;];
      
      If[Head[pos]===List,
        If[FreeQ[ParticleDefinitions[states][[pos[[1,1]]]][[2]],Type],
            Return[None];,
            Return[Type /. ParticleDefinitions[states][[pos[[1,1]]]][[2]]];
            ];,
        Return[None];
        ];
      ];

Options[getMassNumerical]={ ReturnEquation\[Rule]False};
getMassNumerical[y_,gen_,fla_,opt___ ]:=
  getMassNumericalFunc[y,gen,fla, 
    ReturnEquation/.{opt}/. Options[getMassNumerical]]

getMassNumericalFunc[x_,gen_,fla_,formula_]:=Block[{temp},
      If[getGenOne[x]\[Equal]1,
        temp = 
            Mass[x] /. 
                Flatten[
                  Table[Masses[NameOfStates[[i]]],{i,1,
                      Length[NameOfStates]}]] /. subNum;,
        If[getFla[x]>1,
            
            temp = Mass[x[gen,fla]] /. 
                    Flatten[
                      Table[Masses[NameOfStates[[i]]],{i,1,
                          Length[NameOfStates]}]]/. subNum;,
            
            temp = Mass[x[gen]] /. 
                    Flatten[
                      Table[Masses[NameOfStates[[i]]],{i,1,
                          Length[NameOfStates]}]]/. subNum;
            ];
        ];
      If[NumberQ[temp],
        Return[temp];,
        If[Head[temp]===Mass || Head[temp]===MassRead,
            Return[100];,
            If[formula\[Equal]True,
              If[getGenOne[x]\[Equal]1,
                  
                  temp = Mass[x] /. 
                        Flatten[
                          Table[Masses[NameOfStates[[i]]],{i,1,
                              Length[NameOfStates]}]];,
                  If[getFla[x]>1,
                      
                      temp = Mass[x[gen,fla]] /. 
                            Flatten[
                              Table[Masses[NameOfStates[[i]]],{i,1,
                                  Length[NameOfStates]}]];,
                      
                      temp = Mass[x[gen]] /. 
                            Flatten[
                              Table[Masses[NameOfStates[[i]]],{i,1,
                                  Length[NameOfStates]}]];
                      ];
                  ];
              ];
            Return[temp];
            
            ];
        ];
      ];

getWidthNumerical[x_,gen_,fla___]:=Block[{temp},
      If[getGenOne[x]\[Equal]1,
        temp = 
            WidthUsed[x] /. 
              Flatten[Table[
                  Width[NameOfStates[[i]]],{i,1,Length[NameOfStates]}]];,
        If[getFla[x]>1,
            
            temp = WidthUsed[x[gen,fla]] /. 
                  Flatten[
                    Table[Width[NameOfStates[[i]]],{i,1,
                        Length[NameOfStates]}]];,
            
            temp = WidthUsed[x[gen]] /. 
                  Flatten[
                    Table[Width[NameOfStates[[i]]],{i,1,
                        Length[NameOfStates]}]];
            ];
        ];
      If[NumberQ[temp],
        Return[temp];,
        If[Head[temp]===WidthUsed,
            Return[1];,
            Return[External];
            ];
        ];
      ];




getBlank[part_]:=RE[part] /.{x_[{a__}][b_]\[Rule]x,x_[{a__}]\[Rule]x}; 
getBlankSF[part_]:=RE[part] /.{x_[{a__}][{b__}]\[Rule]x,x_[{a__}]\[Rule]x};

getPropagatorType[x_]:=Switch[getType[x],
      F,
      	Return[Straight];,
      S,
      	Return[ScalarDash];,
      V,
      	Return[Sine];,
      G,
      	Return[GhostDash];
      ];

getDim[matrix_]:=If[
      FreeQ[dimMatrizesAll,matrix]\[Equal]False,
      Return[
          Extract[dimMatrizesAll,
              Position[dimMatrizesAll,matrix][[1,1]]][[2]]];,
      Return[0];
      ];

getRParity[name_,Eigenstates_]:=Block[{temp,pos, part},
      part = getBlank[getBlankSF[name]];
      If[FreeQ[WeylFermionAndIndermediate,part],
        temp = ParticleDefinitions[Eigenstates];,
        temp =WeylFermionAndIndermediate;
        ];
      pos = Position[temp,part];
      If[pos=!={},
        pos=pos[[1,1]];
        Return[RParity /. temp[[pos]][[2]]];,
        Return[None];
        ];
      ];

getDimParameter[x_]:=Extract[parameters,Position[parameters,x][[1,1]]][[3]];

getPartCode[parts_]:=Block[{i,partCode},
      partCode=0;
      For[i=1,i\[LessEqual]Length[parts],
        Switch[getType[parts[[i]] /. Der[x_]\[Rule]x],
          A,partCode+=10000;,
          F,partCode+=1000;,
          S,partCode+=100;,
          V,partCode+=10;,
          G,partCode+=1;
          ];
        i++;
        ];
      Return[partCode];
      ];

GetEntryDef[Field_,ES_,Entry_]:=Block[{i,pos},
      pos=Position[ParticleDefinitions[ES],getParticleNameDirac[Field]];
      If[pos==={},
        Return[Non];,
        Return[Entry /. ParticleDefinitions[ES][[pos[[1,1]]]][[2]]];
        ];
      ];

B[conj[x_]]:=conj[B[x]];
T[conj[x_]]:=conj[T[x]];
L[conj[x_]]:=conj[L[x]];



AntiField[x_]:=
  If[FermionQ[x] || GhostQ[x],Return[bar[x]];,
      Return[conj[x]];] /; (FreeQ[x,FieldToInsert] && FreeQ[x,External] && 
        FreeQ[x,Internal])
GhostQ[x_]:=If[getType[x]===G,Return[True];,Return[False];];
FermionQ[x_]:=If[getType[x]===F,Return[True];,Return[False];];
NoFermionQ[x_]:=If[getType[x]===F,Return[False];,Return[True];];

