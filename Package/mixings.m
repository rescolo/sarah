(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)

CalcGaugeMixing[type_, def_]:=Block[{i,l,j,k},
      
      Print["Calc Mixings Gauge Sector"];
      
      title = ToString[type];
      subGauge = {}; subGhost = {};
      subGaugeInv={}; subGhostInv={};
      mixedGauge={}; mixedGhost={};
      mixBosonBasis = {}; mixGhostBasis = {}; mixBasisNumbers={};
      mixBosonFinal = {}; mixGhostFinal = {};
      
       For[i=1,i\[LessEqual]Length[def],
        If[getType[def[[i,1]]]=!=F,
          If[FreeQ[SGauge,def[[i,1]]]\[Equal]False,
            
            BrokenSymmetries=
                Join[BrokenSymmetries,{Position[SGauge,def[[i,1]]][[1,1]]}];
            ];
          
          subGauge = 
            Join[subGauge,{(getFull[def[[i,1]]] /. 
                      subIndizesMixStart) \[Rule] 
                  Sum[Delta[xgen,def[[i,j,1]]] Sum[
                        def[[i,j,k,2]]*
                          repl[xgen] (sum[
                                Hold[ToExpression[
                                    "n"<>StringDrop[ToString[xgen],3]]],
                                GetGenStart[def[[i,j,k,1]]],
                                GetGen[
                                  def[[i,j,k,1]]]]def[[i,j,k,
                                    1]][(getIndizes[
                                      def[[i,1]]]/.subIndizesMixEnde)])  ,{k,
                          2,Length[def[[i,j]]]}],{j,2,Length[def[[i]]]}]}];,
          
          subGauge = 
              Join[subGauge,{(getFull[def[[i,1]]][fNr_] /. 
                        subIndizesMixStart) \[Rule] 
                    Sum[Delta[xgen,def[[i,j,1]]] Sum[
                          def[[i,j,k,2]]*
                            repl[xgen] (sum[
                                  Hold[ToExpression[
                                      "n"<>StringDrop[ToString[xgen],3]]],
                                  GetGenStart[def[[i,j,k,1]]],
                                  GetGen[
                                    def[[i,j,k,1]]]]def[[i,j,k,
                                        1]][(getIndizes[
                                        def[[i,1]]]/.subIndizesMixEnde)][
                                  fNr])  ,{k,2,Length[def[[i,j]]]}],{j,2,
                        Length[def[[i]]]}]}]; 
          ]; 
        If[getType[def[[i,1]]]\[Equal]V,
          
          subGhost = 
            Join[subGhost,{(getFull[getGhost[def[[i,1]]]] /. 
                      subIndizesMixStart) \[Rule] 
                  Sum[Delta[xgen,def[[i,j,1]]] Sum[
                        def[[i,j,k,2]]*
                          repl[xgen] (sum[
                                Hold[ToExpression[
                                    "n"<>StringDrop[ToString[xgen],3]]],
                                GetGenStart[getGhost[def[[i,j,k,1]]]],
                                GetGen[getGhost[def[[i,j,k,1]]]]]getGhost[
                                  def[[i,j,k,1]]][(getIndizes[
                                      getGhost[
                                        def[[i,
                                        1]]]]/.subIndizesMixEnde)])  ,{k,2,
                          Length[def[[i,j]]]}],{j,2,Length[def[[i]]]}]}];
          mixedGauge=Join[mixedGauge,{def[[i,1]]}];
          mixedGhost=Join[mixedGhost,{getGhost[def[[i,1]]]}];
          ];
        For[j=2,j\[LessEqual]Length[def[[i]]],
          If[getType[def[[i,1]]]===V,
            mixBosonBasis=Join[mixBosonBasis,{getFull[def[[i,1]]]}];
            
            mixGhostBasis=
              Join[mixGhostBasis,{getFull[getGhost[def[[i,1]]]]}];
            mixBasisNumbers=Join[mixBasisNumbers,{def[[i,j,1]]}];
            ];
          For[k=2,k\[LessEqual]Length[def[[i,j]]],
            newSymbol= Cases[def[[i,j,k,2]],x_Symbol,2];
             For[l=1,l\[LessEqual]Length[newSymbol],
              If[FreeQ[parameters,newSymbol[[l]]]\[Equal]True,
                parameters=Join[parameters,{{newSymbol[[l]],{},{1}}}];
                realVar=Join[realVar,{newSymbol[[l]]}];
                
                rotationAngleGaugeBoson = 
                  Join[rotationAngleGaugeBoson,{newSymbol[[l]]}];
                ];
              l++;]; 
             If[FreeQ[Particles[Current],def[[i,j,k,1]]]\[Equal]True,
              If[FreeQ[Particles[Current],RE[def[[i,j,k,1]]]]\[Equal]True,
                
                addParticle[RE[def[[i,j,k,1]]],getIndizes[def[[i,1]]], 1,
                    getType[def[[i,1]]]];
                ];
              
              If[getType[def[[i,1]]]===V && 
                  FreeQ[Particles[Current],
                      getGhost[def[[i,j,k,1]]]]\[Equal]True,
                
                addParticle[getGhost[def[[i,j,k,1]]],
                    getIndizes[getGhost[def[[i,1]]]], 1,G];
                ];
              
              If[getType[def[[i,1]]]===V, 
                bosons = Join[bosons,{RE[def[[i,j,k,1]]]}]];
              ];
            
            If[getType[def[[i,1]]]===V && 
                FreeQ[mixBosonFinal,getFull[def[[i,j,k,1]]]]\[Equal]True,
              mixBosonFinal = Join[mixBosonFinal,{getFull[def[[i,j,k,1]]]}];
              
              mixGhostFinal = 
                Join[mixGhostFinal,{getFull[getGhost[def[[i,j,k,1]]]]}];
              ];
            k++;];
          j++;];
        i++;];
      
      
      SubGauge[Eigenstates]=subGauge;
      SubGhost[Eigenstates]=subGhost;
      
      
      MixingM=
        Table[Coefficient[
              replaceGen[
                  ReleaseHold[mixBosonBasis[[i]] /.subGC[1]/. subGauge],0] /. 
                i001\[Rule]mixBasisNumbers[[i]],
              mixBosonFinal[[j]] /.subGC[1]],{i,1,Length[mixBosonBasis]},{j,1,
              Length[mixBosonFinal]}] /.sum[a_,b_,c_]\[Rule]1;
      If[Length[MixingM]>0,
        InvMixingM = Simplify[Inverse[MixingM]];
        ];
      
      For[i=1,i\[LessEqual]Length[mixBosonFinal],
        subGaugeInv=
          Join[subGaugeInv,{(mixBosonFinal[[i]] /.subIndizesMixStart) \[Rule] 
                Sum[InvMixingM[[i,
                        j]] (mixBosonBasis[[j]] /.subIndizesMixEnde) Delta[
                      Hold[ToExpression["n"<>StringDrop[ToString[xgen],3]]],
                      mixBasisNumbers[[j]]],{j,1,Length[mixBosonBasis]}]}];
        subGhostInv=
          Join[subGhostInv,{(mixGhostFinal[[i]] /.subIndizesMixStart) \[Rule] 
                Sum[InvMixingM[[i,
                        j]] (mixGhostBasis[[j]] /.subIndizesMixEnde) Delta[
                      Hold[ToExpression["n"<>StringDrop[ToString[xgen],3]]],
                      mixBasisNumbers[[j]]],{j,1,Length[mixGhostBasis]}]}];
        mixedPart=
          replaceGen[ReleaseHold[mixBosonFinal[[i]] /. subGaugeInv],rgNr];
        If[mixedPart\[Equal]conj[mixedPart],
          realVar = Join[realVar,{getBlank[mixBosonFinal[[i]]]}];
          realVar = Join[realVar,{getBlank[mixGhostFinal[[i]]]}]; 
          ];
        i++;];
      
      UpdateGaugeTransformations[subGauge,subGaugeInv];
      
      GaugeTransformation=
        replaceGen[ReleaseHold[GaugeTransformation /. subGhost /.subGauge],
          rgNr];
      
      For[i=1,i\[LessEqual]Length[def],
        If[getType[def[[i,1]]]\[Equal]V,
          delParticle[getGhost[def[[i,1]]]];
          delParticle[getGhostBar[def[[i,1]]]];
          ];
        delParticle[def[[i,1]]];
        i++;];
      
      
      ];

(* --------------------------------------------------- *)
(* 
  Calculate Mixed Lagrangians *)
(* \
--------------------------------------------------- *)


CalcMixedLagrangian:=Block[{i, rotNr,j,l,add,newTerms},
      EffectiveOperators=0;
      EffectiveTheory=False;
      
      rgNr=0;
      
      
      (* ------------------------ 
                                    SYMMETRY BREAKING -------------------------------- \
*)
      
      LagReDef=0;
      
      For[rotNr=1,rotNr\[LessEqual]Length[NameOfStates],
        
        
        (* --------------------------- 
                                      Mixings --------------------------------*)
\
        
        title = ToString[NameOfStates[[rotNr]]];
        
        Print[""];
        Print["-----------------------------------"];
        Print["Evolve States: ",title];
        Print["-----------------------------------"];
        
        rgNr++;
        
        (*
          
          If[Head[Head[DEFINITION[NameOfStates[[rotNr]]][Flavors]]]=!=
                DEFINITION,
              GenerateFlavors[NameOfStates[[rotNr]]];
              Potential=replaceGen[ReleaseHold[Potential /.flavorSub],rgNr];
              Kinetic=replaceGen[ReleaseHold[Kinetic/.flavorSub],rgNr];
              
              EffectiveOperators=
                replaceGen[ReleaseHold[EffectiveOperators/.flavorSub],rgNr];
              
              LagrangianAux=
                replaceGen[ReleaseHold[LagrangianAux/.flavorSub],rgNr];
              LagReDef=replaceGen[ReleaseHold[LagReDef/.flavorSub],rgNr];
              flavorSub={};,
              flavorSub={};];
          *)
        
        If[Head[Head[DEFINITION[NameOfStates[[rotNr]]][VEVs]]]=!=DEFINITION,
          GenerateVEVs[NameOfStates[[rotNr]]];,
          vevSub={};
          ];
        
        If[
          Head[Head[DEFINITION[NameOfStates[[rotNr]]][GaugeSector2]]]=!=
            DEFINITION,
          
          CalcGaugeMixing2[NameOfStates[[rotNr]],
              DEFINITION[NameOfStates[[rotNr]]][GaugeSector2]];
          ];
        
        
        If[
          Head[Head[DEFINITION[NameOfStates[[rotNr]]][GaugeSector]]]=!=
            DEFINITION,
          
          CalcGaugeMixing[NameOfStates[[rotNr]],
              DEFINITION[NameOfStates[[rotNr]]][GaugeSector]];,
          subGauge = {};
          ];
        
        
        If[
          Head[Head[DEFINITION[NameOfStates[[rotNr]]][Flavors]]]=!=
            DEFINITION,
          GenerateFlavors[NameOfStates[[rotNr]]];
          Potential=replaceGen[ReleaseHold[Potential /.flavorSub],rgNr];
          Kinetic=replaceGen[ReleaseHold[Kinetic/.flavorSub],rgNr];
          
          EffectiveOperators=
            replaceGen[ReleaseHold[EffectiveOperators/.flavorSub],rgNr];
          
          LagrangianAux=
            replaceGen[ReleaseHold[LagrangianAux/.flavorSub],rgNr];
          LagReDef=replaceGen[ReleaseHold[LagReDef/.flavorSub],rgNr];
          flavorSub={};,
          flavorSub={};];
        
        
        If[
          Head[Head[DEFINITION[NameOfStates[[rotNr]]][Phases]]]=!=DEFINITION,
          GeneratePhases[NameOfStates[[rotNr]]];,
          phaseSub={};];
        
        Potential=
          replaceGen[
            ReleaseHold[Potential/.subGauge/.vevSub/.flavorSub /. phaseSub],
            rgNr];
        Kinetic=
          replaceGen[
            ReleaseHold[Kinetic/.vevSub/.subGauge/.flavorSub /. phaseSub],
            rgNr];
        EffectiveOperators=
          replaceGen[
            ReleaseHold[
              EffectiveOperators/.vevSub/.subGauge/.flavorSub /. phaseSub],
            rgNr];
        LagrangianVVV=
          replaceGen[ReleaseHold[LagrangianVVV/.subGauge /. phaseSub],rgNr];
        LagrangianVVVV=
          replaceGen[ReleaseHold[LagrangianVVVV/.subGauge /. phaseSub],rgNr];
        LagrangianAux=
          replaceGen[
            ReleaseHold[
              LagrangianAux/.vevSub/.subGauge/.flavorSub /. phaseSub],rgNr];
        LagReDef=
          replaceGen[
            ReleaseHold[LagReDef/.vevSub/.subGauge/.flavorSub /. phaseSub],
            rgNr];
        
        
        
        (* -------------------------------- 
                                        Effective after Gauge Bososn Mixing ------------------ \
*)
        
        If[Length[IntegrateOut]>0,
          Lagrangian = Kinetic - Potential + LagrangianVVV + LagrangianVVVV;
          MakeEffective;
          ];
        
        Potential=
          Potential /.{GetGenStart\[Rule]getGenStart,GetGen\[Rule]getGen};
        Kinetic = 
          Kinetic /.{GetGenStart\[Rule]getGenStart,GetGen\[Rule]getGen};
        LagrangianVVV = 
          LagrangianVVV /.{GetGenStart\[Rule]getGenStart,
              GetGen\[Rule]getGen};
        LagrangianVVVV = 
          LagrangianVVVV /.{GetGenStart\[Rule]getGenStart,
              GetGen\[Rule]getGen};
        EffectiveOperators  = 
          EffectiveOperators  /.{GetGenStart\[Rule]getGenStart,
              GetGen\[Rule]getGen};
        LagrangianAux  = 
          LagrangianAux /.{GetGenStart\[Rule]getGenStart,
              GetGen\[Rule]getGen};
        LagReDef  = 
          LagReDef /.{GetGenStart\[Rule]getGenStart,GetGen\[Rule]getGen};
        
        
        Print["Calc Mixings of Matter Fields"];
        
        If[
          Head[Head[DEFINITION[NameOfStates[[rotNr]]][MatterSector]]]=!=
            DEFINITION,
          res=MakeStates[DEFINITION[NameOfStates[[rotNr]]][MatterSector]]; ,
          res={{}};
          ];
        
        rgNr++;
        
        If[Head[Head[DEFINITION[NameOfStates[[rotNr]]][VEVs]]]=!=DEFINITION,
          
          TEqu=CalcTadpoleEquations[Potential,
                DEFINITION[NameOfStates[[rotNr]]][VEVs]];,
          Clear[TEqu];
          ];
        
        EffectiveOperators  = 
          replaceGen[ReleaseHold[EffectiveOperators  /. res[[1]]],rgNr];
        Potential = 
          replaceGen[ReleaseHold[ReleaseHold[Potential /. res[[1]]]],rgNr];
        Kinetic = 
          replaceGen[ReleaseHold[ReleaseHold[Kinetic/.res[[1]]]],rgNr];
        LagrangianAux = 
          replaceGen[ReleaseHold[ReleaseHold[LagrangianAux/.res[[1]]]],rgNr];
        LagReDef = 
          replaceGen[ReleaseHold[ReleaseHold[LagReDef/.res[[1]]]],rgNr];
        
        
        
        (* -------------------------------- 
                                        Effective after Particle Mixing ------------------ \
*)
        
        
        If[(Length[IntegrateOut]>0) || (Length[DeleteParticles]>0),
          Print["Integrate out Particles after Symmetry Breaking: ", title];
          Lagrangian = Kinetic - Potential + LagrangianVVV + LagrangianVVVV;
          MakeEffective;
          ];
        
        
        If[
          Head[Head[DEFINITION[NameOfStates[[rotNr]]][GaugeFixing]]]=!=
            DEFINITION,
          
          CalcGhostLagrangian[
              DEFINITION[NameOfStates[[rotNr]]][GaugeFixing]];
          ];
        
        
        If[
          Head[Head[DEFINITION[NameOfStates[[rotNr]]][Additional]]]=!=
            DEFINITION,
          add=DEFINITION[NameOfStates[[rotNr]]][Additional];
          For[j=1,j\[LessEqual]Length[add],
            
            newTerms=
              CreateLagrangian[add[[j,1]],
                AddHC /. add[[j,2]] /. {AddHC\[Rule]False},
                Overwrite /. add[[j,2]] /. {Overwrite\[Rule]False}];
            LagReDef+=newTerms[[1]];
            LagrangianVVV+=newTerms[[2]];
            LagrangianVVVV+=newTerms[[3]];
            Potential+=newTerms[[4]];
            Kinetic +=newTerms[[5]];
            j++;];
          ];
        
        SaveModelParameters[NameOfStates[[rotNr]]];
        
        rotNr++;
        ];
      
      (* ---------------------------- 
                                      Final Lagrangian ------------------------ \
*)
      
      Print[""];
      Print["-----------------------------------"];
      Print["Finishing"];
      Print["-----------------------------------"];
      
      Print["Calculate final Lagrangian"];
      
      SetGenerations=True;
      Update[];
      CheckOne;
      SetGenerations=False;
      
      AddMatrixProducts;
      
      
      MakeParameterDependenceList;
      CheckForMassless;
      CalculateTreeLevelMasses;
      
      SimplifyMatrices;
      CurrentStates = Last[NameOfStates];
      
      GetNumericalValues[SpectrumFile];
      
      If[(Length[makeOutput] > 0)   && (FirstRun\[Equal]False),
        Print[""];
        Print[""];
        Print["Beginning with automatized Output"];
        
        For[i=1,i\[LessEqual]Length[makeOutput],
          
          If[FreeQ[makeOutput[[i,2]],TeX]\[Equal]True,writetex=False;,
            writetex=True;];
          If[FreeQ[makeOutput[[i,2]],FeynArts]\[Equal]True,writefa=False;,
            writefa=True;];
          
          If[FreeQ[makeOutput[[i,2]],CHep]\[Equal]True,writech=False;,
            writech=True;];
          
          ModelOutput[makeOutput[[i,1]],WriteTeX\[Rule]writetex, 
            WriteCHep\[Rule]writech, WriteFeynArts\[Rule]writefa];
          i++;];
        ];
      ];



(* ----------------------------------------------- *)
(* 
  Calculate Substitutions *)
(* \
----------------------------------------------- *)


MakeStates[mixDef_]:=Block[{i,i2,j1,j2,gen,j3,l,flavors},
      mixES = {};
      mixESnoFV = {};
      mixBasis = {};
      mixBasisNoFV = {};
      mixMatES = {};
      mixMatESnoFV = {};
      dimMatrizes={};
      subDef={};
      subDefInverse={};
      mixedNames={};
      mixedNamesNoFV={};
      
      For[i=1,i\[LessEqual]Length[mixDef],
        If[FreeQ[mixDef[[i]],NoFlavorMixing]\[Equal]False,
          If[Length[Dimensions[mixDef[[i,1]]]]\[Equal]1,
            mixESnoFV = Join[mixESnoFV,{mixDef[[i]]}];
            mixedNamesNoFV = Join[mixedNamesNoFV,{mixDef[[i,2,1]]}];
             If[getType[mixDef[[i,1,1]]]===F,
              
              mixBasisNoFV = 
                  Join[mixBasisNoFV,{{mixDef[[i,1]],mixDef[[i,1]]}}];,
              
              mixBasisNoFV = 
                  Join[mixBasisNoFV,{{mixDef[[i,1]],conj[mixDef[[i,1]]]}}];
              ];,
            mixESnoFV = Join[mixESnoFV,{{mixDef[[i,1,1]],mixDef[[i,2,1]]}}];
            mixESnoFV = Join[mixESnoFV,{{mixDef[[i,1,2]],mixDef[[i,2,2]]}}];
            
            mixedNamesNoFV = 
              Join[mixedNamesNoFV,{{mixDef[[i,2,1]],mixDef[[i,2,2]]}}];
            
            mixBasisNoFV = 
              Join[mixBasisNoFV,{{mixDef[[i,1,1]],mixDef[[i,1,2]]}}];
            ];
          mixMatESnoFV = Join[mixMatESnoFV,{mixDef[[i,2]]}];,
          If[Length[Dimensions[mixDef[[i,1]]]]\[Equal]1,
            mixES = Join[mixES,{mixDef[[i]]}];
            mixedNames = Join[mixedNames,{mixDef[[i,2,1]]}];
             If[getType[mixDef[[i,1,1]]]===F,
              mixBasis = Join[mixBasis,{{mixDef[[i,1]],mixDef[[i,1]]}}];,
              
              mixBasis = 
                  Join[mixBasis,{{mixDef[[i,1]],conj[mixDef[[i,1]]]}}];
              ];,
            mixES = Join[mixES,{{mixDef[[i,1,1]],mixDef[[i,2,1]]}}];
            mixES = Join[mixES,{{mixDef[[i,1,2]],mixDef[[i,2,2]]}}];
            mixBasis = Join[mixBasis,{{mixDef[[i,1,1]],mixDef[[i,1,2]]}}];
            
            mixedNames = 
              Join[mixedNames,{{mixDef[[i,2,1]],mixDef[[i,2,2]]}}];
            ];
          mixMatES = Join[mixMatES,{mixDef[[i,2]]}];
          ];
        i++;];
      
      
      For[i=1,i\[LessEqual]Length[mixES],
        gen=
          Sum[(getGen[mixES[[i,1,j]]]-getGenStart[mixES[[i,1,j]]]+1),{j,1,
              Length[mixES[[i,1]]]}];
        addParticle[mixES[[i,2,1]],getFull[RE[mixES[[i,1,1]]]][[1]],gen, 
          getType[mixES[[i,1,1]]]];
        For[i2=1,i2\[LessEqual]AnzahlGauge,
           If[FreeQ[BrokenSymmetries,i2]\[Equal]True,
            SA`Casimir[mixES[[i,2,1]],i2]=SA`Casimir[mixES[[i,1,1]],i2];
            SA`Dynkin[mixES[[i,2,1]],i2]=SA`Dynkin[mixES[[i,1,1]],i2];
            ]; 
          
          MultiplicityFactor[mixES[[i,2,1]],i2]=
            MultiplicityFactor[mixES[[i,1,1]],i2];
          i2++;];
        If[TrueQ[conj[mixES[[i,1,1]]]\[Equal]mixES[[i,1,1]]]\[Equal]True,
          realVar=Join[realVar,{mixES[[i,2,1]]}];];
        If[FreeQ[parameters,mixES[[i,2,2]]]\[Equal]True,
          
          parameters=
              Join[parameters,{{mixES[[i,2,2]],{generation,generation},{gen,
                      gen}}}];
          ];
        i++;];
      
      
      
      For[i=1,i\[LessEqual]Length[mixESnoFV],
        flavors=Length[mixESnoFV[[i,1]]];
        gen=getGen[mixESnoFV[[i,1,1]]];
        addParticle[mixESnoFV[[i,2,1]],
          Insert[getFull[RE[mixESnoFV[[i,1,1]]]][[1]],flavor,2],gen, 
          getType[mixESnoFV[[i,1,1]]],flavors];
        For[i2=1,i2\[LessEqual]AnzahlGauge,
           If[FreeQ[BrokenSymmetries,i2]\[Equal]True,
            SA`Casimir[mixES[[i,2,1]],i2]=SA`Casimir[mixES[[i,1,1]],i2];
            SA`Dynkin[mixES[[i,2,1]],i2]=SA`Dynkin[mixES[[i,1,1]],i2];
            ]; 
          
          MultiplicityFactor[mixESnoFV[[i,2,1]],i2]=
            MultiplicityFactor[mixESnoFV[[i,1,1]],i2];
          i2++;];
        If[
          TrueQ[conj[
                  mixESnoFV[[i,1,1]]]\[Equal]mixESnoFV[[i,1,1]]]\[Equal]True,
          realVar=Join[realVar,{mixESnoFV[[i,2,1]]}];];
        If[FreeQ[parameters,mixESnoFV[[i,2,2]]]\[Equal]True,
          
          parameters=
              Join[parameters,{{mixESnoFV[[i,2,2]],{generation,flavor,
                      flavor},{gen,flavors,flavors}}}];
          ];
        i++;];
      
      
      (* Mixing Mass Definition *)
      
      MatrixValues = {};
      MatrixNames = Transpose[Transpose[mixES][[2]]][[2]];
      
      
      For[i=1, i\[LessEqual]Length[ParameterDefinitions],
        If[( (Dependence /.  ParameterDefinitions[[i,2]])  =!= 
                None )&&  ((Dependence /.  ParameterDefinitions[[i,2]]) =!= 
                Dependence),
          If[FreeQ[MatrixNames,ParameterDefinitions[[i,1]]]\[Equal]False,
              
              MatrixValues = 
                  Join[MatrixValues,{{ParameterDefinitions[[i,1]], 
                        Dependence /.  ParameterDefinitions[[i,2]]}}];
              ];
          ];
        i++;];
      
      For[i=1,i\[LessEqual]Length[mixES],
        If[FreeQ[MatrixValues,mixES[[i,2,2]]]\[Equal]False,
          maxX=0; maxY=0;newMatrixName=None;
          
          matrixV=Extract[MatrixValues,
                Position[MatrixValues,mixES[[i,2,2]]][[1,1]]][[2]];
          UsedDependences = Join[UsedDependences,{mixES[[i,2,2]]}];
          For[j1=1,j1\[LessEqual]Length[matrixV],
            For[j2=1,j2\[LessEqual]Length[matrixV[[j1]]],
              
              subAlways=
                Join[subAlways,{mixES[[i,2,2]][j1,j2]\[Rule] 
                      matrixV[[j1,j2]]}];
              newSymbols = Cases[matrixV[[j1,j2]],x_Symbol,2];
              If[newSymbols\[Equal]{},
                If[NumericQ[matrixV[[j1,j2]]]\[Equal]False,
                    newMatrixName = matrixV[[j1,j2]][[0]];
                    valX=matrixV[[j1,j2]][[1]];
                    valY=matrixV[[j1,j2]][[2]];
                    If[valX>maxX, maxX=valX;];
                    If[valY>maxY, maxY=valY;];
                    ];
                ];
              For[j3=1,j3\[LessEqual]Length[newSymbols],
                If[FreeQ[parameters,newSymbols[[j3]]]\[Equal]True, 
                  parameters=Join[parameters,{{newSymbols[[j3]],{},{1}}}];
                  realVar=Join[realVar,{newSymbols[[j3]]}];
                  ];
                j3++;];
              Inv[mixES[[i,2,2]]][j1,j2]=Simplify[Inverse[matrixV]][[j1,j2]];
              j2++;];
            j1++;];
           If[newMatrixName=!=None,
            
            parameters=
              Join[parameters,{{newMatrixName,{generation,generation},{maxX,
                      maxY}}}];
            pos=Position[ParameterDefinitions,newMatrixName,2];
            If[pos=!={},
              
              If[(Real /. Extract[ParameterDefinitions,
                            pos[[1,1]]][[2]])\[Equal]True,
                  realVar=Join[realVar,{newMatrixName}];
                  ];
              ];
            ];
          ];
        
        If[FreeQ[ParameterDefinitions,mixES[[i,2,2]]]\[Equal]False,
          
          If[(Real /. Extract[ParameterDefinitions,
                        Position[ParameterDefinitions,mixES[[i,2,2]]][[1,
                            1]]][[2]])\[Equal]True,
              realVar=Join[realVar,{mixES[[i,2,2]]}];
              ];
          ];
        
        OffSetArray={0};
        For[j=1,j\[LessEqual] Length[mixES[[i,1]]],
          If[j\[Equal]1,
            OffSet=1-getGenStart[mixES[[i,1,j]]];,
            
            OffSet+=(getGen[mixES[[i,1,j-1]]]-
                  getGenStart[mixES[[i,1,j-1]]]+1);
            OffSetArray=Join[OffSetArray,{OffSet}];
            ];
          If[getType[mixES[[i,1,j]]]===F,
            If[Head[mixES[[i,1,j]]]===conj,
                
                subDef=Join[
                    subDef,{Simplify[
                            getFull[RE[mixES[[i,1,j]]]] /.subIndizesMixStart][
                          fnr_]\[Rule]sum[
                            Hold[ToExpression[
                                "n"<>StringDrop[ToString[xgen],3]]],
                            GetGenStart[mixES[[i,2,1]]],
                            GetGen[mixES[[i,2,1]]]]*
                          repl[xgen] mixES[[i,2,2]][
                            Hold[ToExpression[
                                "n"<>StringDrop[ToString[xgen],3]]],
                            OffSet+xgen] *
                          conj[mixES[[i,2,
                                    1]][(getIndizes[
                                      RE[mixES[[i,1,
                                        j]]]]/.subIndizesMixEnde)][fnr]]} ],
                subDef=
                    Join[subDef,{Simplify[
                              getFull[mixES[[i,1,j]]] /. subIndizesMixStart][
                            fnr_]\[Rule] 
                          sum[Hold[
                                ToExpression[
                                  "n"<>StringDrop[ToString[xgen],3]]],
                              GetGenStart[mixES[[i,2,1]]],
                              GetGen[mixES[[i,2,1]]]]*
                            repl[xgen] conj[
                              mixES[[i,2,2]][
                                Hold[ToExpression[
                                    "n"<>StringDrop[ToString[xgen],3]]],
                                OffSet+xgen]] *
                            mixES[[i,2,
                                    1]][(getIndizes[
                                      RE[mixES[[i,1,
                                        j]]]]/.subIndizesMixEnde)][fnr]}];
                ];,
            If[Head[mixES[[i,1,j]]]===conj,
                
                subDef=Join[
                    subDef,{Simplify[
                          getFull[
                              RE[mixES[[i,1,j]]]] /.subIndizesMixStart]\[Rule]
                        sum[Hold[
                              ToExpression[
                                "n"<>StringDrop[ToString[xgen],3]]],
                            GetGenStart[mixES[[i,2,1]]],
                            GetGen[mixES[[i,2,1]]]]*
                          repl[xgen] mixES[[i,2,2]][
                            Hold[ToExpression[
                                "n"<>StringDrop[ToString[xgen],3]]],
                            OffSet+xgen] *
                          conj[mixES[[i,2,
                                  1]][(getIndizes[
                                    RE[mixES[[i,1,
                                        j]]]]/.subIndizesMixEnde)]]} ],
                
                subDef=Join[
                      subDef,{Simplify[
                            getFull[mixES[[i,1,j]]] /. 
                              subIndizesMixStart]\[Rule] 
                          sum[Hold[
                                ToExpression[
                                  "n"<>StringDrop[ToString[xgen],3]]],
                              GetGenStart[mixES[[i,2,1]]],
                              GetGen[mixES[[i,2,1]]]]*
                            repl[xgen] conj[
                              mixES[[i,2,2]][
                                Hold[ToExpression[
                                    "n"<>StringDrop[ToString[xgen],3]]],
                                OffSet+xgen]] *
                            mixES[[i,2,
                                  1]][(getIndizes[
                                    RE[mixES[[i,1,
                                        j]]]]/.subIndizesMixEnde)]}];
                ];
            ]; 
          j++;];
        If[getType[mixES[[i,1,1]]]=!=F,
          
          subDefInverse=
              Join[subDefInverse,{mixES[[i,2,
                          1]][(getIndizes[
                            RE[mixES[[i,1,1]]]]/.subIndizesMixStart)]\[Rule] 
                    Sum[(getFull[mixES[[i,1,j]]]/.subIndizesMixEnde )sum[
                          Hold[ToExpression[
                              "n"<>StringDrop[ToString[xgen],3]]],
                          getGenStart[mixES[[i,1,j]]],getGen[mixES[[i,1,j]]]]*
                        repl[xgen]*
                        Inv[mixES[[i,2,2]]][
                          OffSetArray[[j]]+
                            Hold[ToExpression[
                                "n"<>StringDrop[ToString[xgen],3]]],xgen], {j,
                        1,Length[mixES[[i,1]]]}]}];,
          
          subDefInverse=
              Join[subDefInverse,{mixES[[i,2,
                            1]][(getIndizes[
                              RE[mixES[[i,1,1]]]]/.subIndizesMixStart)][
                      fnr_]\[Rule] 
                    Sum[(getFull[mixES[[i,1,j]]][fnr]/.subIndizesMixEnde )sum[
                          Hold[
                            ToExpression["n"<>StringDrop[ToString[xgen],3]]],
                          getGenStart[mixES[[i,1,j]]],getGen[mixES[[i,1,j]]]]*
                        repl[xgen]*
                        Inv[mixES[[i,2,2]]][
                          OffSetArray[[j]]+
                            Hold[ToExpression[
                                "n"<>StringDrop[ToString[xgen],3]]],xgen], {j,
                        1,Length[mixES[[i,1]]]}]}];
          ];
          i++;]; 
      
      
      
      For[i=1,i\[LessEqual]Length[mixESnoFV],
        
        If[FreeQ[ParameterDefinitions,mixESnoFV[[i,2,2]]]\[Equal]False,
          
          If[(Real /. Extract[ParameterDefinitions,
                        Position[ParameterDefinitions,mixESnoFV[[i,2,2]]][[1,
                            1]]][[2]])\[Equal]True,
              realVar=Join[realVar,{mixESnoFV[[i,2,2]]}];
              ];
          ];
        
        OffSetArray={0};
        OffSet=1;
        For[j=1,j\[LessEqual] Length[mixESnoFV[[i,1]]],
          If[getType[mixESnoFV[[i,1,j]]]===F,
            If[Head[mixESnoFV[[i,1,j]]]===conj,
                
                subDef=Join[
                    subDef,{Simplify[
                            getFull[
                                RE[mixESnoFV[[i,1,j]]]] /.subIndizesMixStart][
                          fnr_]\[Rule]sum[
                            Hold[ToExpression[
                                "fla"<>StringDrop[ToString[xgen],3]]],1,
                            Length[mixESnoFV[[i,1]]]]*
                          mixESnoFV[[i,2,2]][xgen][
                            Hold[ToExpression[
                                "fla"<>StringDrop[ToString[xgen],3]]],
                            OffSet] *
                          conj[mixESnoFV[[i,2,
                                    1]][(Insert[
                                      getIndizes[RE[mixESnoFV[[i,1,j]]]],
                                      flavor,2]/.subIndizesMixEndeNoFV)][
                              fnr]]} ],
                
                subDef=Join[
                      subDef,{Simplify[
                              getFull[mixESnoFV[[i,1,j]]] /. 
                                subIndizesMixStart][fnr_]\[Rule] 
                          sum[Hold[
                                ToExpression[
                                  "fla"<>StringDrop[ToString[xgen],3]]],1,
                              Length[mixESnoFV[[i,1]]]]mixESnoFV[[i,2,2]][
                                xgen][
                              Hold[ToExpression[
                                  "fla"<>StringDrop[ToString[xgen],3]]],
                              OffSet] *
                            mixESnoFV[[i,2,
                                    1]][(Insert[
                                      getIndizes[RE[mixESnoFV[[i,1,j]]]],
                                      flavor,2]/.subIndizesMixEndev)][fnr]}];
                ];,
            If[Head[mixESnoFV[[i,1,j]]]===conj,
                
                subDef=Join[
                    subDef,{Simplify[
                          getFull[
                              RE[mixESnoFV[[i,1,
                                    j]]]] /.subIndizesMixStart]\[Rule]sum[
                            Hold[ToExpression[
                                "fla"<>StringDrop[ToString[xgen],3]]],1,
                            Length[mixESnoFV[[i,1]]]]mixESnoFV[[i,2,2]][xgen][
                            Hold[ToExpression[
                                "fla"<>StringDrop[ToString[xgen],3]]],
                            OffSet] *
                          conj[mixESnoFV[[i,2,
                                  1]][(Insert[
                                    getIndizes[RE[mixESnoFV[[i,1,j]]]],flavor,
                                    2]/.subIndizesMixEndeNoFV)]]} ],
                
                subDef=Join[
                      subDef,{Simplify[
                            getFull[mixESnoFV[[i,1,j]]] /. 
                              subIndizesMixStart]\[Rule] 
                          sum[Hold[
                                ToExpression[
                                  "fla"<>StringDrop[ToString[xgen],3]]],1,
                              Length[mixESnoFV[[i,1]]]]conj[
                              mixESnoFV[[i,2,2]][xgen][
                                Hold[ToExpression[
                                    "fla"<>StringDrop[ToString[xgen],3]]],
                                OffSet]] *
                            mixESnoFV[[i,2,
                                  1]][(Insert[
                                    getIndizes[RE[mixESnoFV[[i,1,j]]]],flavor,
                                    2]/.subIndizesMixEndeNoFV)]}];
                ];
            ]; 
          If[getType[mixESnoFV[[i,1,1]]]=!=F,
            
            subDefInverse=
                Join[subDefInverse,{mixESnoFV[[i,2,
                            1]][(Insert[getIndizes[RE[mixESnoFV[[i,1,1]]]],
                              flavor,2]/.subIndizesMixStart)]\[Rule] 
                      Sum[(getFull[
                                mixESnoFV[[i,1,
                                    j]]]/.subIndizesMixEndeNoFV )sum[
                            Hold[ToExpression[
                                "fla"<>StringDrop[ToString[xgen],3]]],1,
                            Length[mixESnoFV[[i,1]]]]*
                          Inv[mixESnoFV[[i,2,2]]][xgen][j,
                            Hold[ToExpression[
                                "fla"<>StringDrop[ToString[xgen],3]]]], {j,1,
                          Length[mixESnoFV[[i,1]]]}]}];,
            
            subDefInverse=
                Join[subDefInverse,{mixESnoFV[[i,2,
                              1]][(getIndizes[
                                RE[mixESnoFV[[i,1,1]]]]/.subIndizesMixStart)][
                        fnr_]\[Rule] 
                      Sum[(getFull[mixESnoFV[[i,1,j]]][
                                fnr]/.subIndizesMixEndeNoFV )sum[
                            Hold[ToExpression[
                                "fla"<>StringDrop[ToString[xgen],3]]],1,
                            Length[mixESnoFV[[i,1]]]]*
                          Inv[mixESnoFV[[i,2,2]]][xgen][j,
                            Hold[ToExpression[
                                "fla"<>StringDrop[ToString[xgen],3]]]], {j,1,
                          Length[mixESnoFV[[i,1]]]}]}];
            ];
          OffSet++;
          j++;];
          i++;]; 
      
      MMatrices=
        CalcMassMatrices[mixBasis, Potential,
          Transpose[Transpose[mixES][[2]]][[2]],True];
      
      If[mixBasisNoFV=!={},
        MMatricesNo=
            CalcMassMatrices[mixBasisNoFV, Potential,
              Transpose[Transpose[mixESnoFV][[2]]][[2]],False];
        ];
      
      
      UpdateGaugeTransformations[subDef,subDefInverse];
      
      For[i=1,i\[LessEqual]Length[mixES], 
        For[j=1,j\[LessEqual] Length[mixES[[i,1]]],
          
          If[FreeQ[Particles[Current],RE[mixES[[i,1,j]]]],
            Message[ModelFile::UnknownParticleRotations,
                RE[mixES[[i,1,j]]]];];
          delParticle[RE[mixES[[i,1,j]]]]; 
          j++;];i++;];
      
      For[i=1,i\[LessEqual]Length[mixESnoFV], 
        For[j=1,j\[LessEqual] Length[mixESnoFV[[i,1]]],
          
          If[FreeQ[Particles[Current],RE[mixESnoFV[[i,1,j]]]],
            Message[ModelFile::UnknownParticleRotations,
                RE[mixESnoFV[[i,1,j]]]];];
          delParticle[RE[mixESnoFV[[i,1,j]]]]; 
          j++;];i++;];
      
      If[mixBasisNoFV=!={},
        Return[{subDef,Join[MMatrices[[1]],MMatricesNo[[1]]]/.subAlways,
              Join[MMatrices[[2]],MMatricesNo[[2]]]/.subAlways,
              Join[mixBasis,mixBasisNoFV],Join[mixMatES,mixMatESnoFV],
              Join[mixES,mixESnoFV],Join[mixedNames,mixedNamesNoFV]}];,
        Return[{subDef,MMatrices[[1]]/.subAlways,MMatrices[[2]]/.subAlways,
              mixBasis,mixMatES,mixES,mixedNames}];
        ];
      
      ];



(* ----------------------------------------------- *)
(* 
  Calculate Effective Operators *)
(* \
----------------------------------------------- *)

MakeEffective:=Block[{Masse, temp, i,l,allGenerations},
      IntegrateOutNew={};
      DeleteParticlesNew = {};
      
      For[i=1,i\[LessEqual] Length[IntegrateOut],
        EffectiveTheory=True;
        genMax = 6;
        If[
          MemberQ[Particles[Current],getBlank[IntegrateOut[[i]]],2]\[Equal]
            True,
          Print["Integrate Out ", IntegrateOut[[i]]];
          
          If[MemberQ[MajoranaPart,getBlank[IntegrateOut[[i]]]/.diracSubBack1]===
              False,
            
            Masse = DPV[DPV[Potential,getBlank[IntegrateOut[[i]]],1,1],
                        conj[getBlank[IntegrateOut[[i]]]], 2,2] /. 
                      Flatten[Map[vacHead,vacuum]] /. zero[a_]\[Rule]0*a /. 
                  subFinal ;,
            
            Masse = DPV[DPV[Potential,getBlank[IntegrateOut[[i]]],1,1],
                        getBlank[IntegrateOut[[i]]], 2,2] /. 
                      Flatten[Map[vacHead,vacuum]] /. zero[a_]\[Rule]0 *a/. 
                  subFinal;
            ];
          
          
          temp=DIntOut[Lagrangian,getFull[getBlank[IntegrateOut[[i]]]]];
          If[getBlank[IntegrateOut[[i]]]===IntegrateOut[[i]],
            OutGenStart=getGenStart[IntegrateOut[[i]]];
            OutGenEnde=getGen[IntegrateOut[[i]]];,
            OutGenStart=IntegrateOut[[i,1,1]];
            OutGenEnde=IntegrateOut[[i,1,2]];
            ];
          
          
          For[j=OutGenStart,j\[LessEqual] OutGenEnde,
            (* 
              Mass[getBlank[IntegrateOut[[i]]]][
                    j]  = (Masse /.subREfinal[2,1]) /. gIO1\[Rule]j; *)
      
                  If[(Masse /.subREfinal[2,1])=!=0,
              If[getGen[IntegrateOut[[i]]]>1,
                  
                  Mass[getBlank[
                            IntegrateOut[[i]]][{j}]]  = (Masse /.subREfinal[2,
                              1]) /. gIO1\[Rule]j;,
                  
                  Mass[getBlank[
                          IntegrateOut[[i]]]]  = (Masse /.subREfinal[2,1]) /. 
                        gIO1\[Rule]j;
                  ];
              ];
            j++;];
          
          
          (* 
            EffectiveOperators += (1/Mass[getBlank[IntegrateOut[[i]]]][gIO1]*
                        temp /.sum[gIO1,a_,b_]\[Rule]1 )*
                  sum[gIO1,OutGenStart,OutGenEnde]; *)
          
          If[getGen[IntegrateOut[[i]]]>1,
            
            EffectiveOperators += (1/
                          Mass[getBlank[IntegrateOut[[i]]][{gIO1}]]*
                        temp /.sum[gIO1,a_,b_]\[Rule]1 )*
                  sum[gIO1,OutGenStart,OutGenEnde];,
            
            EffectiveOperators += (1/Mass[getBlank[IntegrateOut[[i]]]]*
                        temp /.sum[gIO1,a_,b_]\[Rule]1 )*
                  sum[gIO1,OutGenStart,OutGenEnde];
            ];
          allGenerations=Particles[Current];
          If[OutGenStart\[Equal]1,
            
            pos = Position[Particles[Current],getBlank[IntegrateOut[[i]]]][[1,
                  1]];
            
            allGenerations[[pos]]={Extract[Particles[Current],{pos,1}],
                OutGenEnde+1,Extract[Particles[Current],{pos,3}],
                Extract[Particles[Current],{pos,4}],
                Extract[Particles[Current],{pos,5}]};,
            
            pos = Position[Particles[Current],getBlank[IntegrateOut[[i]]]][[1,
                  1]];
            
            allGenerations[[pos]]={Extract[Particles[Current],{pos,1}],1,
                OutGenStart-1,Extract[Particles[Current],{pos,4}],
                Extract[Particles[Current],{pos,5}]};
            ];
          Particles[Current]=allGenerations;,
           IntegrateOutNew=Join[IntegrateOutNew,{IntegrateOut[[i]]}]; 
          ];
        i++;
        ];
      
      IntegrateOut = IntegrateOutNew;
      
      allGenerations=Particles[Current];
      
      For[i=1,i\[LessEqual] Length[DeleteParticles],
        If[
          MemberQ[Particles[Current],getBlank[DeleteParticles[[i]]],
              2]\[Equal]True,
          If[getBlank[DeleteParticles[[i]]]===DeleteParticles[[i]],
            OutGenStart=getGenStart[DeleteParticles[[i]]];
            OutGenEnde=getGen[DeleteParticles[[i]]];,
            OutGenStart=DeleteParticles[[i,1,1]];
            OutGenEnde=DeleteParticles[[i,1,2]];
            ];
          
          If[OutGenStart\[Equal]1,
            pos = 
              Position[Particles[Current],getBlank[DeleteParticles[[i]]]][[1,
                  1]];
            
            allGenerations[[pos]]={Extract[Particles[Current],{pos,1}],
                OutGenEnde+1,Extract[Particles[Current],{pos,3}],
                Extract[Particles[Current],{pos,4}],
                Extract[Particles[Current],{pos,5}]};,
            
            pos = Position[Particles[Current],
                  getBlank[DeleteParticles[[i]]]][[1,1]];
            
            allGenerations[[pos]]={Extract[Particles[Current],{pos,1}],1,
                OutGenStart-1,Extract[Particles[Current],{pos,4}],
                Extract[Particles[Current],{pos,5}]};
            ];,
           
          DeleteParticlesNew=
              Join[DeleteParticlesNew,{DeleteParticles[[i]]}]; 
          ];
        i++;];
      
      Particles[Current]=allGenerations;
      
      
      
      DeleteParticles = DeleteParticlesNew; 
      ];




(*-----------------------------------------------------------*)
(* 
  Calculate Mass Matrices *)
\
(*-----------------------------------------------------------*)


CalcMassMatrices[basis_, potential_, names_,FV_]:=
    Block[{i1,j,i2,off,l,m,k,n, MassMatrices, MassMatricesFull, subVac},
      
      Print["Calc Mass Matrices"];
      
      
      subVac=Flatten[Map[vacHead,vacuum]];
      
      MassMatrices=Table[{},{Length[basis]}];
      
      For[i=1,i\[LessEqual]Length[basis],
        
        If[RE[basis[[i,1]]]===RE[basis[[i,2]]],
          Print["    For ",basis[[i,1]]];,
          Print["    For ",basis[[i,1]],basis[[i,2]]];
          ];
        
        MassMatrices[[i]]=
          Table[DMM[DMM[potential,basis[[i,1,m]],m,"m",1],basis[[i,2,n]],n,"n",
                      2]/.subVac /. Mom[_]\[Rule]0 /. zero[a_]\[Rule]nix /. 
              nix\[Rule]0,{m,1,Length[basis[[i,1]]]},{n,1,
              Length[basis[[i,1]]]}];
        
        i++;];
      
      MassMatricesFull = Table[{},{Length[basis]}];
      
      namecounter=1;
      
      For[i=1,i\[LessEqual]Length[MassMatrices],
        ltest=MassMatrices[[i]];
        If[FV\[Equal]True,
          
          dim=Table[{getGenStart[basis[[i,1,n]]],getGen[basis[[i,1,n]]]},{n,1,
                Length[basis[[i,1]]]}];
          
          dimTotal = 
            Table[-getGenStart[basis[[i,1,n]]]+1+getGen[basis[[i,1,n]]],{n,1,
                Length[basis[[i,1]]]}];,
          dim=Table[{1,1},{n,1,Length[basis[[i,1]]]}];
          dimTotal = Table[1,{n,1,Length[basis[[i,1]]]}];
          ];
        
        If[RE[basis[[i,1]]]===RE[basis[[i,2]]],
          
          dimMatrizes = 
            Join[dimMatrizes,{{names[[namecounter]],Total[dimTotal]}}];
          namecounter++;,
          
          dimMatrizes = 
            Join[dimMatrizes,{{names[[namecounter]],Total[dimTotal]}}];
          namecounter++;
          
          dimMatrizes = 
            Join[dimMatrizes,{{names[[namecounter]],Total[dimTotal]}}];
          namecounter++;
          ];
        
        MassMatricesFull[[i]]=Table[0,{Total[dimTotal]},{Total[dimTotal]}];
        zeile=0;
        	For[k=1,k\[LessEqual]Length[dim],
          For[l=dim[[k,1]],l\[LessEqual]dim[[k,2]],
            zeile++;
            spalte=0;
            For[m=1,m\[LessEqual]Length[dim],
              For[n=dim[[m,1]],n\[LessEqual]dim[[m,2]],
                spalte++;
                If[FreeQ[OffSetFlavors,basis[[i,1,1]]],
                  If[FV\[Equal]True,
                      
                      tElement=
                        ltest[[k,m]]/.{ToExpression[
                                        "gm"<>ToString[k]]\[Rule]l,
                                    ToExpression[
                                        "gn"<>ToString[
                                        m]]\[Rule]n}/. (Reverse/@
                                    subIndFinalX[1,m,"n"]) /. 
                              subValue[1,1]/. (Reverse/@
                                subIndFinalX[1,k,"m"]) /. subValue[1,1];
                      
                      MassMatricesFull[[i,zeile,spalte]]=
                        CalcDelta[tElement/.subAlways];,
                      
                      tElement=
                        ltest[[k,m]]/.{ToExpression[
                                        "fm"<>ToString[k]]\[Rule]l,
                                    ToExpression[
                                        "fn"<>ToString[
                                        m]]\[Rule]n}/. (Reverse/@
                                    subIndFinalX[1,m,"n"]) /. 
                              subValue[1,1]/. (Reverse/@
                                subIndFinalX[1,k,"m"]) /. subValue[1,1];
                      
                      MassMatricesFull[[i,zeile,spalte]]=
                        CalcDelta[tElement/.subAlways];
                      ];,
                  pos=Position[OffSetFlavors,basis[[i,1,1]]][[1,1]];
                  offset=Extract[OffSetFlavors,pos][[2]];
                  
                  tElement=
                    ltest[[k,m]]/.{ToExpression["gm"<>ToString[k]]\[Rule]l+
                                    offset,
                                ToExpression["gn"<>ToString[m]]\[Rule]n+
                                    offset}/. (Reverse/@
                                subIndFinalX[1,m,"n"]) /. 
                          subValue[1,1]/. (Reverse/@subIndFinalX[1,k,"m"]) /. 
                      subValue[1,1];
                  
                  MassMatricesFull[[i,zeile,spalte]]=
                    CalcDelta[tElement/.subAlways];
                  ];
                n++;];
              m++;];
            l++;];
          k++;];
        i++;];
      
      (*
        For[i=1,i\[LessEqual]Length[basis],
            TestReducibility[MassMatricesFull[[i]],dimMatrizes[[i,1]]];
            i++;];
        *)
      
      dimMatrizesAll = Join[dimMatrizesAll,dimMatrizes];
      
      For[i=1,i\[LessEqual]Length[dimMatrizes],
        ListMatrixProdukt = 
          Join[ListMatrixProdukt,{{dimMatrizes[[i,1]],dimMatrizes[[i,1]],
                dimMatrizes[[i,2]],Delta}}];
        i++;];
      
      If[FV\[Equal]False,
        For[i=1,i\[LessEqual]Length[MassMatricesFull],
            
            MassMatricesFull[[i]]=
              Table[MassMatricesFull[[i]] /. {gen1\[Rule]k},{k,1,
                  getGen[basis[[i,1,1]]]}];
            i++;];
        ];
      
      
      Return[{CalcDelta[MassMatrices],CalcDelta[MassMatricesFull]}];
      
      ];


 CalculateTreeLevelMasses:=
    Block[{i,j,k,mass,statelist,partList, states,defList,entry,pdgList={},
        doubleCheck,dc},
      Print["Calculating Tree Level Masses"];
      LesHouchesListMasses={};
      subNum={};
      subNumDependencesMasses={};
      
      
      For[j=1,j\[LessEqual]Length[NameOfStates],
        listMasses={};
        listWidth={};
        states = NameOfStates[[j]];
        Print["     For ",states];
        pdgList={};
        usedPDG={};
        partList=Particles[NameOfStates[[j]]];
        defList=ParticleDefinitions[NameOfStates[[j]]];
         For[i=1,i\[LessEqual]Length[partList],
          auto=True;
          
          pos=Position[defList,
              partList[[i,1]]/.diracSubBack1 /.diracSubBack2];
          If[pos=!={},
            entry= Extract[defList,pos[[1,1]]][[2]];
            massGiven = Mass /.entry;
            widthGiven =  Width /. entry;
            PDGNr = PDG/. entry;
            
            doubleCheck=
              DeleteCases[
                DeleteCases[Intersection[Flatten[{pdgList}],Flatten[{PDGNr}]],
                  0],PDG];
            If[Length[doubleCheck]>0 && FreeQ[usedPDG,pos[[1,1]]],
              For[dc=1,dc\[LessEqual]Length[doubleCheck],
                  Message[PDG::DoubleCheck,doubleCheck[[dc]]];
                  dc++
                  ];
              ];
            
            
            pdgList=Join[
                pdgList,{{partList[[i,1]]/.diracSubBack1 /.diracSubBack2,
                    PDGNr}}];
            usedPDG=Join[usedPDG,{pos[[1,1]]}];
            If[Length[widthGiven]>1,
              For[k=1,k\[LessEqual]Length[widthGiven],
                  listWidth = 
                    Join[listWidth,{WidthUsed[partList[[i,1]][k]] \[Rule]
                          widthGiven[[k]]}];
                  If[getTypeOld[partList[[i,1]]]===F,
                    
                    listWidth = 
                        Join[listWidth,{WidthUsed[(partList[[i,
                                        1]]/.diracSubBack1 /.diracSubBack2)[
                                  k]] \[Rule]widthGiven[[k]]}];
                    ];
                  k++;];,
              If[getGen[partList[[i,1]]]>1,
                  For[k=1,k\[LessEqual]Length[getGen[partList[[i,1]]]],
                      If[widthGiven[[k]]=!=External,
                        
                        listWidth = 
                          Join[listWidth,{WidthUsed[
                                  partList[[i,1]][k]] \[Rule]widthGiven}];
                        If[getTypeOld[partList[[i,1]]]===F,
                          
                          listWidth = 
                              Join[listWidth,{WidthUsed[(partList[[i,
                                        1]]/.diracSubBack1 /.diracSubBack2)[
                                        k]] \[Rule]widthGiven}];
                          ];
                        ];
                      k++;];,
                  
                  listWidth = 
                    Join[listWidth,{WidthUsed[
                            partList[[i,1]]] \[Rule]widthGiven}];
                  If[getTypeOld[partList[[i,1]]]===F,
                    
                    listWidth = 
                        Join[listWidth,{WidthUsed[(partList[[i,
                                        1]]/.diracSubBack1 /.diracSubBack2)] \
\[Rule]widthGiven}];
                    ];
                  ];
              ];
            
            Switch[massGiven,
              Automatic,
              	massCalc=TreeMass[partList[[i,1]],NameOfStates[[j]]];
              	
              listMasses=
                Join[listMasses,{Mass[partList[[i,1]]] \[Rule]massCalc}];
              	If[getType[partList[[i,1]]]===F,
                	
                listMasses=
                    Join[listMasses,{Mass[
                            partList[[i,
                                    1]]/.diracSubBack1/.diracSubBack2] \
\[Rule]massCalc}];
                	];,
              
              LesHouches,
              	If[Length[PDGNr]\[Equal]1,
                  	
                  listMasses=
                    Join[listMasses,{Mass[
                            partList[[i,
                                    1]] /.diracSubBack1/.diracSubBack2]\[Rule]\
 MassRead[partList[[i,1]] /.diracSubBack1/.diracSubBack2]}];
                  	LesHouchesListMasses = Join[LesHouchesListMasses,
                      	{{MassRead[
                            partList[[i,
                                    1]] /.diracSubBack1/.diracSubBack2],{{\
Mass,If[Head[PDGNr]===List,PDGNr[[1]],PDGNr]},1}}}];,
                  	
                  listMasses=
                    Join[listMasses,{Mass[(partList[[i,1]][
                                    gen_]) /.diracSubBack1/.diracSubBack2]\
\[Rule] MassRead[(partList[[i,1]][gen]) /.diracSubBack1/.diracSubBack2]}];
                  	For[k=1,k\[LessEqual]Length[PDGNr],
                    	
                    LesHouchesListMasses = 
                      Join[LesHouchesListMasses,{{MassRead[
                              partList[[i,1]][
                                    k]  /.diracSubBack1/.diracSubBack2],{{\
Mass,PDGNr[[k]]},1}}}];
                    	k++;];
                  	];,
              Dependence,
              
              subNumDependencesMasses=
                  Join[subNumDependencesMasses,{Mass[
                          partList[[i,
                                  1]]/.diracSubBack1 \
/.diracSubBack2]\[Rule](MassDependence /.  defList[[pos[[1,1]],2]])}];,
              _,
              	If[Length[massGiven]>1,
                  	For[k=1,k\[LessEqual]Length[massGiven],
                      	If[massGiven[[k]]=!=LesHouches,
                        	
                        subNum=
                          Join[subNum,{MassGiven[
                                  partList[[i,1]][
                                        k] /.diracSubBack1/.diracSubBack2]\
\[Rule]  massGiven[[k]]}];
                        	
                        listMasses=
                          Join[listMasses,{Mass[(partList[[i,1]][
                                        k] /.diracSubBack1/.diracSubBack2)]\
\[Rule] MassGiven[partList[[i,1]][k] /.diracSubBack1/.diracSubBack2]}];,
                        	
                        listMasses=
                          Join[listMasses,{Mass[(partList[[i,1]][
                                        k]) /.diracSubBack1/.diracSubBack2]\
\[Rule] MassRead[(partList[[i,1]][k]) /.diracSubBack1/.diracSubBack2]}];
                        	
                        LesHouchesListMasses = 
                          Join[LesHouchesListMasses,{{MassRead[
                                  partList[[i,1]][
                                        k]  /.diracSubBack1/.diracSubBack2],{{\
Mass,PDGNr[[k]]},1}}}];
                        	];
                      	k++;];,
                  
                  subNum=Join[
                      subNum,{MassGiven[
                            partList[[i,
                                    1]]/.diracSubBack1/.diracSubBack2]\[Rule] \
 massGiven}];
                  
                  listMasses=
                    Join[listMasses,{Mass[
                            partList[[i,
                                    1]] /.diracSubBack1/.diracSubBack2]\[Rule]\
 MassGiven[partList[[i,1]] /.diracSubBack1/.diracSubBack2]}];
                  	];
              ];
            ];
          i++;];
        
        PDGlist[states]=pdgList;
        
        MassesTemp[states]=listMasses;
        Width[states]=listWidth;
        
        j++;];
      
      For[i=1,i\[LessEqual]Length[subNumDependencesMasses],
        subNumDependences = 
          Join[subNumDependences,{subNumDependencesMasses[[i]]}];
        parameters=Join[parameters,{{subNumDependencesMasses[[i,1]],{},{}}}];
        realVar=Join[realVar,{subNumDependencesMasses[[i,1]]}];
        addNewSym[subNumDependencesMasses[[i,1]], 
          subNumDependencesMasses[[i,2]]];
        i++;];
      
      ]; 


GenerateFlavors[type_]:=Block[{i,j},Print["Split Flavors"];
      OffSetFlavors={};
      flavorSub={};
      flavorInverse={};
      flav=DEFINITION[type][Flavors];
      
      For[i=1,i\[LessEqual]Length[flav],
        If[getType[flav[[i,1]]]===F,
          
          flavorSub=
              Join[flavorSub,{flav[[i,1]][{x_,y___}][c_]\[Rule]Sum[
                      Delta[x,n]*
                        repl[x]flav[[i,2,n]][{Hold[
                                ToExpression["n"<>StringDrop[ToString[x],3]]],
                              y}][c] Delta[
                          Hold[ToExpression["n"<>StringDrop[ToString[x],3]]],
                          1],{n,1,Length[flav[[i,2]]]}]}] ;,
          
          flavorSub=
              Join[flavorSub,{flav[[i,1]][{x_,y___}]\[Rule]Sum[
                      Delta[x,n]*repl[x]*
                        flav[[i,2,n]][{Hold[
                              ToExpression["n"<>StringDrop[ToString[x],3]]],
                            y}] Delta[
                          Hold[ToExpression["n"<>StringDrop[ToString[x],3]]],
                          1],{n,1,Length[flav[[i,2]]]}]}];
          ];
        
        
        
        For[j=1,j\[LessEqual]Length[flav[[i,2]]],
          
          addParticle[flav[[i,2,j]],getIndizes[flav[[i,1]]],1,
            getType[flav[[i,1]]]];
          If[getType[flav[[i,1]]]===F,
            
            flavorInverse=
                Join[flavorInverse,{flav[[i,2,j]][{x_,y___}][
                        c_]\[Rule]Delta[x,j] flav[[i,1]][{x,y}][c]}];,
            flavorInverse=
                Join[flavorInverse,{flav[[i,2,j]][{x_,y___}]\[Rule]
                      Delta[x,j] flav[[i,1]][{x,y}]}];
            ];
          OffSetFlavors=Join[OffSetFlavors,{{flav[[i,2,j]],j-1}}];
          
          If[FreeQ[realVar,flav[[i,1]]]\[Equal]False,
            realVar=Join[realVar,{flav[[i,2,j]]}];];
          j++;];
        delParticle[flav[[i,1]]];
        i++];
      FlavorSub[type]=flavorSub;
      FlavorSubInverse[type]=flavorInverse;
      UpdateGaugeTransformations[flavorSub,flavorInverse];
      ];


GeneratePhases[type_]:=Block[{i,j},
      Print["Add Phases"];
      phaseSub={};
      phaseInverse={};
      phas=DEFINITION[type][Phases];
      
      For[i=1,i\[LessEqual]Length[phas],
        If[getType[phas[[i,1]]]===F,
          ParticlePhases = Join[ParticlePhases,{phas[[i]]}];
          
          ParticlePhases = 
            Join[ParticlePhases,{{phas[[i,1]] /.diracSubBack1 /.diracSubBack2,
                  phas[[i,2]]}}];
          
          phaseSub=
            Join[phaseSub,{phas[[i,1]][{y___}][a_]\[Rule]
                  phas[[i,1]][{y}][a] phas[[i,2]]}];
          
          phaseInverse=
            Join[phaseInverse,{phas[[i,1]][{y___}][
                    a_]\[Rule]phas[[i,1]][{y}][a] conj[phas[[i,2]]]}];,
          ParticlePhases = Join[ParticlePhases,{phas[[i]]}];
          
          phaseSub=
            Join[phaseSub,{phas[[i,1]][{y___}]\[Rule]phas[[i,1]][{y}] phas[[i,
                        2]]}];
          
          phaseInverse=
            Join[phaseInverse,{phas[[i,
                        1]][{y___}]\[Rule]phas[[i,1]][{y}] conj[
                      phas[[i,2]]]}];
          ];
        
        PhasesToOneSub=Join[PhasesToOneSub,{phas[[i,2]]\[Rule]1}];
        parameters = Join[parameters,{{phas[[i,2]],{},{}}}];
        
        i++;];
      PhaseSub[type]=phaseSub;
      PhaseSubInverse[type]=phaseInverse;
      UpdateGaugeTransformations[phaseSub,phaseInverse];
      ];



SaveModelParameters[name_]:=Block[{},
      
      
      Print["Save Model Information: ",name];
      
      If[Length[res]\[Equal]7,
        
        SubMatter[name]=res[[1]];
        MassMatricesTemp[name]=res[[2]];
        MassMatricesFullTemp[name]=res[[3]];
        MixBasis[name]=res[[4]];
        MixMatrix[name]=res[[5]];
        MixES[name]=DeleteCases[res[[6]],NoFlavorMixing,2];
        MixedNames[name]=res[[7]];
        
        
        ];
      
      GoldstoneBosons[name]=GoldstoneGhost;
      Print["      TadpoleEquations"];
      If[Head[TEqu]===List,
        TadpoleEquations[name]=CalcDelta[TEqu];
        ];
      
      Print["      Interactions"];
      Potential = 
        Potential /.{GetGenStart \[Rule]getGenStart, GetGen\[Rule]getGen};
      Kinetic = 
        Kinetic /.{GetGenStart \[Rule]getGenStart, GetGen\[Rule]getGen};
      LagrangianVVV = 
        LagrangianVVV /.{GetGenStart \[Rule]getGenStart, 
            GetGen\[Rule]getGen};
      LagrangianVVVV=
        LagrangianVVVV /.{GetGenStart \[Rule]getGenStart, 
            GetGen\[Rule]getGen};
      EffectiveOperators = 
        EffectiveOperators /.{GetGenStart \[Rule]getGenStart, 
            GetGen\[Rule]getGen};
      LagrangianGhost = 
        LGhost /.{GetGenStart \[Rule]getGenStart, GetGen\[Rule]getGen};
      LagrangianRe = 
        LagReDef /.{GetGenStart \[Rule]getGenStart, GetGen\[Rule]getGen};
      LagrangianAux = 
        LagrangianAux /.{GetGenStart \[Rule]getGenStart, 
            GetGen\[Rule]getGen};
      
      CalcImp= True;
      SetGenerations=True;
      Update[];
      
      Print["      Split Lagrangian"];
      
      Pot[name]= Potential;
      LagSSSS[
          name]=- (Potential /.vacuumF /. zero[x_] \[Rule] 0*x) + ( 
            EffectiveOperators/.vacuumF /.vacuumV /. zero[x_] \[Rule] 0*x);
      LagFFS[name]= - Potential;
      
      LagSV[name]=  Kinetic /.vacuumF /. zero[x_] \[Rule] 0*x;
      LagFFV[name]=  Kinetic /.vacuumS /. zero[x_] \[Rule] 0*x;
      LagVVV[name]=  LagrangianVVV;
      LagVVVV[name]= LagrangianVVVV;
      
      LagFFSS[name]= - EffectiveOperators /.vacuumV /. zero[x_] \[Rule] 0*x;
      LagFFVV[name]= - EffectiveOperators/.vacuumS /. zero[x_] \[Rule] 0*x;
      LagFFFF[name]=  - EffectiveOperators/.vacuumS /.vacuumV /. 
          zero[x_] \[Rule] 0*x;
      LagSSSSSS[name]= - EffectiveOperators/.vacuumF /.vacuumV /. 
          zero[x_] \[Rule] 0*x;
      LagSSSVVV[name]=  - EffectiveOperators /.vacuumF;
      
      LagGGV[name]=  LagrangianGhost /.vacuumS /. zero[x_] \[Rule] 0*x;
      LagGGS[name]=  LagrangianGhost /.vacuumV /. zero[x_] \[Rule] 0*x ;
      (* LagAdd[name]=  LagrangianAdd; *)
      
      LagRedefinition[name] = LagrangianRe *1;
      
      LagSSA[name]=  LagrangianAux;
      
      LagrangianComplete[name]=  
        Kinetic - Potential + EffectiveOperators + LagrangianGhost;
      ParticlesTemp[name]= Particles[Current];
      
      SetGenerations=False; 
      CalcImp = False;
      
      ];


SimplifyMatrices:=
    Block[{i,particles,para,temp,sub},Print["Simplify Mass Matrices"];
      states=NameOfStates;
      
      temp=
        Flatten[Table[{Flatten[listIndizes][[i]]/.subGC[1]/.subIndFinalX[1,j,
                  "m"],Flatten[listIndizes][[i]]/.subGC[1]/.subIndFinalX[1,j,
                  "n"]},{i,1,Length[Flatten[listIndizes]]},{j,1,4}]];
      
      sub=Flatten[Table[{sum[temp[[i]],a_,b_]\[Rule]1},{i,1,Length[temp]}]];
      
      For[i=1,i\[LessEqual]Length[states],
        matFull=MassMatricesFullTemp[states[[i]]]/.sub;
        mat=MassMatricesTemp[states[[i]]]/.sub;
        
        matFull=SimplifySARAH[matFull];
        mat=SimplifySARAH[mat];
        
        MassMatricesFull[states[[i]]]=matFull;
        MassMatrices[states[[i]]]=mat;
        i++;];
      ];

MakeEntryDependences[Condition_]:=Block[{list={}},
      For[i=1, i\[LessEqual]Length[ParameterDefinitions],
        If[((Condition /. ParameterDefinitions[[i,2]])=!= 
                None) &&
            ((Condition /. 
                    ParameterDefinitions[[i,2]])=!= Condition), 
          
          If[FreeQ[parameters,ParameterDefinitions[[i,1]]]\[Equal]False,
              pos=Position[parameters,ParameterDefinitions[[i,1]]][[1,1]];
              indices = Extract[parameters,pos][[2]];
              If[Head[Condition  /. ParameterDefinitions[[i,2]]]===List,
                Clear[dep];
                DEP=Condition  /. ParameterDefinitions[[i,2]];
                
                If[getDimParameter[
                      ParameterDefinitions[[i,1]]]\[Equal]Dimensions[DEP],
                  Switch[Length[indices],
                      1,
                      list = Join[
                            list ,{(ParameterDefinitions[[i,1]][
                                      index1_Integer] :> dep[[index1]])/. 
                                dep\[Rule]DEP} ];,
                      2,
                      list = Join[
                            list ,{(ParameterDefinitions[[i,1]][
                                      index1_Integer,index2_Integer] :> 
                                    dep[[index1,index2]])/. 
                                dep\[Rule]DEP} ];,
                      3,
                      list = Join[
                            list ,{(ParameterDefinitions[[i,1]][
                                      index1_Integer, index2_Integer, 
                                      index3_Integer] :> 
                                    dep[[index1,index2,index3]])/. 
                                dep\[Rule]DEP} ];,
                      4, 
                      list = Join[
                            list ,{(ParameterDefinitions[[i,1]][
                                      index1_Integer, index2_Integer,
                                      index3_Integer,index4_Integer] :> 
                                    dep[[index1,index2,index3,index4]])/. 
                                dep\[Rule]DEP} ];
                      ];,
                  
                  Message[Parameter::FalseDimension,
                      ParameterDefinitions[[i,1]]];
                  ];,
                Switch[Length[indices],
                    0,
                    list = Join[
                          list ,{ParameterDefinitions[[i,1]] \[Rule] 
                                Condition /. ParameterDefinitions[[i,2]]} ];,
                    1,
                    list = Join[
                          list ,{ParameterDefinitions[[i,1]][index1_] \[Rule] 
                                Condition /.  
                              ParameterDefinitions[[i,2]]} ];,
                    2,
                    list = Join[
                          list ,{ParameterDefinitions[[i,1]][index1_,
                                  index2_] \[Rule] Condition  /. 
                              ParameterDefinitions[[i,2]]} ];,
                    3,
                    list = Join[
                          list ,{ParameterDefinitions[[i,1]][index1_, 
                                  index2_, index3_] \[Rule] Condition  /. 
                              ParameterDefinitions[[i,2]]} ];,
                    4, 
                    list = Join[
                          list ,{ParameterDefinitions[[i,1]][index1_, index2_,
                                  index3_,index4_] \[Rule] Condition  /. 
                              ParameterDefinitions[[i,2]]} ];
                    ];
                ];
              
              addNewSym[ParameterDefinitions[[i,1]], 
                Condition/. ParameterDefinitions[[i,2]]];
              ];
          ];
        i++;];
      Return[list];
      
      
      ];


MakeParameterDependenceList :=Block[{i,j,temp},
      subDependences =MakeEntryDependences[DependenceOptional];
      temp=MakeEntryDependences[Dependence];
      For[i=1,i\[LessEqual]Length[temp],
        If[
          FreeQ[Table[subAlways[[i,1]],{i,1,Length[subAlways]}],temp[[i,1]]],
          subAlways =Join[subAlways,{temp[[i]]}];
          ];
        i++;];
      
      (*
        For[i=1, i\[LessEqual]Length[ParameterDefinitions],
            
            If[((DependenceOptional /. ParameterDefinitions[[i,2]])=!= 
                    None) &&
                ((DependenceOptional /. 
                        ParameterDefinitions[[i,2]])=!= DependenceOptional), 
              
              If[FreeQ[parameters,ParameterDefinitions[[i,1]]]\[Equal]False,
                  
                  pos=Position[parameters,ParameterDefinitions[[i,1]]][[1,
                        1]];
                  indices = Extract[parameters,pos][[2]];
                  
                  If[Head[DependenceOptional  /. ParameterDefinitions[[i,2]]]===
                      List,
                    Clear[dep];
                    DEP=DependenceOptional  /. ParameterDefinitions[[i,2]];
                    
                    If[getDimParameter[
                          ParameterDefinitions[[i,1]]]\[Equal]Dimensions[
                          DEP],
                      Switch[Length[indices],
                          1,
                          subDependences = 
                              Join[subDependences ,{(ParameterDefinitions[[i,
                                        1]][index1_Integer] :> dep[[index1]])/. 
                                    dep\[Rule]DEP} ];,
                          2,
                          subDependences = 
                              Join[subDependences ,{(ParameterDefinitions[[i,
                                        1]][index1_Integer,index2_Integer] :> 
                                        dep[[index1,index2]])/. 
                                    dep\[Rule]DEP} ];,
                          3,
                          subDependences = 
                              Join[subDependences ,{(ParameterDefinitions[[i,
                                        1]][index1_Integer, index2_Integer, 
                                        index3_Integer] :> 
                                        dep[[index1,index2,index3]])/. 
                                    dep\[Rule]DEP} ];,
                          4, 
                          subDependences = 
                              Join[subDependences ,{(ParameterDefinitions[[i,
                                        1]][index1_Integer, index2_Integer,
                                        index3_Integer,index4_Integer] :> 
                                        dep[[index1,index2,index3,index4]])/. 
                                    dep\[Rule]DEP} ];
                          ];,
                      
                      Message[Parameter::FalseDimension,
                          ParameterDefinitions[[i,1]]];
                      ];,
                    Switch[Length[indices],
                        0,
                        subDependences = 
                            Join[subDependences ,{ParameterDefinitions[[i,
                                        1]] \[Rule] DependenceOptional /. 
                                  ParameterDefinitions[[i,2]]} ];,
                        1,
                        subDependences = 
                            Join[subDependences ,{ParameterDefinitions[[i,1]][
                                      index1_] \[Rule] DependenceOptional /.  
                                  ParameterDefinitions[[i,2]]} ];,
                        2,
                        subDependences = 
                            Join[subDependences ,{ParameterDefinitions[[i,1]][
                                      index1_,index2_] \[Rule] 
                                    DependenceOptional  /. 
                                  ParameterDefinitions[[i,2]]} ];,
                        3,
                        subDependences = 
                            Join[subDependences ,{ParameterDefinitions[[i,1]][
                                      index1_, index2_, index3_] \[Rule] 
                                    DependenceOptional  /. 
                                  ParameterDefinitions[[i,2]]} ];,
                        4, 
                        subDependences = 
                            Join[subDependences ,{ParameterDefinitions[[i,1]][
                                      index1_, index2_,index3_,
                                      index4_] \[Rule] DependenceOptional  /. 
                                  ParameterDefinitions[[i,2]]} ];
                        ];
                    ];
                  
                  addNewSym[ParameterDefinitions[[i,1]], 
                    DependenceOptional/. ParameterDefinitions[[i,2]]];
                  ];
              ];
            i++;];
        *)
      
      
      subDependencesSPheno ={};
      
      
      For[i=1, i\[LessEqual]Length[ParameterDefinitions],
        If[((DependenceSPheno /. ParameterDefinitions[[i,2]])=!= 
                None) &&
            ((DependenceSPheno /. 
                    ParameterDefinitions[[i,2]])=!= DependenceSPheno), 
          
          subDependencesSPheno = 
              Join[subDependencesSPheno,{ParameterDefinitions[[i,
                        1]]\[Rule] (DependenceSPheno /. 
                        ParameterDefinitions[[i,2]])}];
          ];
        i++;];
      
      subNumDependences = {};
      dependtPara ={};
      
      For[i=1, i\[LessEqual]Length[ParameterDefinitions],
        If[((DependenceNum /. ParameterDefinitions[[i,2]])=!= 
                None) &&
            ((DependenceNum /. 
                    ParameterDefinitions[[i,2]])=!= DependenceNum), 
          
          If[FreeQ[parameters,ParameterDefinitions[[i,1]]]\[Equal]False,
              pos=Position[parameters,ParameterDefinitions[[i,1]]][[1,1]];
              dependtPara=Join[dependtPara,{ParameterDefinitions[[i,1]]}];
              indices = Extract[parameters,pos][[2]];
              val=DependenceNum/. ParameterDefinitions[[i,2]];
              Switch[Length[indices],
                0,
                subNumDependences = 
                    Join[subNumDependences ,{ParameterDefinitions[[i,
                                1]] \[Rule] DependenceNum/. 
                          ParameterDefinitions[[i,2]]} ];,
                1,
                	If[Head[val]===List,
                    	
                    If[getDimParameter[
                            ParameterDefinitions[[i,1]]]\[Equal]Dimensions[
                            val],
                        	
                        subNumDependences = 
                          Join[subNumDependences ,{ParameterDefinitions[[i,
                                      1]][index1_Integer] \
\[RuleDelayed]VAL[[index1]]} ];
                        	
                        subNumDependences = 
                          Join[subNumDependences ,{ParameterDefinitions[[i,
                                      1]][index1_] \[RuleDelayed]VAL[
                                  index1]} ];,
                        	
                        Message[Parameter::FalseDimension,
                            ParameterDefinitions[[i,1]]];
                        	];,
                    	
                    subNumDependences = 
                        Join[subNumDependences ,{ParameterDefinitions[[i,1]][
                                index1_] \[Rule]val} ];
                    	];,
                2,
                	If[Head[val]===List,
                    	
                    If[getDimParameter[ParameterDefinitions[[i,1]]]\[Equal]
                          Dimensions[val],
                        	
                        subNumDependences = 
                          Join[subNumDependences ,{ParameterDefinitions[[i,
                                      1]][index1_Integer,
                                  index2_Integer] \[RuleDelayed]
                                VAL[[index1,index2]]} ];
                        	
                        subNumDependences = 
                          Join[subNumDependences ,{ParameterDefinitions[[i,
                                      1]][index1_,index2_] \[RuleDelayed]
                                VAL[index1,index2]} ];,
                        	
                        Message[Parameter::FalseDimension,
                            ParameterDefinitions[[i,1]]];
                        	];,
                    	
                    subNumDependences = 
                        Join[subNumDependences ,{ParameterDefinitions[[i,1]][
                                index1_,index2_] \[Rule]val} ];
                    	];,
                3,
                	If[Head[val]===List,
                    	
                    If[getDimParameter[ParameterDefinitions[[i,1]]]\[Equal]
                          Dimensions[val],
                        		
                        subNumDependences = 
                          Join[subNumDependences ,{ParameterDefinitions[[i,
                                      1]][index1_Integer, index2_Integer, 
                                  index3_Integer] \[RuleDelayed]
                                VAL[[index1,index2,index3]]} ];
                        	
                        subNumDependences = 
                          Join[subNumDependences ,{ParameterDefinitions[[i,
                                      1]][index1_, index2_, 
                                  index3_] \[RuleDelayed]VAL[index1,index2,
                                  index3]} ];,
                        	
                        Message[Parameter::FalseDimension,
                            ParameterDefinitions[[i,1]]];
                        	];,
                    		
                    subNumDependences = 
                        Join[subNumDependences ,{ParameterDefinitions[[i,1]][
                                index1_, index2_, index3_] \[Rule]val} ];
                    	];,
                4,
                	If[Head[val]===List,
                    	
                    If[getDimParameter[
                            ParameterDefinitions[[i,1]]]\[Equal]Dimensions[
                            val],
                        	 
                        subNumDependences = 
                            Join[subNumDependences ,{ParameterDefinitions[[i,
                                        1]][index1_Integer, index2_Integer,
                                    index3_Integer,
                                    index4_Integer] \[RuleDelayed]VAL[[index1,
                                      index2,index3,index4]]} ];,
                        	Message[Parameter::FalseDimension,
                            ParameterDefinitions[[i,1]]];
                        	];,
                    	
                    subNumDependences = 
                        Join[subNumDependences ,{ParameterDefinitions[[i,1]][
                                index1_, index2_,index3_,index4_] \[Rule]
                              val} ];
                    	];
                ];
              subNumDependences = subNumDependences /. VAL\[Rule]val;
              
              addNewSym[ParameterDefinitions[[i,1]], 
                DependenceNum/. ParameterDefinitions[[i,2]]];
              ];
          ];
        i++;];
      
      
      ];


AddMatrixProducts:=Block[{i},
      
      Print["Add Matrix Products"];
      
      For[i=1,i\[LessEqual]Length[ParameterDefinitions],
        If[((MatrixProduct/. ParameterDefinitions[[i,2]])=!= 
                MatrixProduct) &&
            ((MatrixProduct /. 
                    ParameterDefinitions[[i,2]])=!= None),
          mat1 = (MatrixProduct/. ParameterDefinitions[[i,2]])[[1]];
          mat2 = (MatrixProduct/. ParameterDefinitions[[i,2]])[[2]];
          
          ListMatrixProdukt= 
            Join[ListMatrixProdukt,{{mat1,mat2,getDim[mat1],
                  ParameterDefinitions[[i,1]]},{mat2,mat1,getDim[mat1],
                  conj[ParameterDefinitions[[i,1]]]}}];
          
          parameters = 
            Join[parameters,{{ParameterDefinitions[[i,1]],{generation,
                    generation},{getDim[mat1],getDim[mat1]}}}];
          ];
        i++;];
      
      
      For[i=1,i\[LessEqual]Length[MayBeParameters],
        If[FreeQ[parameters,MayBeParameters[[i,1]]],
          
          parameters = 
              Join[parameters,{MayBeParameters[[i]] /. 
                    GetDimParameters\[Rule] getDimParameters}];
          ];
        i++;];
      
      
      ];

CheckForMassless:=Block[{i,j,particle,type},
      Print["Checking for massless particles"];
      
      For[i=1,i\[LessEqual]Length[NameOfStates],
        temp={};
        If[i\[Equal]1, firstStates=Particles[NameOfStates[[i]]];,
          Particles[Current]=Particles[NameOfStates[[i]]];
          For[j=1,j\[LessEqual]Length[Particles[Current]],
            particle=Particles[Current][[j,1]];
            type=getType[particle];
            
            If[(FreeQ[firstStates,particle]\[Equal]False  || type===V) &&
                type=!=A  && type=!=G,
               mass=TreeMass[particle,NameOfStates[[i]]]; 
              
              If[Simplify[mass/.subDependences] ===0 || 
                  GetEntryDef[particle,NameOfStates[[i]],Mass]===0,
                temp=Join[temp,{particle /. diracSubBack1 /. diracSubBack2}];
                ];
              ];
            j++;];
          Massless[NameOfStates[[i]]]=temp;
          ];
        i++;];
      ];


CalcGaugeMixing2[name_, def_]:=Block[{temp,temp2,i,j,i1,i2},
      Print["hi"];
      MassMatricesGauge[name]={};
      subVac=Flatten[Map[vacHead,vacuum]];
      
      For[i=1,i\[LessEqual]Length[def],
        If[getType[def[[i,1,1]]/. a_[b_Integer]\[Rule]a]===V,
          temp=Kinetic;,
          temp=Potential;
          ];
        
        temp =
          Table[DMM[DMM[Kinetic /. vevSub,
                        def[[i,1,i1]] /. a_[b_Integer]\[Rule]a,1,"t",1],
                      def[[i,1,i2]] /. a_[b_Integer]\[Rule]a,2,"t",
                      2] /. {gt1\[Rule] ExtractGen[def[[i,1,i1]]],
                      gt2\[Rule] ExtractGen[def[[i,1,i2]]]} /.subVac /. 
                Mom[_]\[Rule]0 /. zero[a_]\[Rule]0 ,{i1,1,
              Length[def[[i,1]]]},{i2,1,Length[def[[i,1]]]}];
        
        MassMatricesGauge[name]=Join[MassMatricesGauge[name],{temp}];
        
        i++;];
      
      MassMatricesGauge[name]=
        SimplifySARAH[MassMatricesGauge[name]] /. g[a__]\[Rule]1;
      
      ];

ExtractGen[x_]:=
    If[ Cases[x,y_?IntegerQ]\[Equal]{},Return[1],
      Return[Cases[x,y_?IntegerQ][[1]]]];

addNewSym[par_,dep_]:=Block[{i,j,newSym,pos,pos2},
      newSym = 
        DeleteCases[
          Intersection[
            Cases[dep /. Mass[a__]:>Random[],x_Symbol,
              99]],_?(MemberQ[{index1,index2,index3,i001,i002,i003,i004,
                    sum},#]&)];
      pos=Position[parameters,par][[1,1]];
      For[j=1,j\[LessEqual]Length[newSym],
        If[FreeQ[parameters,newSym[[j]]],
          If[Head[dep]===List,
            parameters=Join[parameters,{{newSym[[j]],{},{}}}];,
            
            parameters=
                Join[parameters,{{newSym[[j]],parameters[[pos]][[2]],
                      parameters[[pos]][[3]]}}];
            ];
          pos2=Position[Transpose[ParameterDefinitions][[1]],newSym[[j]]];
          If[pos2=!={},
            If[(Real /. ParameterDefinitions[[pos2[[1,1]],2]])\[Equal]True,
                realVar=Join[realVar,{newSym[[j]]}];
                ];
            ];
          ];
        j++;];
      ];

CheckParticleMixing[Eigenstates_]:=
    Block[{i,j,temp,pos,partS,partF,partV,vert},
      partS=Transpose[Select[Particles[Eigenstates],(#[[4]]===S)&]][[1]];
      partF=
        Intersection[
          Transpose[Select[Particles[Eigenstates],(#[[4]]===F)&]][[1]] /. 
              diracSubBack /. bar[x_]\[Rule]x];
      partV=Transpose[Select[Particles[Eigenstates],(#[[4]]===V)&]][[1]];
      
      For[i=1,i\[LessEqual]Length[partS],
        For[j=i+1,j\[LessEqual]Length[partS],
          
          vert=FullSimplify[
              Vertex[{partS[[i]],partS[[j]]}][[2,1]]//. subAlways //. 
                subDependences];
          If[vert=!=0,
            Print["Possible mixing between ",partS[[i]], " and ",partS[[j]]];
            Print["    term :",vert];,
            
            vert=FullSimplify[
                Vertex[{partS[[i]],conj[partS[[j]]]}][[2,1]]//. subAlways //. 
                  subDependences];
            If[vert=!=0,
              
              Print["Possible mixing between ",partS[[i]], " and ",
                conj[partS[[j]]]];
              Print["    term :",vert];
              ];
            ];
          j++;];
        i++;];
      
      For[i=1,i\[LessEqual]Length[partF],
        For[j=i+1,j\[LessEqual]Length[partF],
          
          vert=FullSimplify[(Vertex[{partF[[i]],partF[[j]]}][[2,1]]+
                      Vertex[{partF[[i]],partF[[j]]}][[3,1]])//. subAlways //. 
                subDependences];
          If[vert=!=0,
            Print["Possible mixing between ",partF[[i]], " and ",partF[[j]]];
            Print["    term :", vert];,
            
            vert=FullSimplify[(Vertex[{bar[partF[[i]]],partF[[j]]}][[2,1]]+
                        Vertex[{bar[partF[[i]]],partF[[j]]}][[3,1]])//. 
                    subAlways //. subDependences];
            If[vert=!=0,
              
              Print["Possible mixing between ",partF[[i]], " and ",
                conj[partF[[j]]]];
              Print["    term :",vert];
              ];
            ];
          j++;];
        i++;];
      
      For[i=1,i\[LessEqual]Length[partV],
        For[j=i+1,j\[LessEqual]Length[partV],
          
          vert=FullSimplify[
              Vertex[{partV[[i]],partV[[j]]}][[2,1]]//. subAlways //. 
                subDependences];
          If[vert=!=0,
            Print["Possible mixing between ",partV[[i]], " and ",partV[[j]]];
            Print["    term :",vert];,
            
            vert=FullSimplify[
                Vertex[{partV[[i]],conj[partV[[j]]]}][[2,1]]//. subAlways //. 
                  subDependences];
            If[vert=!=0,
              
              Print["Possible mixing between ",partV[[i]], " and ",
                conj[partV[[j]]]];
              Print["    term :",vert];
              ];
            ];
          j++;];
        i++;];
      
      Print["Check finished"];
      
      
      ];