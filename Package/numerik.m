(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)

(* Begin["`Numerik`"] *)


(*----------------------------------------*)
(* 
  Numerical Values  *)
(*----------------------------------------*)


(* ----- Read Specturm File --------*)

FirstRead=True;

GetNumericalValues[file_]:=Block[{},
      Print["Checking for Spectrum File"];
      
      If[file=!=None,
        ReadSpectrum[file];,
        Print["     No Spectrum File defined"];
        ];
      
      
      MakeNumericalValueList;
      subNum=Join[subNum,subNumValue];
      
      CalcMatrices;
      
      ];


FindValue[block_,entry_,data_,app_]:=Block[{pos},
      pos=Position[data,block];
      If[pos=!={},
        If[Head[app]===Integer,
          pos = pos[[app,1]];,
          pos=Last[pos][[1]];
          ];
        temp=DeleteCases[Drop[Extract[data,pos],1],{}];
        If[entry===None, Return[temp];];
        If[Head[entry]===List,
          pos=Cases[Tranpose[temp][[1]],Join[entry,{_}]];
          If[pos==={},
            Return[0];,
            Return[Last[pos[[1]]]];
            ];,
          pos=Position[Transpose[temp][[1]],entry];
          If[pos==={},
            Return[0];,
            Return[temp[[pos[[1,1]]]][[2]]];
            ];
          ];,
        Return[None];
        ];
      ];
Options[ShowValue]={Appearance\[Rule]Last};
Options[ShowBlock]={Appearance\[Rule]Last};

ShowValue[block_,entry_,opt___]:=
    FindValue[ToUpperCase[ToString[block]],entry,LesHouchesInput,
      Appearance/.{opt}/.Options[ShowValue]];
ShowBlock[block_,opt___]:=
    FindValue[ToUpperCase[ToString[block]],None,LesHouchesInput,
      Appearance/.{opt}/.Options[ShowBlock]];

ReadSpectrum[file_]:=Block[{i,j,a,b,c,lval,nrgesucht,j2, list},
      
      LesHouchesList={};
      
      For[i=1,i\[LessEqual]Length[ParameterDefinitions],
        lh = LesHouches /. ParameterDefinitions[[i,2]];
        LesHouchesList=
          Join [LesHouchesList,{{ ParameterDefinitions[[i,1]],lh}}];
        i++;];
      
      LesHouchesInput=ReadSpectrumFile[file];
      
      For[i=1,i\[LessEqual]Length[LesHouchesList],
        If[
          FreeQ[LesHouchesInput,
              LHBlockName[LesHouchesList[[i,1]]]]\[Equal]False,
          Switch[Depth[LesHouchesList[[i,2]]],
              1,
                 real =ShowBlock[LesHouchesList[[i,2]]];
                 
              imag =ShowBlock[
                  ToExpression["IM"<>ToString[LesHouchesList[[i,2]]]]];
                If[real=!=None || imag =!=None,
                If[real===None, real = imag*0]; 
                If[imag===None, imag = real*0];
                   
                subNum = 
                  Join[subNum, 
                    Table[LesHouchesList[[i,1]]@@
                          Transpose[Drop[Transpose[real],-1]][[j]]\[Rule]Last[
                              Transpose[real]][[j]]+\[ImaginaryI] Last[
                                Transpose[imag]][[j]],{j,1, Length[real]}]];
                ];,
              2,
                 
              real =ShowValue[LesHouchesList[[i,2,1]],
                  LesHouchesList[[i,2,2]]];
                 
              imag =ShowValue[
                  ToExpression["IM"<>ToString[LesHouchesList[[i,2,1]]]],
                  LesHouchesList[[i,2,2]]];
                If[real=!=None || imag =!=None,
                If[real===None, real = imag*0]; 
                If[imag===None, imag = real*0];
                   
                subNum = 
                  Join[subNum, {LesHouchesList[[i,1]] \[Rule] 
                        real +\[ImaginaryI] imag}];
                ];
              ];
          ];
        i++;];
      
      pos = Position[LesHouchesInput,"MASS"];
      
      If[pos=!={},
        listMass=Drop[LesHouchesInput[[pos[[1,1]]]],1];
        For[i=1,i\[LessEqual]Length[LesHouchesListMasses],
          pos = Position[listMass,LesHouchesListMasses[[i,2,1,2]]];
          If[pos=!={},
            
            subNum = 
                Join[subNum,{LesHouchesListMasses[[i,1]]\[Rule] 
                      listMass[[pos[[1,1]]]][[2]]}];
            ];
          i++;];
        ];
      
      
      subNum = Flatten[subNum /. EndOfFile \[Rule]0];
      
      ];

ReadSpectrumFile[file_]:=Block[{i,j,a,b,c,sps={}, temp,t="", return,in},
      in=OpenRead[ToFileName[{$sarahCurrentModelDir},file]];
      ScalesLesHouches= {};
      
      While[t=!="BLOCK",t=ToUpperCase[Read[in,Word]];];
      
      While[return=!=EndOfFile,
        temp=ReadBlock;
        return=temp[[2]];
        sps=Join[sps,{temp[[1]]}];
        ];
      Close[in];
      Return[sps];
      ];

ReadBlock:=Block[{i,t,temp,temp1,j,test,first},
      temp ={ToUpperCase[Read[in,Word]]};
      temp1={};
      test=Read[in,String];
      scale=0;
      If[StringFreeQ[test,"Q="]\[Equal]False,
        scale = 
            ToExpression[
              StringReplace[
                StringTake[
                  test,{StringPosition[test,"="][[1,1]]+1,
                    StringPosition[test,"#"][[1,1]]-1}],{"E"->"*10^"}]];
        ];
      temp={{temp[[1]],scale}};
      first=True;
      While[ToUpperCase[j]=!="BLOCK" && j=!=EndOfFile,
        i=j;
        If[i==="#",
          temp = Join[temp,{temp1}];
          test=Read[in,String];
          temp1={};,
          If[first=!=True,
              
              temp1 = Join[
                    temp1,{ToExpression[StringReplace[i,{"E"->"*10^"}]]}];
              ];
          ];
        j=Read[in,Word];
        first=False;
        ];
      
      Return[{temp,j}];
      
      
      ];

MakeNumericalValueList:=Block[{i},
      
      Print["Reading Parameter Values and Dependences"];
      
      subNumValue={};
      For[i=1,i\[LessEqual]Length[ParameterDefinitions],
        If[((Value /. ParameterDefinitions[[i,2]])=!=
                None) && (Value /. ParameterDefinitions[[i,2]])=!=Value,
          If[Depth[(Value /. ParameterDefinitions[[i,2]])]\[Equal]1,
              
              subNumValue = 
                  Join[subNumValue,{ParameterDefinitions[[i,
                            1]] \[Rule] (Value /. 
                            ParameterDefinitions[[i,2]])}];,
              lval= Value/. ParameterDefinitions[[i,2]];
              For[j=1,j\[LessEqual]Length[lval],
                
                subNumValue= 
                  Join[subNumValue,{(ParameterDefinitions[[i,1]][
                              lval[[j,1]]] /. A_[{a__}]\[Rule]A[a])\[Rule] 
                        lval[[j,2]]}];
                j++;];
              ];
          ];
        i++;];
      
      DefinedNumericalValues=subNumValue;
      
      ];

CalcMatrices:=Block[{i,j,k, states, basis, matrices, mixName,massesTemp},
      
      Print["Calculate Mixing Matrices"];
      
      states = NameOfStates;
      
      alreadyCalculated={};
      
      For[i=1,i\[LessEqual]Length[states],
        basis = MixBasis[states[[i]]];
        matrices=MassMatricesFull[states[[i]]];
        mixName=MixMatrix[states[[i]]];
        massesTemp=MassesTemp[states[[i]]];
        Particles[Current]=Particles[states[[i]]];
        
        If[Head[basis]=!= MixBasis,
          For[j=1,j\[LessEqual]Length[matrices],
              If[FreeQ[alreadyCalculated,mixName[[j,2]]]\[Equal]True,
                alreadyCalculated = Join[alreadyCalculated,{mixName[[j,2]]}];
                If[NumericalValue[matrices[[j]]]=!=NaN,
                  If[RE[basis[[j,1]]]===RE[basis[[j,2]]],
                      
                      CalcMixingmatrixSymm[matrices[[j]],
                          ToExpression[ToString[mixName[[j,2]]]<>"Num"],
                          ToExpression["Mass"<>ToString[mixName[[j,1]]]]];,
                      
                      CalcMixingmatrixNSymm[matrices[[j]],
                          ToExpression[ToString[mixName[[j,1,2]]]<>"Num"],
                          ToExpression[ToString[mixName[[j,2,2]]]<>"Num"],
                          ToExpression["Mass"<>ToString[mixName[[j,1,1]]]],
                          ToExpression["Mass"<>ToString[mixName[[j,2,1]]]]];
                      ];
                  ];
                ];
              j++;];
          ];
        Masses[states[[i]]]=massesTemp;
        i++;];
      ];


CalcParameters[file_]:=Block[{i},
      
      Print["Read Numerical Input File"];
      
      
      Print["Calc Mixing Matrices"];
      
      For[i=1,i\[LessEqual] Length[MassMatricesFull],
        If[
          conj[Transpose[
                MassMatricesFull[[i]]]]\[Equal]MassMatricesFull[[i]],
          
          CalcMixingmatrixSymm[MassMatricesFull[[i]],
              ToExpression[ToString[mix[[i,2,2]]]<>"Num"],
              ToExpression["Mass"<>ToString[mix[[i,2,1]]]]];,
          
          CalcMixingmatrixNSymm[MassMatricesFull[[i]],
              ToExpression[ToString[mix[[i,2,1,2]]]<>"Num"],
              ToExpression[ToString[mix[[i,2,2,2]]]<>"Num"],
              ToExpression["Mass"<>ToString[mix[[i,2,1,1]]]],
              ToExpression["Mass"<>ToString[mix[[i,2,2,1]]]]];
          ];
        i++;];
      ];



(* -------- Functions for Changing Numerical Value -------*)

NumericValQ[x_List]:=NumericValQ/@ x;
NumericValQ[x_Times]:=NumericValQ/@ x;
NumericValQ[x_Power]:=NumericValQ/@ x;
NumericValQ[x_Plus]:=NumericValQ/@ x;
NumericValQ[x_]:=NumericQ[x];

NVal[x_List]:=NVal/@ x;
NVal[x_Times]:=NVal/@ x;
NVal[x_Power]:=NVal/@ x;
NVal[x_Plus]:=NVal/@ x;
NVal[x_Sin]:=NVal/@ x;
NVal[x_Cos]:=NVal/@ x;
NVal[x_Tan]:=NVal/@ x;
NVal[x_Plus]:=NVal/@ x;
NVal[x_Integer]:=x;
NVal[x_Real]:=x;
NVal[x_Complex]:= x;
NVal[x_Rational]:=x;

NVal[x_]:=Block[{temp},
      If[FreeQ[x,sum]\[Equal]False,
          temp=x;
          While[FreeQ[temp,sum]\[Equal]False,
            temp = temp /. sum[a_,b_,c_,d_]\[Rule]Hold[Sum[d,{a,b,c}]];
            temp =ReleaseHold[temp];
            ];
          Return[NVal[temp]];,
          
          If[FreeQ[subNum,x]\[Equal]False,
            Return[x /. subNum];
            ];
          
          If[FreeQ[subNum,dependtPara]\[Equal]False,
            Return[NVal[x/. subNumDependences]];
            ];
          
          Return[x];
          ];
      ];


WriteErrorNum=False;

NumericalValue[x_] :=Block[{},
      result=NVal[x];
      result = 
        result  /.subNumDependences /.subNum  /.subNumDependences  /.subNum;
      If[FreeQ[NumericValQ[result],False]\[Equal]True,
        Return[result];,
        If[WriteErrorNum,
          
          listNoNumeric=
            Intersection[
              Flatten[DeleteCases[Expand[result] /. Power\[Rule]Times ,
                          y_?NumericQ,2] /. Plus\[Rule]List /. 
                      Times\[Rule]List /. 
                    conj[y_]\[Rule]y /. {Sin[y_]\[Rule]y,Tan[y_]\[Rule]y,
                    Cos[y_]\[Rule]y}]];
          Print["No numerical values for: ",listNoNumeric];
          ];
        If[SetNaNtoZero\[Equal]True,
          Return[0];,
          Return[NaN];
          ];
        ];
      ];

NoNumericValQ[x_]:=If[NumericQ[x]\[Equal]True, Return[False];,Return[True];];

SetParameterValue[x_,y_]:=Block[{},
      If[MemberQ[subNum,x\[Rule]_],
        subNum=DeleteCases[subNum, x\[Rule]_];
        ];
      subNum = Join[subNum,{x\[Rule]y}];
      ];

DeleteParameterValue[x_]:=Block[{},
      subNum=DeleteCases[subN, x\[Rule]_];
      ];





(* ---------- Calc Eigensystem ------------*)

CalcMixingmatrix[M_]:=Block[{eigenSystem,pi,i,vec,temp,m,k},
      eigenSystem=
        Chop[SetPrecision[Eigensystem[SetPrecision[M,100]],10],10^-50];
      pi=Table[k,{k,Dimensions[M][[1]]}];
      vec=eigenSystem[[2]];
      temp=vec;
      For[k=1,k\[LessEqual]Dimensions[M][[1]],
        For[m=1,m\[LessEqual]Dimensions[M][[1]],
          If[Abs[vec[[pi[[k]],k]]]<Abs[vec[[m,k]]],pi[[k]]=m];
          m++];
        vec[[pi[[k]]]]=Table[0,{Dimensions[M][[1]]}];
        k++;];
      vec=temp[[pi]];
      Return[vec];
      ];

TestReducibility[M_,Mixing_]:=Block[{i,j},
      TestMatrix=Table[0,{Dimensions[M][[1]]},{Dimensions[M][[2]]}];
      
      For[i=1,i\[LessEqual]Dimensions[M][[1]],
        For[j=1,j\[LessEqual]Dimensions[M][[2]],
          If[M[[i,j]]=!=0,
            TestMatrix[[i,j]]=1000*Random[];
            ];
          j++;];
        i++;];
      
      mix=CalcMixingmatrix[TestMatrix];
      
      For[i=1,i\[LessEqual]Dimensions[mix][[1]],
        For[j=1,j\[LessEqual]Dimensions[mix][[2]],
          If[Abs[mix[[i,j]]]<10^(-100),
            Mixing[i,j]=0;
            ];
          j++;];
        i++;];
      ];


TestReality[M_] :=Block[{i,j},
      If[conj[M] =!= M, Return[False];,
          
          TestMatrix=Table[0,{Dimensions[M][[1]]},{Dimensions[M][[2]]}];
          
          For[i=1,i\[LessEqual]Dimensions[M][[1]],
            For[j=1,j\[LessEqual]Dimensions[M][[2]],
              If[M[[i,j]]=!=0,
                TestMatrix[[i,j]]=1000*Random[];
                ];
              j++;];
            i++;];
          
          EV=Eigenvalues[TestMatrix];
          
          If[Length[Cases[EV,x_?Negative]]>0, Return[False];,Return[True];];
          
          
          ];
      ];


(* ------- Non Symmetric Matrix ------- *)

CalcMixingmatrixNSymm[M_,U_,V_,M1_,M2_]:=Block[{i,j},
      MMfN=NumericalValue[M];
      Utemp=CalcMixingmatrix[MMfN.Transpose[MMfN]];
      Vtemp=CalcMixingmatrix[Transpose[MMfN].MMfN];
      tempMass1 = {};
      tempMass2 = {};
      
      dia1 = Vtemp.(Transpose[MMfN].MMfN).Inverse[Vtemp];
      dia2 = Utemp.(MMfN.Transpose[MMfN]).Inverse[Utemp];
      For[i=1,i\[LessEqual]Dimensions[M][[1]],
        For[j=1,j\[LessEqual]Dimensions[M][[1]],
          
          subNum=Join[
              subNum,{ToExpression[
                    StringDrop[ToString[U],Length[ToString[U]]-3]<>
                      "[i,j]"]\[Rule]Utemp[[i,j]]}];
          
          subNum=Join[
              subNum,{ToExpression[
                    StringDrop[ToString[V],Length[ToString[V]]-3]<>
                      "[i,j]"]\[Rule]Vtemp[[i,j]]}];
          j++;];
        subNum= Join[subNum,{M1[i] \[Rule] Sqrt[dia1[[i,i]]]}];
        subNum= Join[subNum,{M2[i] \[Rule] Sqrt[dia2[[i,i]]]}];
        i++;];
      Set[U,Utemp];
      Set[V,Vtemp];
      ];


(* ----------- Symmetric Matrix ---------- *)

CalcMixingmatrixSymm[M_,U_,M1_]:=Block[{i,j},
      MMfN=NumericalValue[M];
      Utemp=CalcMixingmatrix[MMfN];
      tempMass={};
      dia = Utemp.MMfN.Inverse[Utemp];
      For[i=1,i\[LessEqual]Dimensions[M][[1]],
        For[j=1,j\[LessEqual]Dimensions[M][[1]],
          
          subNum=Join[
              subNum,{ToExpression[
                    StringDrop[ToString[U],Length[ToString[U]]-3]<>
                      "[i,j]"]\[Rule]Utemp[[i,j]]}];
          j++;];
        subNum = Join[subNum,{M1[i]->dia[[i,i]]}];
        i++;];
      Set[U,Utemp];
      ];

(* End[] *)