(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)


(* Begin["`Init`"]  *)

InitArrays:=Block[{},
      
      Print["Initialization"];
      
      Clear[DEFINITION];
      Clear[Fields];
      Clear[dirac];
      Clear[Traceless];
      SA`CasimirList={};
      NonSUNindices={};
      VectorParameters={};
      SimplifyTraces=True;
      Fields=Table[0,{99}];
      Gauge=Table[0,{99}];
      dirac=Table[0,{99}];
      mixMass=Table[0,{99}];
      IntegrateOut= Table[0,{99}];
      DeleteParticles= Table[0,{99}];
      IntegrateOutGauge= Table[0,{99}];
      LesHouchesList={};
      BrokenSymmetries={};
      ReplaceExpandedIndices={};
      rotationAngleGaugeBoson={};
      SpectrumFile=None;
      UnfixedCharges={};
      U1MixingParameters={};
      subNum={};
      vacuum = {};
      vacuumF = {};
      vacuumV = {};
      vacuumS = {};
      vacuumG = {};
      vacuumA = {};
      dimMatrizesAll = {};
      UsedDependences ={};
      ListMatrixProdukt={};
      NoDTerms = False;
      NoFTerms = False;
      RParityConservation  = True;
      subAlways={};
      Abbr={};
      bosons={};
      parameters={};
      Gauginos={};
      OnlyOneGen={};
      SetNaNtoZero=False;
      MasslessBosons={};
      Traceless={};
      ColoredGaugeParticles={};
      SetGenerations=False;
      ListSymmetricParameters={};
      ListAntiSymmetricParameters={};
      ParticlePhases = {};
      PhasesToOneSub={};
      
      
      
      
      
      For[i=1,i\[LessEqual]Length[ParticleListOneGeneration],
        If[ParticleListOneGeneration[[i,2]]===One,
          ParticleListOneGeneration[[i,1]][{a_}]=.;,
          
          ParticleListOneGeneration[[i,1]][
                ParticleListOneGeneration[[i,2]]]=.;
          ];
        i++;];
      
      ];


InitFields:= 
    Block[{i,h,j,k,off,tempS1,tempF1,tempS2,tempF2,tempS1b,tempF1b,tempS2b,
        tempF2b,S1,F1,S2,F2,j2,diff},
      
      
      Print["Generate all Superfields"];
      
      (*Delete unneeded Array Elemtns*)
      
      
      Fields=DeleteCases[Fields,0];
      Gauge=DeleteCases[Gauge,0];
      dirac=DeleteCases[dirac,0];
      mixMass=DeleteCases[mixMass,0];
      IntegrateOut=DeleteCases[IntegrateOut,0];
      DeleteParticles=DeleteCases[DeleteParticles,0];
      IntegrateOutGauge=DeleteCases[IntegrateOutGauge,0];
      RemovedFields = Join[DeleteParticles,IntegrateOut];
      (* Rotation=DeleteCases[Rotation,0]; *)
      
      
      (* Set Numbers *)
      
      AnzahlChiral=Length[Fields];
      AnzahlGauge = Length[Gauge];
      AnzahlEWSB = Length[ewsb];
      AnzahlDirac = Length[dirac];
      MultiplicityList = Table[{},{AnzahlChiral}];
      
      (* Set Real Parameters *)
      
      realVar={Mass};
      realHeads={Mass,repl,Sin,Cos,Sec,Tan,Csc,Cot,Delta,Kronecker,epsTensor, 
          g,sum};
      Particles[Current] = {};
      Particles[ALL] = {};
      
      
      (* ------------ Dirac Spinors ------------ *)
      
      diracSub={};
      diracSubBack={};
      diracSubBack1={};
      diracSubBack2={};
      
      For[i=1,i\[LessEqual]Length[dirac],
        diracSub=
          Join[diracSub,{dirac[[i,1]]\[Rule]{dirac[[i,2]],dirac[[i,3]]}}];
        If[Head[dirac[[i,3]]]===conj,
          
          diracSubBack=
              Join[diracSubBack,{RE[dirac[[i,3]]]\[Rule]bar[dirac[[i,1]]]}];,
          diracSubBack=Join[diracSubBack,{dirac[[i,3]]\[Rule]dirac[[i,1]]}];
          ];
        If[Head[dirac[[i,2]]]===conj,
          
          diracSubBack=
              Join[diracSubBack,{RE[dirac[[i,2]]]\[Rule]bar[dirac[[i,1]]]}];,
          diracSubBack=Join[diracSubBack,{dirac[[i,2]]\[Rule]dirac[[i,1]]}];
          ];
        
        diracSubBack1=
          Join[diracSubBack1,{RE[dirac[[i,3]]]\[Rule]dirac[[i,1]]}];
        diracSubBack2=
          Join[diracSubBack2,{RE[dirac[[i,2]]]\[Rule]dirac[[i,1]]}];
        If[MemberQ[realVar,dirac[[i,2]]]\[Equal]True,
          realVar=Join[realVar,{dirac[[i,1]]}];
          ];
        i++;];
      
      diracFermion = Transpose[dirac][[1]];
      
      
      CreateParameterFile;
      CreateParticleFile;
      
       CheckModelFile;
      
      (* Create All Fields *)
      
      Print["Create all component Fields"];
      
      SFields = Table[{}, {AnzahlChiral}];
      FFields = Table[{}, {AnzahlChiral}];
      AFields = Table[{}, {AnzahlChiral}];
      
      SFieldsMultiplets = Table[{}, {AnzahlChiral}];
      FFieldsMultiplets = Table[{}, {AnzahlChiral}];
      AFieldsMultiplets = Table[{}, {AnzahlChiral}];
      
      SFieldList={};
      FFieldList={};
      AFieldList={};
      
      appendIndex={"","b","c","d","e","f","g","h","i","j","k"};
      
      
      SGauge=Table[{},{AnzahlGauge}];
      FGauge=Table[{},{AnzahlGauge}];
      gGauge=Table[{},{AnzahlGauge}];
      aGauge=Table[{},{AnzahlGauge}];
      
      For[i=1,i\[LessEqual]AnzahlGauge,
        If[Gauge[[i,2]]=!=U[1],
          Gauge[[i]] = Join[Gauge[[i]],{1}];,
          If[FreeQ[ParameterDefinitions,Gauge[[i,4]]]\[Equal]False,
            pos=Position[Transpose[ParameterDefinitions][[1]],Gauge[[i,4]]];
            If[pos=!={},
              
              gutRen=GUTnormalization/.Extract[ParameterDefinitions,
                      pos[[1,1]]][[2]];
              If[NumericQ[gutRen],
                GUTren[i]=gutRen,
                GUTren[i]= 1;
                ];,
              GUTren[i]= 1;
              ];,
            GUTren[i]= 1;
            ];
          For[j=1,j\[LessEqual]AnzahlGauge,
            If[Gauge[[j,2]]===U[1] && i\[NotEqual] j,
              
              newGC = ToExpression[
                  ToString[Gauge[[i,4]]]<>ToString[Gauge[[j,4]]]];
              GaugesU1[i,j]=newGC;
              parameters=Join[parameters,{{newGC,{},{}}}];
              U1MixingParameters=Join[U1MixingParameters,{newGC}];
              realVar=Join[realVar,{newGC}];
              ];
            j++;];
          ];
        i++;];
      
      ListFields = {};
      typeList={};
      
      
      For[i=1, i\[LessEqual] AnzahlChiral,
        temp= GenerateAllIndizes[i];
        indizes=temp[[1]];
        Expandedindizes=temp[[2]];
        absI=temp[[3]];
        absE=temp[[4]];
        
        If[Dimensions[Fields[[i,1]]]=!={} &&  Head[Fields[[i,1]]]=!=conj,
          
          FieldNames=
              Intersection[
                DeleteCases[Flatten[Fields[[i,1]]],
                    x_?NumericQ] /.x_? NumericQ\[Rule]1];,
          FieldNames ={Fields[[i,1]]};
          ];
        
        subScalar={};
        subFermion={};
        subAux={};
        
        scalarSF = ToExpression["S"<>ToString[Fields[[i,3]]]];
        fermionSF = ToExpression["F"<>ToString[Fields[[i,3]]]];
        auxiliarySF = ToExpression["A"<>ToString[Fields[[i,3]]]];
        
        For[j=1,j\[LessEqual]Length[FieldNames],
          If[Head[FieldNames[[j]]]===conj,
            name= ToString[FieldNames[[j,1]]];,
            name = ToString[FieldNames[[j]]];
            ];
          
          scalar = ToExpression["S"<>name];
          fermion = ToExpression["F"<>name];
          auxiliary = ToExpression["A"<>name];
          
          For[j2=1,j2\[LessEqual]AnzahlGauge,
            If[Gauge[[j2,5]]\[Equal]True,
              diff=Abs[Fields[[i,j2+3]]];,
              diff=1;
              ];
            
            SA`Casimir[scalar,j2]=SA`Casimir[scalarSF,j2]/diff;
            SA`Casimir[fermion,j2]=SA`Casimir[scalarSF,j2]/diff;
            SA`Dynkin[scalar,j2]=SA`Dynkin[scalarSF,j2]/diff;
            SA`Dynkin[fermion,j2]=SA`Dynkin[scalarSF,j2]/diff;
            MultiplicityFactor[scalar,j2] = MultiplicityList[[i,j2]];
            MultiplicityFactor[fermion,j2] = MultiplicityList[[i,j2]];
            j2++;];
          
          If[Head[Fields[[i,1]]]=!=List,
            usedInd=absI;,
            usedInd={}
            ];
          
          If[Head[FieldNames[[j]]]===conj,
            
            subScalar=
              Join[subScalar,{FieldNames[[j]]->conj[scalar[usedInd]]}];
            
            subFermion=
              Join[subFermion,{FieldNames[[j]]->conj[fermion[usedInd]]}];
            subAux=Join[subAux,{FieldNames[[j]]->conj[auxiliary[usedInd]]}];
            SFieldList=Join[SFieldList,{conj[scalar[absI]]}];
            FFieldList=Join[FFieldList,{conj[fermion[absI]]}];
            AFieldList=Join[AFieldList,{conj[auxiliary[absI]]}];,
            subScalar=Join[subScalar,{FieldNames[[j]]->scalar[usedInd]}];
            subFermion=Join[subFermion,{FieldNames[[j]]->fermion[usedInd]}];
            subAux=Join[subAux,{FieldNames[[j]]->auxiliary[usedInd]}];
            SFieldList=Join[SFieldList,{scalar[absI]}];
            FFieldList=Join[FFieldList,{fermion[absI]}];
            AFieldList=Join[AFieldList,{auxiliary[absI]}];
            ];
          
          
          addParticle[scalar,absI,Fields[[i,2]],S];
          addParticle[fermion,absI,Fields[[i,2]],F];
          addParticle[auxiliary,absI,Fields[[i,2]],A];
          j++;];
        
        
        SFieldsMultiplets [[i]]=Fields[[i,1]] /. subScalar /. A_[{}]\[Rule]A;
        FFieldsMultiplets [[i]]=
          Fields[[i,1]] /. subFermion /. A_[{}]\[Rule]A;
        AFieldsMultiplets [[i]]=Fields[[i,1]] /. subAux /. A_[{}]\[Rule]A;
        
        
        If[Head[Fields[[i,1]]]=!=List,
          SFields[[i]]=Fields[[i,1]] /. subScalar;
          FFields[[i]]=Fields[[i,1]] /. subFermion;
          AFields[[i]]=Fields[[i,1]] /. subAux;
          typeList=Join[typeList,{{SFields[[i]],S}}];
          typeList=Join[typeList,{{FFields[[i]],F}}];
          typeList=Join[typeList,{{AFields[[i]],A}}];,
          
          
          SFields[[i]]=
            ToExpression["S"<>ToString[Fields[[i,3]]]][absE][absI];
          FFields[[i]]=
            ToExpression["F"<>ToString[Fields[[i,3]]]][absE][absI];
          
          AFields[[i]]=
            ToExpression["A"<>ToString[Fields[[i,3]]]][absE][absI];
          
          
          
          Set[ToExpression["S"<>ToString[Fields[[i,3]]]][{x__Integer}][{c__}],
            Hold[(Extract[SFieldsMultiplets [[NR]],{x}]/
                      DeleteCases[Extract[SFieldsMultiplets [[NR]],{x}],
                        y_?NumberQ,4]) DeleteCases[
                      Extract[SFieldsMultiplets [[NR]],{x}],y_?NumberQ,
                      4][{c}]] /. NR\[Rule]i];
          
          
          Set[ToExpression["F"<>ToString[Fields[[i,3]]]][{x__Integer}][{c__}][
              d_],Hold[(Extract[FFieldsMultiplets [[NR]],{x}]/
                      DeleteCases[Extract[FFieldsMultiplets [[NR]],{x}],
                        y_?NumberQ,4]) DeleteCases[
                        Extract[FFieldsMultiplets [[NR]],{x}],y_?NumberQ,
                        4][{c}][d]] /. NR\[Rule]i];
          
          
          Set[ToExpression["A"<>ToString[Fields[[i,3]]]][{x__Integer}][{c__}],
            Hold[(Extract[AFieldsMultiplets [[NR]],{x}]/
                      DeleteCases[Extract[AFieldsMultiplets [[NR]],{x}],
                        y_?NumberQ,4]) DeleteCases[
                      Extract[AFieldsMultiplets [[NR]],{x}],y_?NumberQ,
                      4][{c}]] /. NR\[Rule]i]; 
          
          
          typeList=
            Join[typeList,{{ToExpression["S"<>ToString[Fields[[i,3]]]],S}}];
          
          typeList=
            Join[typeList,{{ToExpression["F"<>ToString[Fields[[i,3]]]],F}}];
          
          typeList=
            Join[typeList,{{ToExpression["A"<>ToString[Fields[[i,3]]]],A}}];
          
          
          ];
        
        ListFields = 
          Join[ListFields,{{Fields[[i,3]],{absE,Expandedindizes},{absI,
                  indizes}}}];
        i++;
        ];
      
      
      
      For[i=1,i\[LessEqual]Length[Traceless],
        realVar=Join[realVar,{SFields[[Traceless[[i,1]]]]}];
        i++];
      
      
      subIndizes={};
      subIndizesRE={};
      subIndizesRE2={};
      subIndizesREFinal={};
      subIndizesFinal={};
      subIndizesFinalX={};
      subIndizesInt={};
      subIndizesMixStart={};
      subIndizesMixEnde={};
      subIndizesValue={};
      
      subIndizesRule={};
      
      listIndizes=Table[{},{AnzahlGauge}];
      
      For[i=1, i\[LessEqual]AnzahlGauge,
        If[FreeQ[parameters,Gauge[[i,4]]],
          parameters=Join[parameters,{{Gauge[[i,4]],{},{}}}];
          ];
        indizes = {generation};
        indizesVB = Join[indizes,{lorentz}];
        SGauge[[i]]=ToExpression["V"<>ToString[Gauge[[i,1]]]][indizesVB];
        FGauge[[i]]=ToExpression["f"<>ToString[Gauge[[i,1]]]][indizes];
        gGauge[[i]]=ToExpression["g"<>ToString[Gauge[[i,1]]]][indizes];
        aGauge[[i]]=ToExpression["a"<>ToString[Gauge[[i,1]]]][indizes];
        
        typeList=Join[typeList,{{SGauge[[i]],S}}];
        typeList=Join[typeList,{{FGauge[[i]],F}}];
        typeList=Join[typeList,{{aGauge[[i]],A}}];
        typeList=Join[typeList,{{gGauge[[i]],G}}]; 
        
        If[Gauge[[i,2]]===U[1],
          nGen=1;
          Generator[i,a_,b__]=GUTren[i] a;,
          If[Head[Gauge[[i,2]]]===SU,
            nGen=Gauge[[i,2,1]]^2-1;,
            
            nGen = DimR[SusynoForm[Gauge[[i,2]]],
                  Adjoint[SusynoForm[Gauge[[i,2]]]]];
            ];
          If[Head[Gauge[[i,2]]]===SU,
            SA`Casimir[getBlank[SGauge[[i]]],i]=Gauge[[i,2,1]];
            SA`Dynkin[getBlank[SGauge[[i]]],i]=Gauge[[i,2,1]];
            SA`Casimir[getBlank[FGauge[[i]]],i]=Gauge[[i,2,1]];
            SA`Dynkin[getBlank[FGauge[[i]]],i]=Gauge[[i,2,1]];,
            
            SA`Casimir[getBlank[SGauge[[i]]],i]=
              Casimir[SusynoForm[Gauge[[i,2]]],
                Adjoint[SusynoForm[Gauge[[i,2]]]]];
            
            SA`Dynkin[getBlank[SGauge[[i]]],i]=
              Casimir[SusynoForm[Gauge[[i,2]]],
                Adjoint[SusynoForm[Gauge[[i,2]]]]];
            
            SA`Casimir[getBlank[FGauge[[i]]],i]=
              Casimir[SusynoForm[Gauge[[i,2]]],
                Adjoint[SusynoForm[Gauge[[i,2]]]]];
            
            SA`Dynkin[getBlank[FGauge[[i]]],i]=
              Casimir[SusynoForm[Gauge[[i,2]]],
                Adjoint[SusynoForm[Gauge[[i,2]]]]];
            
            ];
          
          
          Generator[i,1,a__]=0;  
          For[j=1,j\[LessEqual]Gauge[[i,6]],
            If[Head[Gauge[[i,2]]]===SU,
              
              Set[NumberStates[
                    ToExpression[ToString[Gauge[[i,3]]]<>appendIndex[[j]]],_],
                  Gauge[[i,2,1]]];,
              For[k=1,k\[LessEqual]Length[Fields],
                  
                  Set[NumberStates[Gauge[[i,3]],Fields[[k,3]]],
                    FieldDim[k,i]];
                  
                  Set[NumberStates[
                      Gauge[[i,3]],(AFields[[k]] //. a_[{b__}]\[Rule]a)],
                    FieldDim[k,i]];
                  
                  Set[NumberStates[
                      Gauge[[i,3]],(FFields[[k]] //. a_[{b__}]\[Rule]a)],
                    FieldDim[k,i]];
                  
                  Set[NumberStates[
                      Gauge[[i,3]],(SFields[[k]] //. a_[{b__}]\[Rule]a)],
                    FieldDim[k,i]];
                  k++;];
              ];
            
            listIndizes[[i]]=
              Join[listIndizes[[i]],{ToExpression[
                    ToString[Gauge[[i,3]]]<>appendIndex[[j]]]}];
            
            subIndizes=
              Join[subIndizes,{ToExpression[
                      ToString[Gauge[[i,3]]]<>
                        appendIndex[[j]]]\[Rule] (Hold[
                          ToExpression[
                            basis<>ToString[number]<>app]]/. {basis\[Rule]
                            StringTake[ToString[Gauge[[i,3]]],3], 
                          app \[Rule] appendIndex[[j]]})}];
            
            subIndizesRule=
              Join[subIndizesRule,{ToExpression[
                      ToString[Gauge[[i,3]]]<> 
                        appendIndex[[j]]]\[Rule] (Hold[
                          ToExpression[
                            basis<>ToString[number]<>app<>
                              "_"]]/. {basis\[Rule]StringTake[
                              ToString[Gauge[[i,3]]],3],
                          app \[Rule] appendIndex[[j]]})}];
            
            subIndizesRE=
              Join[subIndizesRE,{(Hold[
                          ToExpression[basis<>ToString[number1]<>app]]\[Rule] 
                        Hold[ToExpression[basis<>ToString[number2]<>app]])/.{ 
                      basis->StringTake[ToString[Gauge[[i,3]]],3],
                      app \[Rule] appendIndex[[j]]}}];
            If[Head[Gauge[[i,2]]]===SU,
              
              subIndizesRE2=
                  Join[subIndizesRE2,{(Hold[
                              ToExpression[
                                basis<>ToString[number1]<>app]]\[Rule] 
                            Hold[ToExpression[
                                basis<>ToString[number2]<>app]])/.{ 
                          basis->StringTake[ToString[Gauge[[i,3]]],3],
                          app \[Rule] appendIndex[[j]]}}];
              ];
            
            subIndizesREFinal=
              Join[subIndizesREFinal,{(Hold[
                          ToExpression[basis<>ToString[number1]<>app]]\[Rule] 
                        Hold[ToExpression[
                            basis<>ToString[number2]<>
                              app]])/. {basis->(StringTake[
                              ToString[Gauge[[i,3]]],1]<>"t"),
                      app \[Rule] appendIndex[[j]]}}];
            
            subIndizesFinal=
              Join[subIndizesFinal,{(Hold[
                          ToExpression[
                            basis1<>ToString[number1]<>app]]\[Rule] 
                        Hold[ToExpression[
                            basis2<>ToString[number2]<>app]])/. {basis1->
                        StringTake[ToString[Gauge[[i,3]]],3],
                      app \[Rule] appendIndex[[j]], 
                      basis2\[Rule](StringTake[ToString[Gauge[[i,3]]],1]<>
                            "t")}}];
            
            subIndizesFinalX=
              Join[subIndizesFinalX,{(Hold[
                            ToExpression[
                              basis1<>ToString[number1]<>app]]\[Rule] 
                          Hold[ToExpression[
                              basis2<>xname<>ToString[number2]<>
                                app]])/. {basis1->
                          StringTake[ToString[Gauge[[i,3]]],3],
                        app \[Rule] appendIndex[[j]]}/. 
                    basis2\[Rule](StringTake[ToString[Gauge[[i,3]]],1])}];
            
            subIndizesValue=
              Join[subIndizesValue,{(Hold[
                          ToExpression[
                            basis1<>ToString[number1]<>app]]\[Rule] 
                        Hold[number2])/. {basis1->
                        StringTake[ToString[Gauge[[i,3]]],3],
                      app \[Rule] appendIndex[[j]]}}];
            (* 
              subIndizesInt=
                  Join[subIndizesInt,{(Hold[
                              ToExpression[
                                basis<>ToString[number]<>app]]/. {basis->
                                StringTake[ToString[Gauge[[i,3]]],3],
                              app \[Rule] appendIndex[[j]]})\[Rule](Hold[
                              ToExpression[
                                "aaI"<>basis<>ToString[number]<>app]]/.{basis->
                                StringTake[ToString[Gauge[[i,3]]],3],
                              app \[Rule] appendIndex[[j]]})}]; *)
           
             subIndizesInt=
              Join[subIndizesInt,{(Hold[
                          ToExpression[
                            basis<>ToString[number]<>app]]/. {basis->
                            StringTake[ToString[Gauge[[i,3]]],3],
                          app \[Rule] appendIndex[[j]]})\[Rule](Hold[
                          ToExpression[
                            "aaI"<>basis<>ToString[1]<>app]]/.{basis->
                            StringTake[ToString[Gauge[[i,3]]],3],
                          app \[Rule] appendIndex[[j]]})}];
            
            subIndizesMixStart=
              Join[subIndizesMixStart,{ToExpression[
                      ToString[Gauge[[i,3]]]<>
                        appendIndex[[j]]]\[Rule]ToExpression[
                      StringTake[ToString[Gauge[[i,3]]],3]<>appendIndex[[j]]<>
                        ToString[_]]}];
            
            subIndizesMixEnde=
              Join[subIndizesMixEnde,{ToExpression[
                      ToString[Gauge[[i,3]]]<>appendIndex[[j]]]\[Rule]
                    ToExpression[
                      StringTake[ToString[Gauge[[i,3]]]<>appendIndex[[j]],
                        3]]}]; 
            j++;];
          ];
        
        addParticle[ToExpression["V"<>ToString[Gauge[[i,1]]]],indizesVB,nGen,
          V];
        addParticle[ToExpression["f"<>ToString[Gauge[[i,1]]]],indizes,nGen,
          F];
        addParticle[ToExpression["g"<>ToString[Gauge[[i,1]]]],indizes,nGen,
          G];
        addParticle[ToExpression["a"<>ToString[Gauge[[i,1]]]],indizes,nGen,
          A];
        Gauginos = Join[Gauginos,{FGauge[[i]]}];
        Gauginos = Join[Gauginos,{FGauge[[i]] /. diracSubBack1}];
        bosons=Join[bosons,{SGauge[[i]]}];
        OnlyOneGen=
          Join[OnlyOneGen,{FGauge[[i]],FGauge[[i]] /. diracSubBack1,
              SGauge[[i]],gGauge[[i]]}];
        If[Gauge[[i,3]]===color,
          
          ColoredGaugeParticles=
            Join[ColoredGaugeParticles,{aGauge[[i]],FGauge[[i]],
                FGauge[[i]] /. diracSubBack1,SGauge[[i]],gGauge[[i]]}];
          OnlyOneGen=Join[OnlyOneGen,{aGauge[[i]]}];
          ];
        realVar=
          Join[realVar,{Head[SGauge[[i]]],Head[gGauge[[i]]],Head[aGauge[[i]]],
              Gauge[[i,4]]}];
        i++;
        ];
      
      subIndizes = 
        Join[subIndizes,{generation \[Rule]
              Hold[ToExpression["gen"<>ToString[number]]],
            flavor \[Rule]Hold[ToExpression["fla"<>ToString[number]]],
            lorentz \[Rule]Hold[ToExpression["lor"<>ToString[number]]]}];
      subIndizesRule = 
        Join[subIndizesRule,{generation \[Rule]
              Hold[ToExpression["gen"<>ToString[number]<>"_"]],
            flavor \[Rule]Hold[ToExpression["fla"<>ToString[number]<>"_"]],
            lorentz \[Rule]Hold[
                ToExpression["lor"<>ToString[number]<>"_"]]}];
      (* subIndizesInt = 
            Join[subIndizesInt,{Hold[ToExpression["gen"<>ToString[number]]]->
                  Hold[ToExpression["aaIgen"<>ToString[number]]],
                Hold[ToExpression["lor"<>ToString[number]]]\[Rule]Hold[
                    ToExpression["aaIlor"<>ToString[number]]]}]; *)
      
      subIndizesInt = 
        Join[subIndizesInt,{Hold[ToExpression["gen"<>ToString[number]]]->
              Hold[ToExpression["aaIgen"<>ToString[1]]],
            Hold[ToExpression["fla"<>ToString[number]]]->
              Hold[ToExpression["aaIfla"<>ToString[1]]],
            Hold[ToExpression["lor"<>ToString[number]]]\[Rule]
              Hold[ToExpression["aaIlor"<>ToString[1]]]}];
      subIndizesRE = 
        Join[subIndizesRE,{Hold[ToExpression["gen"<>ToString[number1]]]\[Rule]
              Hold[ToExpression["gen"<>ToString[number2]]],
            Hold[ToExpression["fla"<>ToString[number1]]]\[Rule]
              Hold[ToExpression["fla"<>ToString[number2]]],
            Hold[ToExpression["lor"<>ToString[number1]]] \[Rule]
              Hold[ToExpression["lor"<>ToString[number2]]]}];
      subIndizesRE2 = 
        Join[subIndizesRE2,{Hold[
                ToExpression["gen"<>ToString[number1]]]\[Rule]
              Hold[ToExpression["gen"<>ToString[number2]]],
            Hold[ToExpression["fla"<>ToString[number1]]]\[Rule]
              Hold[ToExpression["fla"<>ToString[number2]]],
            Hold[ToExpression["lor"<>ToString[number1]]] \[Rule]
              Hold[ToExpression["lor"<>ToString[number2]]]}];
      subIndizesREFinal = 
        Join[subIndizesRE,{Hold[ToExpression["gt"<>ToString[number1]]]\[Rule]
              Hold[ToExpression["gt"<>ToString[number2]]],
            Hold[ToExpression["ft"<>ToString[number1]]]\[Rule]
              Hold[ToExpression["ft"<>ToString[number2]]],
            Hold[ToExpression["lt"<>ToString[number1]]] \[Rule]
              Hold[ToExpression["lt"<>ToString[number2]]]}];
      subIndizesFinal = 
        Join[subIndizesFinal,{Hold[
                ToExpression["gen"<>ToString[number1]]]\[Rule]
              Hold[ToExpression["gt"<>ToString[number2]]],
            Hold[ToExpression["fla"<>ToString[number1]]]\[Rule]
              Hold[ToExpression["ft"<>ToString[number2]]],
            Hold[ToExpression["lor"<>ToString[number1]]] \[Rule]
              Hold[ToExpression["lt"<>ToString[number2]]]}];
      subIndizesFinalX = 
        Join[subIndizesFinalX,{Hold[
                ToExpression["gen"<>ToString[number1]]]\[Rule]Hold[
                ToExpression["g"<>xname<>ToString[number2]]],
            Hold[ToExpression["fla"<>ToString[number1]]]\[Rule]
              Hold[ToExpression["f"<>xname<>ToString[number2]]],
            Hold[ToExpression["lor"<>ToString[number1]]] \[Rule]
              Hold[ToExpression["l"<>xname<>ToString[number2]]]}];
      subIndizesMixStart=
        Join[subIndizesMixStart,{generation\[Rule]xgen_,flavor\[Rule]fla_,
            lorentz\[Rule]lor_}];
      subIndizesMixEndeNoFV=
        Join[subIndizesMixEnde,{generation\[Rule]xgen, lorentz\[Rule]lor, 
            flavor \[Rule]Hold[
                ToExpression["fla"<>StringDrop[ToString[xgen],3]]]}]; 
      subIndizesMixEnde=
        Join[subIndizesMixEnde,{generation\[Rule]
              Hold[ToExpression["n"<>StringDrop[ToString[xgen],3]]], 
            lorentz\[Rule]lor, flavor \[Rule]fla}]; 
      
      
      
      subGC[nr_]:=Return[ReleaseHold[subIndizes /. number \[Rule]nr]];
      subGCRule[nr_]:=
        Return[ReleaseHold[subIndizesRule /. number \[Rule]nr]];
      subGCInt[nr_]:=Return[ReleaseHold[subIndizesInt/. {number \[Rule]nr}]];
      subGCRE[nr1_,nr2_]:=
        Return[ReleaseHold[
            subIndizesRE /. {number1 \[Rule]nr1, number2\[Rule]nr2}]];
      subREfinal[nr1_,nr2_]:=
        Return[ReleaseHold[
            subIndizesREFinal /. {number1 \[Rule]nr1, number2\[Rule]nr2}]];
      subIndFinal[nr1_,nr2_]:=
        Return[ReleaseHold[
            subIndizesFinal /. {number1 \[Rule]nr1, number2\[Rule]nr2}]];
      subIndFinalX[nr1_,nr2_,x_]:=
        Return[ReleaseHold[
            subIndizesFinalX /. {number1 \[Rule]nr1, number2\[Rule]nr2,
                xname\[Rule]x}]];
      subValue[nr1_,nr2_]:=
        Return[ReleaseHold[
            subIndizesValue /. {number1 \[Rule]nr1, number2\[Rule]nr2}]];
      
      
      
      makeSubFinalIndizes;
      
      
      For[i=1,i\[LessEqual]Length[SA`CasimirList],
        SA`Casimir[
            getBlank[
              ToExpression["S"<>ToString[Fields[[SA`CasimirList[[i,1]],3]]]]],
            SA`CasimirList[[i,2]]]=SA`CasimirList[[i,3]];
        SA`Casimir[getBlank[getBlank[SFields[[SA`CasimirList[[i,1]]]]]],
            SA`CasimirList[[i,2]]]=SA`CasimirList[[i,3]];
        SA`Dynkin[getBlank[getBlank[SFields[[SA`CasimirList[[i,1]]]]]],
            SA`CasimirList[[i,2]]]=SA`CasimirList[[i,4]];
        SA`Casimir[Fields[[SA`CasimirList[[i,1]],3]],SA`CasimirList[[i,2]]]=
          SA`CasimirList[[i,3]];
        SA`Dynkin[Fields[[SA`CasimirList[[i,1]],3]],SA`CasimirList[[i,2]]]=
          SA`CasimirList[[i,4]];
        SA`Dynkin[
            ToExpression["S"<>ToString[Fields[[SA`CasimirList[[i,1]],3]]]],
            SA`CasimirList[[i,2]]]=SA`CasimirList[[i,4]];
        i++;];
      
      
      
      (*---------------- Majorana Particles ------*)
      
      MajoranaPart={};
      
      For[i=1,i\[LessEqual]Length[dirac],
        If[{conj[dirac[[i,3]]],conj[dirac[[i,2]]]}==={dirac[[i,2]],
              dirac[[i,3]]},
          MajoranaPart = Join[MajoranaPart,{dirac[[i,1]]}];
          ];
        i++;];
      
      
      (*------------- DeleteFields -------------- *)
      
      deleteTemp= DeleteParticles;
      DeleteParticles={};
      
      For[i=1,i\[LessEqual]Length[deleteTemp],
        If[FreeQ[Fields,deleteTemp[[i]]]\[Equal]True,
          DeleteParticles=Join[DeleteParticles,{deleteTemp[[i]]}];,
          pos=Position[Fields,deleteTemp[[i]]][[1,1]];
          
          If[Length[
                Intersection[
                  DeleteCases[Flatten[SFieldsMultiplets[[pos]]],x_?NumberQ,
                    4]]]\[Equal]1,
            
            DeleteParticles=
              Join[DeleteParticles,{getBlank[
                    Intersection[
                      DeleteCases[Flatten[SFieldsMultiplets[[pos]]],
                        x_?NumberQ,4]]]}];
            
            DeleteParticles=
              Join[DeleteParticles,{getBlank[
                    Intersection[
                      DeleteCases[Flatten[FFieldsMultiplets[[pos]]],
                        x_?NumberQ,4]]]}];
            DeleteParticles=
              Join[DeleteParticles,{getBlank[
                    Intersection[
                      DeleteCases[Flatten[AFieldsMultiplets[[pos]]],
                        x_?NumberQ,4]]]}];,
            
            DeleteParticles=
              Join[DeleteParticles,
                Intersection[
                  DeleteCases[Flatten[SFieldsMultiplets[[pos]]],x_?NumberQ,
                    4]]];
            
            DeleteParticles=
              Join[DeleteParticles,
                Intersection[
                  DeleteCases[Flatten[FFieldsMultiplets[[pos]]],x_?NumberQ,
                    4]]];
            
            DeleteParticles=
              Join[DeleteParticles,
                Intersection[
                  DeleteCases[Flatten[AFieldsMultiplets[[pos]]],x_?NumberQ,
                    4]]];
            ];
          ];
        i++;];
      
      For[i=1,i\[LessEqual]Length[NameOfStates],
        InitSMParameters[NameOfStates[[i]]];
        i++;];
      
      ];


 InitParameters := Block[{i,k,max},
      
      Print["Generate Parameter Dependences"];
      
      MayBeParameters={};
      
      For[i=1,i\[LessEqual]Length[ParameterDefinitions],
        If[((Dependence /. ParameterDefinitions[[i,2]])=!= 
                Dependence) &&
            ((Dependence /. 
                    ParameterDefinitions[[i,2]])=!= None),
          dep=Dependence /. ParameterDefinitions[[i,2]];
          If[Head[dep]=!= List,
            max=0;
            If[FreeQ[dep,index1]\[Equal]False, max=1;];
            If[FreeQ[dep,index2]\[Equal]False, max=2;];
            If[FreeQ[dep,index3]\[Equal]False, max=3;];
            
            temp =RE[dep /. sum[a_,b_,c_]\[Rule]1 /. Delta[a_,b_]\[Rule]1];
            
            
            
            Switch[max,
              0,
              subAlways = 
                Join[subAlways,{ParameterDefinitions[[i,1]]\[Rule]dep}];
              
              NewParameters=
                Cases[DeleteCases[Cases[temp,SymbolQ_,3],x_?NumericQ,2],
                  x_?AtomQ];,
              1,
              subAlways = 
                Join[subAlways,{ParameterDefinitions[[i,1]][
                        index1_]\[Rule]dep}];
              
              NewParameters=
                Cases[DeleteCases[Cases[temp,SymbolQ_,3],x_?NumericQ,2],
                    x_[a_]] /. x_[a_]\[Rule]x;,
              2,
              subAlways = 
                Join[subAlways,{ParameterDefinitions[[i,1]][index1_,
                        index2_]\[Rule]dep}];
              
              NewParameters=
                Cases[DeleteCases[Cases[temp,SymbolQ_,3],x_?NumericQ,2],
                    x_[a_,b_]]/. x_[a_,b_]\[Rule]x;,
              3,
              subAlways = 
                Join[subAlways,{ParameterDefinitions[[i,1]][index1_,index2_,
                        index3_]\[Rule]dep}];
              
              NewParameters=
                Cases[DeleteCases[Cases[temp,SymbolQ_,3],x_?NumericQ,2],
                    x_[a_,b_,c_]]/. x_[a_,b_,c_]\[Rule]x;
              ];
            
            For[k=1,k\[LessEqual]Length[NewParameters],
              If[FreeQ[MayBeParameters,NewParameters[[k]]],
                
                MayBeParameters=
                    Join[MayBeParameters,{{NewParameters[[k]],
                          Table[generation,{max}],
                          GetDimParameters[ParameterDefinitions[[i,1]]]}}];
                ];
              k++;];
            
            
            ];
          ];
        i++;];
      
      
       Print["Set Information for Rotations"];
      
      For[i=1,i\[LessEqual]Length[FieldRotations],
        If[FreeQ[parameters,FieldRotations[[i,2]]]\[Equal]True,
          
          parameters = 
              Join[parameters,{{FieldRotations[[i,2]],{generation,
                      generation},{getGen[getScalar[FieldRotations[[i,1,1]]]],
                      getGen[getScalar[FieldRotations[[i,1,1]]]]}}}];
          ];
        i++;];
      
      
      ];

(*-------------------------------------------*)
(* VEVs *)
\
(*-------------------------------------------*)

GenerateVEVs[type_] := Block[{i,j,i2,vev,pos,form,scalarform},
      
      title=ToString[type];
      
      Print["Parametrize Higgs Sector"];
      
      
      vevSub={};
      vevSubInverse={};
      vev = DEFINITION[type][VEVs];
      
      If[Head[Head[vev]]===DEFINITION,vev={}];
      
      For[i=1,i\[LessEqual]Length[vev],
        pos=Position[Transpose[ParameterDefinitions][[1]],vev[[i,2,1]]];
        scalarform=False;
        If[pos=!={},
          If[(Form /.  ParameterDefinitions[[pos[[1,1]],2]])===Scalar,
              vev[[i,2,1]][{x__}]=vev[[i,2,1]];
              scalarform=True;
              ];
          ];
        
        vevSub = 
          Join[vevSub,{vev[[i,1]][x_]\[Rule]Sum[
                  vev[[i,n,2]]*vev[[i,n,1]][x],{n,2,4}]}];
        vevSubInverse = Join[vevSubInverse,{vev[[i,3,1]][x_]\[Rule] 
                - vev[[i,3,2]](vev[[i,1]][x]-conj[vev[[i,1]][x]]),
              vev[[i,4,1]][x_]\[Rule] 
                
                vev[[i,4,2]](vev[[i,1]][x]+
                      conj[vev[[i,1]][x]]-2 vev[[i,2,1]][x] )}];
         
        
        If[FreeQ[parameters,vev[[i,2,1]]],
          
          addParticle[ vev[[i,2,1]],getIndizes[vev[[i,1]]],getGen[vev[[i,1]]],
            VEV];
          If[getGen[vev[[i,1]]]=!=1 && scalarform\[Equal]False,
            
            parameters = 
                Join[parameters, {{ 
                      vev[[i,2,1]], {generation}, {getGen[vev[[i,1]]]}}}];,
            parameters = Join[parameters, {{ vev[[i,2,1]], {}, {1}}}];
            ];
          ];
        addParticle[ vev[[i,3,1]],getIndizes[vev[[i,1]]],getGen[vev[[i,1]]],
          getType[vev[[i,1]]]];
        addParticle[ vev[[i,4,1]],getIndizes[vev[[i,1]]],getGen[vev[[i,1]]],
          getType[vev[[i,1]]]];
        
        For[i2=1,i2\[LessEqual]AnzahlGauge,
           If[FreeQ[BrokenSymmetries,i2]\[Equal]True,
            SA`Casimir[vev[[i,3,1]],i2]=SA`Casimir[vev[[i,1]],i2];
            SA`Dynkin[vev[[i,3,1]],i2]=SA`Dynkin[vev[[i,1]],i2];
            
            MultiplicityFactor[vev[[i,3,1]],i2]=
              MultiplicityFactor[vev[[i,1]],i2];
            SA`Casimir[vev[[i,4,1]],i2]=SA`Casimir[vev[[i,1]],i2];
            SA`Dynkin[vev[[i,4,1]],i2]=SA`Dynkin[vev[[i,1]],i2];
            
            MultiplicityFactor[vev[[i,4,1]],i2]=
              MultiplicityFactor[vev[[i,1]],i2];
            ];
          i2++;];
        
        realVar=Join[realVar,{vev[[i,2,1]],vev[[i,3,1]],vev[[i,4,1]]}];
        delParticle[vev[[i,1]]];
        i++];
      
      VevSub[type]=vevSub;
      VevSubInverse[type]=vevSubInverse;
      
      
      UpdateGaugeTransformations[vevSub,vevSubInverse];
      
      
      
      ];



InitSMParameters[Eigenstates_] :=Block[{i,j,k,tempName},
      AllScalarNonSM={};
      AllFermionNonSM={};
      AllVectorNonSM={};
      For[i=1,i\[LessEqual]Length[ParticleDefinitions[Eigenstates]],
        Switch[getType[ParticleDefinitions[Eigenstates][[i,1]]],
          S,
          AllScalarNonSM=
              Join[AllScalarNonSM,{ParticleDefinitions[Eigenstates][[i,
                      1]]}];,
          F,
          AllFermionNonSM=
              Join[
                AllFermionNonSM,{ParticleDefinitions[Eigenstates][[i,1]]}];,
          V,
          AllVectorNonSM=
              Join[AllVectorNonSM,{ParticleDefinitions[Eigenstates][[i,1]]}];
          ];
        
        
        AllScalarNonSM = 
          Select[AllScalarNonSM,(FreeQ[Particles[Eigenstates],#]\[Equal]
                  False)&];
        AllFermionNonSM = 
          Select[AllFermionNonSM,(FreeQ[
                    Particles[Eigenstates] /. diracSubBack,#]\[Equal]
                  False)&];
        
        
        Switch[Description /. ParticleDefinitions[Eigenstates][[i,2]],
          "Leptons",
          	Electron = ParticleDefinitions[Eigenstates][[i,1]];
          	
          UElectron = 
            ToExpression[
              "U"<>ToString[ParticleDefinitions[Eigenstates][[i,1]]]];,
          "Sleptons",
          	Selectron = ParticleDefinitions[Eigenstates][[i,1]];,
          "Down-Quarks",
          	BottomQuark = ParticleDefinitions[Eigenstates][[i,1]];
          	
          UBottom = 
            ToExpression[
              "U"<>ToString[ParticleDefinitions[Eigenstates][[i,1]]]];,
          "Down-Squarks",
          	BottomSquark = ParticleDefinitions[Eigenstates][[i,1]];,
          "Up-Quarks",
          	TopQuark = ParticleDefinitions[Eigenstates][[i,1]];
          	
          UTop = ToExpression[
              "U"<>ToString[ParticleDefinitions[Eigenstates][[i,1]]]];,
          "Up-Squarks",
          	TopSquark = ParticleDefinitions[Eigenstates][[i,1]];,
          "Photon",
          	VectorP= ParticleDefinitions[Eigenstates][[i,1]];,
          "Gluon",
          	VectorG= ParticleDefinitions[Eigenstates][[i,1]];,
          "Gluino",
          	Gluino= ParticleDefinitions[Eigenstates][[i,1]];,
          "W-Boson",
          	VectorW= ParticleDefinitions[Eigenstates][[i,1]];,
          "Z-Boson",
          	VectorZ= ParticleDefinitions[Eigenstates][[i,1]];,
          "Up-Squarks",
          	TopSquark= ParticleDefinitions[Eigenstates][[i,1]];,
          "Higgs",
          	HiggsBoson = ParticleDefinitions[Eigenstates][[i,1]];
          	UnmixedHiggs = ToExpression["U"<>ToString[HiggsBoson]];,
          "Pseudo-Scalar Higgs",
          	PseudoScalar= ParticleDefinitions[Eigenstates][[i,1]];,
          "Neutrinos",
          	Neutrino = ParticleDefinitions[Eigenstates][[i,1]];,
          "Charged Higgs",
          	ChargedHiggs = ParticleDefinitions[Eigenstates][[i,1]];,
          "Sneutrinos",
          	Sneutrino = ParticleDefinitions[Eigenstates][[i,1]];
          ];
        
        i++;];
      
      If[FreeQ[ParticleDefinitions[Eigenstates],"Sneutrinos"],
        Sneutrino = HiggsBoson;
        ];
      
      If[FreeQ[ParticleDefinitions[Eigenstates],"Sleptons"],
        Selectron = ChargedHiggs;
        ];
      
      For[i=1,i\[LessEqual]Length[ParameterDefinitions],
        Switch[Description /. ParameterDefinitions[[i,2]],
          "Up-Yukawa-Coupling",
          	UpYukawa = ParameterDefinitions[[i,1]];,
          "Down-Yukawa-Coupling",
          	DownYukawa = ParameterDefinitions[[i,1]];,
          "Lepton-Yukawa-Coupling",
          	ElectronYukawa = ParameterDefinitions[[i,1]];,
          "Hypercharge-Coupling",
          	hyperchargeCoupling =  ParameterDefinitions[[i,1]];,
          "Left-Coupling",
          	leftCoupling =  ParameterDefinitions[[i,1]];,
          "Strong-Coupling",
          	strongCoupling =  ParameterDefinitions[[i,1]];,
          "electric charge",
          	electricCharge =  ParameterDefinitions[[i,1]];,
          "Up-Squark-Mixing-Matrix",
          	UpSquarkMM = ParameterDefinitions[[i,1]];,
          "Down-Squark-Mixing-Matrix",
          	DownSquarkMM = ParameterDefinitions[[i,1]];,
          "Left-Lepton-Mixing-Matrix",
          	ElectronMatrixL =  ParameterDefinitions[[i,1]];,
          "Right-Lepton-Mixing-Matrix",
          	ElectronMatrixR =  ParameterDefinitions[[i,1]];,
          "Left-Down-Mixing-Matrix",
          	DownMatrixL =  ParameterDefinitions[[i,1]];,
          "Right-Down-Mixing-Matrix",
          	DownMatrixR =  ParameterDefinitions[[i,1]];,
          "Left-Up-Mixing-Matrix",
          	UpMatrixL =  ParameterDefinitions[[i,1]];,
          "Right-Up-Mixing-Matrix",
          	UpMatrixR =  ParameterDefinitions[[i,1]];,
          "CKM Matrix",
          	CKMmat =  ParameterDefinitions[[i,1]];,
          "Weinberg-Angle",
          	Weinberg = ParameterDefinitions[[i,1]];,
          "Down-VEV",
          	VEVSM1 = ParameterDefinitions[[i,1]];,
          "Up-VEV",
          	VEVSM2 = ParameterDefinitions[[i,1]];,
          "EW-VEV",
          	VEVSM = ParameterDefinitions[[i,1]];,
          "Scalar mixing angle",
          	alphaAngle = ParameterDefinitions[[i,1]];,
          "Pseudo Scalar mixing angle",
          	betaAngle = ParameterDefinitions[[i,1]];,
          "Scalar-Mixing-Matrix",
          	HiggsMixingMatrix = ParameterDefinitions[[i,1]];,
          "Pseudo-Scalar-Mixing-Matrix",
          	PseudoScalarMixingMatrix = ParameterDefinitions[[i,1]];,
          "Softbreaking right Down-Squark Mass",
          	SoftDown= ParameterDefinitions[[i,1]];,
          "Softbreaking right Up-Squark Mass",
          	SoftUp= ParameterDefinitions[[i,1]];,
          "Softbreaking left Slepton Mass",
          	SoftLeftLepton = ParameterDefinitions[[i,1]];,
          "Softbreaking right Slepton Mass",
          	SoftRightLepton = ParameterDefinitions[[i,1]];,
          "Softbreaking left Squark Mass",
          	SoftSquark = ParameterDefinitions[[i,1]];,
          "Trilinear-Up-Coupling",
          	TrilinearUp = ParameterDefinitions[[i,1]];,
          "Trilinear-Down-Coupling",
          	TrilinearDown= ParameterDefinitions[[i,1]];,
          "Trilinear-Lepton-Coupling",
          	TrilinearLepton= ParameterDefinitions[[i,1]];
          ];
        i++;];
      
      
      SMParticles={Electron, TopQuark,BottomQuark,VectorP,VectorZ,VectorG,
          VectorW,Neutrino};
      NonSMQ[x_]:=FreeQ[SMParticles,RE[x]];
      SMQ[x_]:=If[FreeQ[SMParticles,RE[x]],Return[False];,Return[True];];
      
      
      
      AllFermionNonSM=DeleteCases[AllFermionNonSM,x_?SMQ,3];
      AllScalarNonSM=DeleteCases[AllScalarNonSM,x_?SMQ,3];
      
      ];





(* End[] *)

