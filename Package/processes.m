(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)

MakeCouplingLists:=Block[{i,j,k,temp,pos},
      For[i=1,i\[LessEqual]Length[ITypes],
        ISec=Intersection[ITypes[[i]]];
        For[j=1,j\[LessEqual]Length[ISec],
          For[k=1,k\[LessEqual]Length[ISec],
            
            partI[ITypes[[i,1]]][ISec[[j]]][ISec[[k]]]=
              Table[{},{Length[PART[ISec[[j]]]]}];
            k++;];
          j++;];
        i++;];
      
      For[i=1,i\[LessEqual]Length[VertexListNonCC],
        For[j=1,j\[LessEqual]Length[VertexListNonCC[[i,1,1]]],
          p1=VertexListNonCC[[i,1,1,j]];
          pos=Position[PART[getType[p1]],getBlank[p1]][[1,1]];
          For[k=1,k\[LessEqual]Length[VertexListNonCC[[i,1,1]]],
            If[k\[NotEqual]j,
              p2=VertexListNonCC[[i,1,1,k]];
              temp = partI[VertexListNonCC[[i,2]]][getType[p1]][getType[p2]];
              temp[[pos]]=Join[temp[[pos]],{getBlank[p2]}];
              partI[VertexListNonCC[[i,2]]][getType[p1]][getType[p2]] = temp;
              ];
            k++;];
          j++;];
        i++;];
      
      For[i=1,i\[LessEqual]Length[ITypes],
        ISec=Intersection[ITypes[[i]]];
        For[j=1,j\[LessEqual]Length[ISec],
          For[k=1,k\[LessEqual]Length[ISec],
            
            partListInv[ITypes[[i,1]],ISec[[j]],ISec[[k]]]=
              Intersection/@partI[ITypes[[i,1]]][ISec[[j]]][ISec[[k]]];
            k++;];
          j++;];
        i++;];
      
      For[i=1,i\[LessEqual]Length[ITypes],
        If[Length[SA`VertexList[ITypes[[i,1]]]]>0,
          
          VerticesInv[ITypes[[i,1]]]=
            Apply[C,Transpose[SA`VertexList[ITypes[[i,1]]]][[1]] /. 
                A_[{a__}]\[Rule] A,1];
          
          VerticesOrg[ITypes[[i,1]]]=
            Transpose[SA`VertexList[ITypes[[i,1]]]][[1]];
          
          VerticesVal[ITypes[[i,1]]]=
            Transpose[SA`VertexList[ITypes[[i,1]]]][[2]];
          If[FreeQ[ITypes[[i]],F],
            
            VerticesValSUM[ITypes[[i,1]]]=
                Transpose[SA`VertexList[sum][ITypes[[i,1]]]][[2]];,
            VerticesValSUM[ITypes[[i,1]]]=
                Transpose[
                  Delete[Transpose[SA`VertexList[sum][ITypes[[i,1]]]],1]];
            ];,
          VerticesInv[ITypes[[i,1]]] = {};
          VerticesOrg[ITypes[[i,1]]] = {};
          VerticesVal[ITypes[[i,1]]] = {};
          VerticesValSUM[ITypes[[i,1]]]={};
          ];
        i++;];
      
      VerticesInv[All]=
        Flatten[{VerticesInv[FFS],VerticesInv[FFV],VerticesInv[SSS],
            VerticesInv[SSSS],VerticesInv[SSVV],
            VerticesInv[SVV],VerticesInv[SSV],VerticesInv[GGV],
            VerticesInv[GGS],VerticesInv[VVV],VerticesInv[VVVV]}];
      
      InitDiagramGeneration;
      ];


AddUnrotatedVertex[coup_,matrix_]:=Block[{pos,vertex,parts},
      If[coup[[1]]=!=SSSS && coup[[1]] =!=SSVV  && coup[[1]] =!=VVVV,
          
          pos=Position[VerticesInv[coup[[1]]],
                C[coup[[2]],coup[[3]],coup[[4]]]][[1,1]];
          vertex=Extract[VerticesValSUM[coup[[1]]],pos];
          parts=Extract[VerticesOrg[coup[[1]]],pos];
          
          pos2 = Position[parts /.  A_[{a__}]\[Rule] A,coup[[2]]][[1,1]];
          
          GT = generation /. subGC[pos2] /.subIndFinal[pos2,pos2];
          If[Length[matrix]\[Equal]0,
            
            vertex = 
                vertex /. {matrix[GT,a_]\[Rule] Delta[GT,a]}  /. 
                  sumExp\[Rule]sum;,
            
            vertex = 
                vertex /. {matrix[[1]][GT,a_]\[Rule] Delta[GT,a],
                      matrix[[2]][GT,a_]\[Rule] Delta[GT,a]} /. 
                  sumExp\[Rule]sum;
            ];
          
          If[getGen[coup[[2]]]>1,
            
            SubParticle = {getBlank[coup[[2]]][{GT,a___}]\[Rule]
                    ToExpression["U"<>ToString[getBlank[coup[[2]]]]][{GT,
                        a}]};,
            SubParticle = {};
            ];
          
          If[Length[Dimensions[vertex]]\[Equal]2,
            Return[{parts /. SubParticle,vertex[[1]],vertex[[2]]}];,
            Return[{parts /. SubParticle,vertex}];
            ];,
          
          
          pos=Position[VerticesInv[coup[[1]]],
                C[coup[[2]],conj[coup[[2]]],coup[[3]],coup[[4]]]][[1,1]];
          vertex=Extract[VerticesValSUM[coup[[1]]],pos];
          parts=Extract[VerticesOrg[coup[[1]]],pos];
          
          pos2 = Position[parts /.  A_[{a__}]\[Rule] A,coup[[2]]][[1,1]];
          If[conj[coup[[2]]]===coup[[2]],
            
            pos3 = Position[parts /.  A_[{a__}]\[Rule] A,conj[coup[[2]]]][[2,
                    1]];,
            
            pos3 = Position[parts /.  A_[{a__}]\[Rule] A,conj[coup[[2]]]][[1,
                    1]];
            ];
          
          GT1 = generation /. subGC[pos2] /.subIndFinal[pos2,pos2];
          GT2 = generation /. subGC[pos3] /.subIndFinal[pos3,pos3];
          vertex = 
            vertex /. {matrix[GT1,a_]\[Rule] Delta[GT1,a],
                  matrix[GT2,a_]\[Rule] Delta[GT2,a]}/. sumExp\[Rule]sum;
          
          If[getGen[coup[[2]]]>1,
            
            SubParticle = {getBlank[coup[[2]]][{GT1,a___}]\[Rule]ToExpression[
                        "U"<>ToString[getBlank[coup[[2]]]]][{GT1,a}],
                  getBlank[coup[[2]]][{GT2,a___}]\[Rule]ToExpression[
                        "U"<>ToString[getBlank[coup[[2]]]]][{GT2,a}]};,
            SubParticle = {};
            ];
          Return[{parts /. SubParticle,vertex}];
          ];
      ];


AddVertex[coup_]:=Block[{pos,vertex,parts},
      If[coup[[1]]=!=SSSS && coup[[1]] =!=SSVV && coup[[1]] =!=VVVV,
          
          pos=Position[VerticesInv[coup[[1]]],
                C[coup[[2]],coup[[3]],coup[[4]]]][[1,1]];
          vertex=Extract[VerticesValSUM[coup[[1]]],pos]  /. sumExp\[Rule]sum;
          parts=Extract[VerticesOrg[coup[[1]]],pos];
          If[Length[Dimensions[vertex]]\[Equal]2,
            Return[{parts,vertex[[1]],vertex[[2]]}];,
            Return[{parts,vertex}];
            ];,
          
          pos=Position[VerticesInv[coup[[1]]],
                C[coup[[2]],conj[coup[[2]]],coup[[3]],coup[[4]]]][[1,1]];
          vertex=Extract[VerticesValSUM[coup[[1]]],pos] /. sumExp\[Rule]sum;
          parts=Extract[VerticesOrg[coup[[1]]],pos];
          Return[{parts,vertex}];
          ];
      ];

SetAttributes[C,Orderless];
SetAttributes[VType,Orderless];
VType[a__]:=
  ToExpression[
    StringReplace[ToString[{a}],{"{"->"","}"->"",","->""," "->""}]] 
getVertexType[x_]:=VType@@getType/@x;

ThreeParticleVertex[x_]:=Block[{i,temp,temp2},
      temp=
        InsFields[{{C[AntiField[x],AntiField[FieldToInsert[1]],
                FieldToInsert[2]]},{Internal[1]\[Rule]FieldToInsert[1],
              Internal[2]\[Rule]FieldToInsert[2],
              External[1]\[Rule]AntiField[x]}}];
      Return[
        Select[Table[{AntiField[Internal[1]/.temp[[i,2]]],
              Internal[2]/.temp[[i,2]],
              Cp[External[1]/.temp[[i,2]],AntiField[Internal[1]/.temp[[i,2]]],
                Internal[2]/.temp[[i,2]]]},{i,1,
              Length[temp]}],(FreeQ[getType/@#1,G])&]];
      ]; 


ThreeParticleVertex2[x_]:=Block[{i,temp,temp2,symm,temp3},
      temp=
        InsFields[{{C[AntiField[x],AntiField[FieldToInsert[1]],
                FieldToInsert[2]]},{Internal[1]\[Rule]FieldToInsert[1],
              Internal[2]\[Rule]FieldToInsert[2],
              External[1]\[Rule]AntiField[x],Index[1]\[Rule]gO1,
              Index[2]\[Rule]gI1,Index[3]\[Rule]gI2}}];
      temp2=
        Select[Table[{AntiField[Internal[1]/.temp[[i,2]]],
              Internal[2]/.temp[[i,2]],
              Cp[External[1][{Index[1]}],AntiField[Internal[1][{Index[2]}]],
                  Internal[2][{Index[3]}]]/.temp[[i,2]],
              VType[getType[Internal[1]/.temp[[i,2]]],
                getType[Internal[2]/.temp[[i,2]]],
                getType[External[1]/.temp[[i,2]]]],
              CalculateColorFactor[getBlank[External[1]/.temp[[i,2]]],
                Internal[1]/.temp[[i,2]],Internal[2]/.temp[[i,2]]],
              CalculateSymmetryFactor[Internal[1]/.temp[[i,2]],
                Internal[2]/.temp[[i,2]]]},{i,1,
              Length[temp]}],(FreeQ[#1,GGS]&&FreeQ[#1,GGV])&];
      temp3={};
      For[i=1,i\[LessEqual]Length[temp2],
        If[
          FreeQ[temp3 /. a_[{b__}]\[Rule]a /. 
              Cp\[Rule]C,(AntiField/@temp2[[i,3]])/. a_[{b__}]\[Rule]a /. 
              Cp\[Rule]C],temp3=Join[temp3,{temp2[[i]]}];];
        i++;];
      Return[
        temp3 /. Map[(#1[a_]\[Rule]#1)&,
            Transpose[
                Select[Particles[Current],
                  TrueQ[getGen[#1[[1]]]\[Equal]1]&]][[1]]]];
      ];


FourParticleVertex[x_]:=
    Block[{i,temp,temp2},
      temp=InsFields[{{C[AntiField[x],AntiField[FieldToInsert[1]],
                FieldToInsert[2],
                FieldToInsert[3]]},{Internal[1]\[Rule]FieldToInsert[1],
              Internal[2]\[Rule]FieldToInsert[2],
              Internal[3]\[Rule]FieldToInsert[3],
              External[1]\[Rule]AntiField[x]}}];
      Return[
        Table[{AntiField[Internal[1]/.temp[[i,2]]],Internal[2]/.temp[[i,2]],
            Internal[3]/.temp[[i,2]],temp[[i,1,1]]/.C\[Rule]Cp},{i,1,
            Length[temp]}]];
      ];

FourParticleVertex2[x_]:=Block[{i,temp,temp2={}},
      temp=
        InsFields[{{C[AntiField[x],x,AntiField[FieldToInsert[1]],
                FieldToInsert[1]]},{Internal[1]\[Rule]FieldToInsert[1],
              External[1]\[Rule]x,Index[1]\[Rule]gO1,Index[2]\[Rule]gI1}}];
      For[i=1,i\[LessEqual]Length[temp],
        temp2= 
          Join[temp2,{{AntiField[Internal[1]/.temp[[i,2]]],
                Internal[1]/.temp[[i,2]],
                Cp[External[1][{Index[1]}],AntiField[External[1][{Index[1]}]],
                    AntiField[Internal[1][{Index[2]}]],
                    Internal[1][{Index[2]}]]/.temp[[i,2]],
                VType[getType[Internal[1]/.temp[[i,2]]],
                  getType[Internal[1]/.temp[[i,2]]],
                  getType[External[1]/.temp[[i,2]]],
                  getType[External[1]/.temp[[i,2]]]],
                CalculateColorFactor[getBlank[External[1]/.temp[[i,2]]],
                  Internal[1]/.temp[[i,2]],Internal[1]/.temp[[i,2]]],
                2 CalculateSymmetryFactor[Internal[1]/.temp[[i,2]],
                    Internal[1]/.temp[[i,2]]]}}];
        i++;];
      Return[
        temp2 /. Map[(#1[a_]\[Rule]#1)&,
            Transpose[
                Select[Particles[Current],
                  TrueQ[getGen[#1[[1]]]\[Equal]1]&]][[1]]]];
      ];

ThreeBodyDecay[p_]:=Block[{i,res1,res2,listTemp,j,k},
      process={};
      res1=ThreeParticleVertex[p];
      
      For[i=1,i\[LessEqual]Length[res1],
        If[
          getType[res1[[i,2]]]===
              F && (getType[res1[[i,1]]]=!=V || 
                FreeQ[massless,res1[[i,1]]]\[Equal]True),
          res2=ThreeParticleVertex[res1[[i,1]]];
          For[j=1,j\[LessEqual]Length[res2],
            If[getType[res2[[j,1]]]===F && getType[res2[[j,2]]] ===F,
              
              process=Join[
                    process,{{Final1\[Rule] res1[[i,2]],
                        Propagator\[Rule]res1[[i,1]],
                        Final2\[Rule] res2[[j,1]],Final3\[Rule] res2[[j,2]],
                        Couplings\[Rule]{res1[[i,3]],res2[[j,3]]}}}];
              ];
            j++;];
          ];
        
        If[
          getType[res1[[i,1]]]===
              F && (getType[res1[[i,2]]]=!=V || 
                FreeQ[massless,res1[[i,2]]]\[Equal]True),
          res2=ThreeParticleVertex[res1[[i,2]]];
          For[j=1,j\[LessEqual]Length[res2],
            If[getType[res2[[j,1]]]===F && getType[res2[[j,2]]] ===F,
              
              process=Join[
                    process,{{Final1\[Rule] res1[[i,1]],
                        Propagator\[Rule] res1[[i,2]],
                        Final2\[Rule] res2[[j,1]],Final3->res2[[j,2]],
                        Couplings\[Rule] {res1[[i,3]],res2[[j,3]]}}}];
              ];
            j++;];
          ];
        i++;];
      
      finalstates={};
      SortedProcessesTemp={};
      
      
      For[i=1,i\[LessEqual]Length[process],
        If[
          FreeQ[finalstates,
              FinalStatesNO[Final1,Final2,Final3] /. process[[i]]]\[Equal]
            True,
          
          finalstates = 
            Join[finalstates,{FinalStatesNO[Final1,Final2,Final3] /. 
                  process[[i]]}];
          
          SortedProcessesTemp=
            Join[SortedProcessesTemp,{{FinalStatesNO[Final1,Final2,Final3] /. 
                    process[[i]],process[[i]]}}];,
          
          pos=Position[SortedProcessesTemp,
              FinalStatesNO[Final1,Final2,Final3] /. process[[i]]];
          
          SortedProcessesTemp[[pos[[1,1]]]]=
            Join[SortedProcessesTemp[[pos[[1,1]]]],{process[[i]]}];
          ];
        i++;];
      
      SortedProcesses=Table[{},{Length[SortedProcessesTemp]}];
      
      For[i=1,i\[LessEqual]Length[SortedProcessesTemp],
        listTempSR={};
        listTempSC={};
        listTempVR={};
        listTempVC={};
        SortedProcesses[[i]]=SortedProcessesTemp[[i,1]];
        For[j=2,j\[LessEqual]Length[SortedProcessesTemp[[i]]],
          If[getType[Propagator /. SortedProcessesTemp[[i,j]]]===S,
            
            If[AntiField[
                    Propagator /. SortedProcessesTemp[[i,j]]]===(Propagator /. 
                      SortedProcessesTemp[[i,j]]),
                listTempSR=Join[listTempSR,{SortedProcessesTemp[[i,j]]}];,
                listTempSC=Join[listTempSC,{SortedProcessesTemp[[i,j]]}];
                ];,
            
            If[AntiField[
                    Propagator /. SortedProcessesTemp[[i,j]]]===(Propagator /. 
                      SortedProcessesTemp[[i,j]]),
                listTempVR=Join[listTempVR,{SortedProcessesTemp[[i,j]]}];,
                listTempVC=Join[listTempVC,{SortedProcessesTemp[[i,j]]}];
                ];
            ];
          j++;];
         SortedProcesses[[i]]=
          Join[{SortedProcesses[[i]]},
            Join[Join[listTempVR,listTempVC],Join[listTempSC,listTempSR]]]; 
        i++;];
      
      finalstates={};
      For[i=1,i\[LessEqual]Length[SortedProcesses],
        SortedProcesses[[i,1]]=
          FinalStates[Final1,Final2,Final3] /. SortedProcesses[[i,2]];
        finalstates=
          Join[finalstates,{FinalStates[Final1,Final2,Final3] /. 
                SortedProcesses[[i,2]]}];
        i++;];
      
      Return[{finalstates,SortedProcesses}];
      ];

SetAttributes[FinalStatesNO,Orderless];

TwoBodyDecay[p_]:=Block[{i,res1,res2,addedP},
      process={};
      res1=ThreeParticleVertex[p];
      addedP={};
      
      For[i=1,i\[LessEqual]Length[res1],
        If[
          FreeQ[addedP,C[res1[[i,1]],res1[[i,2]]]] && 
            FreeQ[addedP,C[AntiField[res1[[i,1]]],AntiField[res1[[i,2]]]]],
          
          If[((FreeQ[massless,getBlank[res1[[i,1]]]]\[Equal]True || 
                      getType[res1[[i,1]]]=!=
                        V) &&  (FreeQ[massless,getBlank[res1[[i,2]]]]\[Equal]
                        True || getType[res1[[i,1]]]=!=V)),
              
              process=Join[
                  process,{{res1[[i,1]],res1[[i,2]],res1[[i,3]],
                      CalculateColorFactorDecay[p,res1[[i,1]],res1[[i,2]]],
                      SymmFactor2BodyDecay[p,res1[[i,1]],res1[[i,2]]]}}];
              addedP=Join[addedP,{C[res1[[i,1]],res1[[i,2]]]}];
              ];
          ];
        i++;];
      Return[process];
      ];


SymmFactor2BodyDecay[pD_,p1_,p2_]:=Block[{},
      If[getType[getBlank[pD]]===S,
          If[getBlank[p1]===getBlank[p2],
              If[AntiField[p1]===p1,
                  Return[1/2];,
                  Return[1];
                  ];,
              Return[1];
              ];,
          If[AntiField[p1]===p1 &&  AntiField[p2]===p2,
              Return[1/2];,
              Return[1];
              ];
          ];
      ];

CalculateColorFactor[pD_,p1_,p2_]:=ChargeFactor[pD,p1,p2];
CalculateColorFactorDecay[pD_,p1_,p2_]:=ChargeFactor[pD,p1,p2];

ChargeFactor[External_,Int1_,Int2_]:=Block[{pos,temp},
      pos=Select[{Position[getBlank/@Gauginos,getBlank[External]]/2,
            Position[getBlank/@SGauge,getBlank[External]]},(#1=!={})&];
      If[pos=!={},
        If[Gauge[[pos[[1,1,1]],2]]=!=U[1],
            Return[SA`Dynkin[getBlank[Int1],pos[[1,1,1]]]/.diracSubBack];,
            Return[1];
            ];
        ];
      pos = Select[{Position[getBlank/@Gauginos,getBlank[Int1]]/2,
            Position[getBlank/@SGauge,getBlank[Int1]],
            Position[getBlank/@Gauginos,getBlank[Int2]]/2,
            Position[getBlank/@SGauge,getBlank[Int2]]},(#1=!={})&];
      If[pos=!={},
        If[Gauge[[pos[[1,1,1]],2]]=!=U[1],
            Return[SA`Casimir[getBlank[External],pos[[1,1,1]]]];,
            Return[1];
            ];
        ];
      
      If[Select[
            getIndexRange[
              Int1],(FreeQ[getIndexRange[External],#1] \[Equal]False && 
                  FreeQ[getIndexRange[Int2],#1] \[Equal]False  && #1[[1]]=!=
                    generation)&]=!={},
        Return[999];
        ];
      
      temp=
        Select[getIndexRange[
            Int1],(FreeQ[getIndexRange[External],#1] && #1[[1]]=!=
                  generation)&];
      If[temp=!={},
        Return[Times@@Transpose[temp][[2]]];,
        Return[1];
        ];
      ]; 

CalculateSymmetryFactor[p1_,p2_]:=Block[{},
      fac=1/2;
      If[getBlank[p1]=!=getBlank[p2],
        If[(AntiField[p1]===p1 && AntiField[p2]===p2),
          fac= fac;,
          fac=2fac;
          ];
        fac=fac;
        ];
      
      If[getBlank[p1]===getBlank[p2] && AntiField[p1]===p1,
        fac=1/2fac;
        ];
      
      Return[fac];
      ]; 